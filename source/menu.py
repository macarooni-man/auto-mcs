from PIL.ImageFilter import GaussianBlur
from datetime import datetime as dt
from PIL import Image as PILImage
from ctypes import ArgumentError
from pypresence import Presence
from plyer import filechooser
from random import randrange
from PIL import ImageEnhance
import simpleaudio as sa
from pathlib import Path
from glob import glob
import webbrowser
import traceback
import functools
import threading
import inspect
import random
import json
import yaml
import time
import math
import sys
import os
import re


# Local imports
import amseditor
import logviewer
import constants
import crashmgr
import amscript
import telepath
import addons
import backup
import acl

if constants.os_name == "windows":
    import tkinter as tk
    from tkinter import filedialog

# Control modifier for keyboard shortcuts
control = 'meta' if constants.os_name == "macos" else 'ctrl'

# Disable Kivy logging if debug is off and app is compiled
if constants.app_compiled and constants.debug is False:
    kivy_folder = os.path.join(constants.os_temp, ".kivy")
    constants.folder_check(kivy_folder)
    os.environ['KIVY_HOME'] = kivy_folder


os.environ["KCFG_KIVY_LOG_LEVEL"] = "debug" if constants.debug else "info"
os.environ["KIVY_IMAGE"] = "pil,sdl2"
os.environ['KIVY_NO_ARGS'] = '1'
os.environ["KIVY_METRICS_DENSITY"] = "1"

from kivy.config import Config
Config.set('graphics', 'maxfps', '120')
Config.set('graphics', 'vsync', '-1')
Config.set('input', 'mouse', 'mouse,multitouch_on_demand')
Config.set('graphics', 'window_state', 'hidden')
Config.set('kivy', 'exit_on_escape', '0')


# Import kivy elements
from kivy.clock import Clock
from kivy.cache import Cache
from kivy.uix.label import Label
from kivy.uix.widget import Widget
from kivy.animation import Animation
from kivy.uix.textinput import TextInput
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.gridlayout import GridLayout
from kivy.uix.scrollview import ScrollView
from kivy.uix.recycleview import RecycleView
from kivy.uix.anchorlayout import AnchorLayout
from kivy.uix.togglebutton import ToggleButton
from kivy.uix.relativelayout import RelativeLayout
from kivy.input.providers.mouse import MouseMotionEvent
from kivy.uix.recyclegridlayout import RecycleGridLayout
from kivy.graphics import Color, Rectangle, Ellipse, Line
from kivy.uix.screenmanager import ScreenManager, Screen, NoTransition, FadeTransition


import kivy
kivy.require('2.0.0')
from kivy.app import App
from kivy.metrics import sp, dp
from kivy.uix.button import Button
from kivy.uix.slider import Slider
from kivy.core.window import Window
from kivy.uix.dropdown import DropDown
from kivy.core.clipboard import Clipboard
from kivy.uix.image import Image, AsyncImage
from kivy.uix.floatlayout import FloatLayout
from kivy.properties import BooleanProperty, ObjectProperty, ListProperty



# Discord rich presence
class DiscordPresenceManager():
    def __init__(self):
        self.presence = None
        self.connected = False
        self.updating_presence = False
        self.splash = constants.session_splash.replace('â€ˆ', '')
        self.id = "1293773204552421429"
        self.start_time = 0
        if constants.app_config.discord_presence:
            self.start()

    def start(self):
        if not self.connected:
            self.presence = Presence(self.id)
            self.start_time = int(time.time())
            def presence_thread(*a):
                try:
                    self.presence.connect()
                    self.connected = True
                    print("Discord Presence: Connected")
                except:
                    self.presence = None
                    print("Discord Presence: Failed to connect")
            threading.Timer(0, presence_thread).start()

    def stop(self):
        if self.connected:
            self.presence.close()
            self.start_time = None
            self.presence = None
            self.connected = False
            print("Discord Presence: Disconnected")

    def get_image(self, file_path: str):
        server_obj = constants.server_manager.current_server
        try:
            if 'rich-presence-icon' in server_obj.run_data:
                return server_obj.run_data['rich-presence-icon']
        except:
            pass

        url = 'https://0x0.st'
        files = {'file': open(file_path, 'rb')}
        response = constants.requests.post(url, files=files, headers={'User-Agent': f'{constants.app_title}/{constants.app_version}'})
        if response.status_code == 200:
            url = response.text.strip()

            # Cache icon for later retrieval
            server_obj.run_data['rich-presence-icon'] = url
            return url
        elif constants.debug:
            print("Upload failed:", response.text)
            return None

    def update_presence(self, footer_data: str = None):
        if not self.presence:
            return False

        def do_update(*a):
            self.updating_presence = True
            def update(*a):
                if not self.connected:
                    for x in range(50):
                        if self.connected:
                            break
                        time.sleep(0.2)
                    else:
                        return False

                if footer_data:
                    footer_path = footer_data.replace('$','')
                    overrides = {
                        'splash': ('Main Menu', self.splash)
                    }

                    details = None
                    state = None
                    large = 'https://raw.githubusercontent.com/macarooni-man/auto-mcs/refs/heads/main/source/gui-assets/big-icon.png'

                    # Override for running server
                    if constants.server_manager.current_server and constants.server_manager.current_server.running and screen_manager.current == 'ServerViewScreen':
                        server_obj = constants.server_manager.current_server
                        details = f"Running '{server_obj.name}'"
                        if server_obj._telepath_data:
                            details = f"Telepath - running '{server_obj.name}'"
                        state = f'{server_obj.type.replace("craft", "").title()} {server_obj.version}'

                        # Custom arguments for customization
                        if 'player-list' in server_obj.run_data:
                            current = len([p for p in server_obj.run_data['player-list'].values() if p['logged-in']])
                        else:
                            current = 0

                        if current:
                            args = {'party_size': [int(current), int(server_obj.server_properties['max-players'])]}
                        else:
                            args = {}

                        # Get server icon
                        if server_obj.server_icon:
                            if server_obj._telepath_data:
                                icon_path = constants.get_server_icon(server_obj.name, server_obj._telepath_data)
                            else:
                                icon_path = server_obj.server_icon
                            args['small_image'] = self.get_image(icon_path)
                        else:
                            args['small_image'] = f'https://github.com/macarooni-man/auto-mcs/blob/main/source/gui-assets/icons/big/{server_obj.type}_small.png?raw=true'

                        args['small_text'] = f"{server_obj.name} - {state}"
                        self.presence.update(state=state, details=details, start=self.start_time, large_image=large, **args)

                        return True


                    elif footer_path in overrides:
                        details = overrides[footer_path][0]
                        state = overrides[footer_path][1]


                    elif 'amscript IDE' in footer_path:
                        details, state = footer_path.split(' > ', 1)
                        image = 'https://github.com/macarooni-man/auto-mcs/blob/main/source/gui-assets/amscript-icon.png?raw=true'
                        self.presence.update(state=state, details=details, start=self.start_time, small_image=image, small_text='amscript IDE', large_image=large)

                        return True


                    elif 'Telepath' in footer_path:
                        if ' > ' in footer_path:
                            details, state = footer_path.split(' > ', 1)
                        else:
                            details, state = 'Telepath', self.splash
                        image = 'https://github.com/macarooni-man/auto-mcs/blob/main/source/gui-assets/icons/telepath.png?raw=true'
                        self.presence.update(state=state, details=details, start=self.start_time, small_image=image, small_text='Telepath', large_image=large)

                        return True


                    elif ' > ' in footer_path:
                        details, state = footer_path.split(' > ', 1)
                        if constants.server_manager.current_server and details == 'Server Manager':
                            server_obj = constants.server_manager.current_server
                            if server_obj._telepath_data:
                                details = f"Telepath - '{server_obj.name}'"
                            else:
                                details = f"Server Manager - '{server_obj.name}'"

                    else:
                        details = footer_path
                        state = self.splash


                    if details and state:
                        self.presence.update(state=state, details=details, start=self.start_time, large_image=large)

                else:
                    pass
            update()
            self.updating_presence = False
        if not self.updating_presence:
            threading.Timer(0, do_update).start()
constants.discord_presence = DiscordPresenceManager()
def toggle_discord_presence():
    if constants.discord_presence.connected:
        constants.discord_presence.stop()
        banner_text = f"$Discord$ rich presence is now disabled"
        banner_color = (0.937, 0.831, 0.62, 1)
        banner_icon = "discord-strike.png"
        constants.app_config.discord_presence = False
    else:
        constants.discord_presence.start()
        constants.discord_presence.update_presence(constants.footer_path)
        banner_text = f"$Discord$ rich presence is now enabled"
        banner_color = (0.553, 0.902, 0.675, 1)
        banner_icon = "discord.png"
        constants.app_config.discord_presence = True

    Clock.schedule_once(
        functools.partial(
            screen_manager.current_screen.show_banner,
             banner_color,
            banner_text,
            banner_icon,
            2.5,
            {"center_x": 0.5, "center_y": 0.965}
        ), 0
    )


# Override Kivy widgets for translation
size_dict = {'down': [], 'up': []}

# Generates manual overrides for string resizing. Run this function with locale changes, and on startup
def size_list(*a):
    scale_up = ['back-ups', 'launch']
    scale_down = ['ADD RULES...', 'QUIT']
    size_dict['up'] = [constants.translate(i).lower() for i in scale_up]
    size_dict['down'] = [constants.translate(i).lower() for i in scale_down]
size_list()

def scale_size(obj, o, n, *a):
    if o and n and obj.__o_size__:
        diff = len(n) - len(o)
        parent_class = obj.parent.__class__.__name__
        new_size = None

        # Ignore on certain screens
        if screen_manager.current.endswith('ProgressScreen') or r'[ref=none]' in obj.text:
            return None

        # Ignore header resizing
        if parent_class not in ('HeaderText'):
            new_size = round(diff * 0.4)

        if new_size:

            # Make text bigger
            if obj.text.strip().lower() in size_dict['up'] or parent_class in ('IconButton'):
                new_size = round(new_size / 2)

            # Make text smaller
            if obj.text.strip().lower() in size_dict['down']:
                new_size = new_size * 2

            # Change popup sizes
            if (screen_manager.current_screen.popup_widget and parent_class == 'RelativeLayout'):
                if screen_manager.current_screen.popup_widget.window_background.width > 500:
                    new_size = round(new_size / 32)
                else:
                    new_size = round(new_size / 5)

            # Set a floor for resize
            if obj.__o_size__ - new_size < obj.__o_size__ - 4:
                new_size = 4

            # Change y-center of Input
            if obj.__class__.__name__.endswith('Input'):
                obj.padding_y = (11 + new_size, 11 + new_size)

            obj.font_size = obj.__o_size__ - new_size
def filter_text(string):
    if isinstance(string, str) and "$" in string:
        return re.sub(r'\$([^\$]+)\$', '\g<1>', string)
    else:
        return string
class Label(Label):
    def __init__(self, *args, **kwargs):
        self.__translate__ = True
        self.__o_size__ = None
        super().__init__(*args, **kwargs)

    def __setattr__(self, key, value):
        if constants.app_config.locale != 'en':
            if key == 'font_size' and not self.__o_size__:
                self.__o_size__ = value
            if key in ['text'] and isinstance(value, str) and not value.isnumeric() and value.strip() and self.__translate__:
                o = value
                value = constants.translate(value)
                Clock.schedule_once(functools.partial(scale_size, self, o, value), 0)
        elif constants.app_config.locale == 'en' and key in ['text']:
            value = filter_text(value)
        super().__setattr__(key, value)
class Button(Button):
    def __init__(self, *args, **kwargs):
        self.__translate__ = True
        self.__o_size__ = None
        super().__init__(*args, **kwargs)

    def __setattr__(self, key, value):
        if constants.app_config.locale != 'en':
            if key == 'font_size' and not self.__o_size__:
                self.__o_size__ = value
            if key in ['text'] and isinstance(value, str) and not value.isnumeric() and value.strip() and self.__translate__:
                o = value
                value = constants.translate(value)
                Clock.schedule_once(functools.partial(scale_size, self, o, value), 0)
        elif constants.app_config.locale == 'en' and key in ['text']:
            value = filter_text(value)
        super().__setattr__(key, value)
class TextInput(TextInput):
    def __init__(self, *args, **kwargs):
        self.__translate__ = True
        self.__o_size__ = None
        super().__init__(*args, **kwargs)

    def __setattr__(self, key, value):
        if constants.app_config.locale != 'en':
            if key == 'font_size' and not self.__o_size__:
                self.__o_size__ = value
            if key in ['hint_text'] and isinstance(value, str) and not value.isnumeric() and value.strip() and self.__translate__:
                o = value
                value = constants.translate(value)
                Clock.schedule_once(functools.partial(scale_size, self, o, value), 0)
        elif constants.app_config.locale == 'en' and key in ['hint_text']:
            value = filter_text(value)

        if key in ['focus', 'focused']:
            try:
                super().__setattr__(key, value)
            except:
                pass
        else:
            super().__setattr__(key, value)


# Opens text file with logviewer
def view_file(path: str, title=None):
    data_dict = {
        'app_title': constants.app_title,
        'gui_assets': constants.gui_assets,
        'background_color': constants.background_color,
        'sub_processes': constants.sub_processes,
        'os_name': constants.os_name,
        'translate': constants.translate
    }

    if not title and constants.server_manager.current_server:
        title = constants.server_manager.current_server.name

    Clock.schedule_once(
        functools.partial(
            logviewer.open_log,
            title,
            path,
            data_dict
        ), 0.1
    )


def icon_path(name):
    return os.path.join(constants.gui_assets, 'icons', name)


# Custom widget attributes
class HoverBehavior(object):
    """Hover behavior.
    :Events:
        `on_enter`
            Fired when mouse enter the bbox of the widget.
        `on_leave`
            Fired when the mouse exit the widget
    """

    hovered = BooleanProperty(False)
    border_point = ObjectProperty(None)
    '''Contains the last relevant point received by the Hoverable. This can
    be used in `on_enter` or `on_leave` in order to know where was dispatched the event.
    '''

    def __init__(self, *args, **kwargs):
        self.register_event_type('on_enter')
        self.register_event_type('on_leave')
        Window.bind(mouse_pos=self.on_mouse_pos)
        super(HoverBehavior, self).__init__(**kwargs)
        self.id = ''

    def on_mouse_pos(self, *args):

        # Ignore if context menu is visible
        context_menu = screen_manager.current_screen.context_menu
        if context_menu and not (self.id.startswith('list_') and self.id.endswith('_button')):
            return


        if not self.get_root_window() or self.disabled:
            return  # do proceed if I'm not displayed <=> If there's no parent
        pos = args[1]
        # Next line to_widget allow to compensate for relative layout
        inside = self.collide_point(*self.to_widget(*pos))

        if self.hovered == inside:
            #We have already done what was needed
            return
        self.border_point = pos
        self.hovered = inside
        if inside:
            self.dispatch('on_enter')
        else:
            self.dispatch('on_leave')

    def on_enter(self):
        pass

    def on_leave(self):
        pass

from kivy.lang import Builder
from kivy.factory import Factory
Factory.register('HoverBehavior', HoverBehavior)


def animate_button(self, image, color, **kwargs):
    image_animate = Animation(**kwargs, duration=0.05)

    def f(w):
        w.background_normal = image

    for child in self.parent.children:
        if child.id == 'text':
            Animation(color=color, duration=0.06).start(child)
        if child.id == 'icon':
            Animation(color=color, duration=0.06).start(child)

    a = Animation(duration=0.0)
    a.on_complete = functools.partial(f)

    image_animate += a

    image_animate.start(self)



def animate_icon(self, image, colors, hover_action, **kwargs):
    image_animate = Animation(**kwargs, duration=0.05)

    def f(w):
        w.background_normal = image

    for child in self.parent.children:
        if child.id == 'text':
            if hover_action:
                try:
                    color = child.hover_color
                except:
                    child.hover_color = None

                if child.hover_color:
                    Animation(color=child.hover_color, duration=0.12).start(child)
                else:
                    Animation(color=colors[1] if not self.selected else (0.6, 0.6, 1, 1), duration=0.12).start(child)
            else:
                Animation(color=(0, 0, 0, 0), duration=0.12).start(child)

        if child.id == 'icon':
            if hover_action:
                Animation(color=colors[0], duration=0.06).start(child)
            else:
                Animation(color=colors[1], duration=0.06).start(child)

    a = Animation(duration=0.0)
    a.on_complete = functools.partial(f)

    image_animate += a

    image_animate.start(self)



class HoverButton(Button, HoverBehavior):

    # self.id references image patterns
    # self.color_id references text/image color [hovered, un-hovered]

    color_id = [(0, 0, 0, 0), (0, 0, 0, 0)]
    alt_color = ''
    ignore_hover = False

    # Ignore touch events when popup is present
    def on_touch_down(self, touch):
        popup_widget = screen_manager.current_screen.popup_widget
        if popup_widget:
            return
        else:
            return super().on_touch_down(touch)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.bind(on_touch_down=self.onPressed)
        self.button_pressed = None
        self.selected = False
        self.context_options = []
        self.id = ''

    def onPressed(self, instance, touch):
        if touch.device == "wm_touch":
            touch.button = "left"

        self.button_pressed = touch.button

        # Show context menu if available
        if touch.button == 'right' and self.collide_point(*touch.pos):
            self.update_context_options()
            if self.context_options:
                screen_manager.current_screen.show_context_menu(self, self.context_options)

    def on_enter(self, *args):
        if not self.ignore_hover:

            if 'icon_button' in self.id:
                if self.selected:
                    animate_icon(self, image=os.path.join(constants.gui_assets, f'{self.id}_selected.png'), colors=[(0.05, 0.05, 0.1, 1), (0.05, 0.05, 0.1, 1)], hover_action=True)
                else:
                    animate_icon(self, image=os.path.join(constants.gui_assets, f'{self.id}_hover{self.alt_color}.png'), colors=self.color_id, hover_action=True)
            else:
                animate_button(self, image=os.path.join(constants.gui_assets, f'{self.id}_hover.png'), color=self.color_id[0])

    def on_leave(self, *args):
        if not self.ignore_hover:

            if 'icon_button' in self.id:
                if self.selected:
                    animate_icon(self, image=os.path.join(constants.gui_assets, f'{self.id}_selected.png'), colors=[(0.05, 0.05, 0.1, 1), (0.05, 0.05, 0.1, 1)], hover_action=False)
                else:
                    animate_icon(self, image=os.path.join(constants.gui_assets, f'{self.id}.png'), colors=self.color_id, hover_action=False)
            else:
                animate_button(self, image=os.path.join(constants.gui_assets, f'{self.id}.png'), color=self.color_id[1])

    def on_press(self):
        self.on_mouse_pos(self, Window.mouse_pos)

        # Log for crash info
        try:
            widget_text = None
            for widget in self.parent.children:
                if "Label" in widget.__class__.__name__:
                    widget_text = widget.text
                    break
            if "_" in str(self.id):
                interaction = str(''.join([x.title() for x in self.id.split("_")]))
            else:
                interaction = str(self.id)
            if widget_text:
                interaction += f" ({widget_text.title().replace('Mcs', 'MCS')})"
            constants.last_widget = interaction + f" @ {constants.format_now()}"
        except:
            pass

    def force_click(self, *args):
        touch = MouseMotionEvent("mouse", "mouse", Window.center)
        touch.button = 'left'
        touch.pos = Window.center
        self.dispatch('on_touch_down', touch)

        screen_manager.current_screen._keyboard.release()
        self.on_enter()
        self.trigger_action(0.1)

    # Optional hook to override for updating context options dynamically
    def update_context_options(self):
        pass

# -----------------------------------------------------  Labels  -------------------------------------------------------
class InputLabel(RelativeLayout):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.id = 'InputLabel'
        self.text_size = sp(21)

        self.text = Label()
        self.text.id = 'text'
        self.text.text = "Invalid input"
        self.text.font_size = self.text_size
        self.text_x = self.text.x
        self.text.x += dp(15)
        self.text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
        self.text.color = (1, 0.53, 0.58, 0)

        self.icon = Image()
        self.icon.id = 'icon'
        self.icon.source = os.path.join(constants.gui_assets, 'icons', 'alert-circle-outline.png')
        self.icon.color = (1, 0.53, 0.58, 0)
        self.icon_x = self.icon.x
        self.icon.x -= dp((len(self.text.text) * (self.text_size - 8)) / 3) - dp(20)

        self.add_widget(self.text)
        self.add_widget(self.icon)


    def disable_text(self, disable):

        break_loop = False
        for child in self.parent.children:
            if break_loop:
                break

            elif child.__class__.__name__ == 'FloatLayout':
                for item in child.children:
                    try:
                        if item.id == 'next_button':
                            item.disable(disable)
                            break_loop = True
                            break

                    except AttributeError:
                        pass


    def update_text(self, text, warning=False):

        chosen_color = (0.3, 0.75, 1, 1) if warning else (1, 0.53, 0.58, 1)
        start_color = (0.3, 0.75, 1, 0) if warning else (1, 0.53, 0.58, 0)

        def change_color(item):
            item.color = start_color
            Animation(color=chosen_color, duration=0.12).start(item)

        for child in self.children:
            if child.id == 'text':
                child.text = text
                child.x = self.text_x + dp(15)

                if [round(x, 2) for x in child.color] != [round(x, 2) for x in chosen_color]:
                    change_color(child)
            else:
                child.source = os.path.join(constants.gui_assets, 'icons', 'alert-circle-outline.png')
                child.x = self.icon_x - dp((len(text) * (self.text_size - 8)) / 3) - dp(20)

                if [round(x, 2) for x in child.color] != [round(x, 2) for x in chosen_color]:
                    change_color(child)


    def clear_text(self):
        for child in self.children:
            new_color = (child.color[0], child.color[1], child.color[2], 0)
            Animation(color=new_color, duration=0.12).start(child)

            def reset_color(item, *args):
                item.color = (1, 0.53, 0.58, 0)

            Clock.schedule_once(functools.partial(reset_color, child), 0.12)


class BaseInput(TextInput):

    def _on_focus(self, instance, value, *largs):
        super()._on_focus(instance, value, *largs)

        # Log for crash info
        if value:
            try:
                interaction = str(self.__class__.__name__)
                if self.title.text:
                    interaction += f" ({self.title.text.title()})"
                constants.last_widget = interaction + f" @ {constants.format_now()}"
            except:
                pass

        # Update screen focus value on next frame
        def update_focus(*args):
            screen_manager.current_screen._input_focused = self.focus
        Clock.schedule_once(update_focus, 0)


    def grab_focus(self, *a):
        def focus_later(*args):
            self.focus = True
        Clock.schedule_once(focus_later, 0)


    def fix_overscroll(self, *args):

        if self.cursor_pos[0] < (self.x):
            self.scroll_x = 0


    def update_rect(self, *args):
        self.rect.source = os.path.join(constants.gui_assets, f'text_input_cover{"" if self.focused else "_fade"}.png')

        self.title.text = self.title_text
        self.rect.width = (len(self.title.text) * 16) + 116 if self.title.text else 0
        if self.width > 500:
            self.rect.width += (self.width - 500)
        self.rect.pos = self.pos[0] + (self.size[0] / 2) - (self.rect.size[0] / 2) - 1, self.pos[1] + 45
        self.title.pos = self.pos[0] + (self.size[0] / 2) - (self.title.size[0] / 2), self.pos[1] + 4
        Animation(opacity=(0.85 if self.text and self.title_text else 0), color=self.foreground_color, duration=0.06).start(self.title)
        Animation(opacity=(1 if self.text and self.title_text else 0), duration=0.08).start(self.rect)

        if self.disabled:
            Animation.stop_all(self.title)
            c = self.foreground_color
            self.title.opacity = 0.85
            self.title.color = (c[0], c[1], c[2], 0.4)

        # Auto position cursor at end if typing
        if self.cursor_index() == len(self.text) - 1:
            self.do_cursor_movement('cursor_end', True)
            Clock.schedule_once(functools.partial(self.do_cursor_movement, 'cursor_end', True), 0.01)


    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.title_text = "InputTitle"
        self.is_valid = True

        self.multiline = False
        self.size_hint_max = (500, 54)
        self.border = (-15, -15, -15, -15)
        self.background_normal = os.path.join(constants.gui_assets, f'text_input.png')
        self.background_active = os.path.join(constants.gui_assets, f'text_input_selected.png')
        self.background_disabled_normal = self.background_normal

        self.halign = "center"
        self.hint_text_color = (0.6, 0.6, 1, 0.4)
        self.foreground_color = (0.6, 0.6, 1, 1)
        self.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
        self.font_size = sp(22)
        self.padding_y = (12, 12)
        self.cursor_color = (0.55, 0.55, 1, 1)
        self.cursor_width = dp(3)
        self.selection_color = (0.5, 0.5, 1, 0.4)

        with self.canvas.after:
            self.rect = Image(size=(100, 15), color=screen_manager.current_screen.background_color, opacity=0, allow_stretch=True, keep_ratio=False)
            self.title = AlignLabel(halign="center", text=self.title_text, color=self.foreground_color, opacity=0, font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["regular"]}.ttf'))
            self.bind(pos=self.update_rect)
            self.bind(size=self.update_rect)
            self.bind(text=self.update_rect)
            self.bind(foreground_color=self.update_rect)
            self.bind(focused=self.update_rect)

        if self.disabled:
            c = self.foreground_color
            self.disabled_foreground_color = (c[0], c[1], c[2], 0.4)
            self.background_color = (1, 1, 1, 0.4)

        self.bind(cursor_pos=self.fix_overscroll)


    # Ignore popup text
    def insert_text(self, substring, from_undo=False):
        if screen_manager.current_screen.popup_widget:
            return None

        super().insert_text(substring, from_undo)


    def valid_text(self, boolean_value, text):
        pass

    #               if error       visible text
    def valid(self, boolean_value, text=True):

        if boolean_value:

            # Hide text
            self.valid_text(boolean_value, text)
            self.is_valid = True

            self.background_normal = os.path.join(constants.gui_assets, f'text_input.png')
            self.background_active = os.path.join(constants.gui_assets, f'text_input_selected.png')
            self.hint_text_color = (0.6, 0.6, 1, 0.4)
            self.foreground_color = (0.6, 0.6, 1, 1)
            self.cursor_color = (0.55, 0.55, 1, 1)
            self.selection_color = (0.5, 0.5, 1, 0.4)

        else:

            # Show error
            self.valid_text(boolean_value, text)
            self.is_valid = False

            self.background_normal = os.path.join(constants.gui_assets, f'text_input_invalid.png')
            self.background_active = os.path.join(constants.gui_assets, f'text_input_invalid_selected.png')
            self.hint_text_color = (1, 0.6, 0.6, 0.4)
            self.foreground_color = (1, 0.56, 0.6, 1)
            self.cursor_color = (1, 0.52, 0.55, 1)
            self.selection_color = (1, 0.5, 0.5, 0.4)

    # Ignore touch events when popup is present
    def on_touch_down(self, touch):
        popup_widget = screen_manager.current_screen.popup_widget
        if popup_widget:
            return
        else:
            return super().on_touch_down(touch)

    # Special keypress behaviors
    def keyboard_on_key_down(self, window, keycode, text, modifiers):

        if keycode[1] == "backspace" and control in modifiers:
            original_index = self.cursor_col
            new_text, index = constants.control_backspace(self.text, original_index)
            self.select_text(original_index - index, original_index)
            self.delete_selection()
        else:
            super().keyboard_on_key_down(window, keycode, text, modifiers)

class BigBaseInput(BaseInput):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.title_text = "InputTitle"
        self.is_valid = True

        self.multiline = False
        self.size_hint_max = (400, 100)
        self.border = (-15, -15, -15, -15)
        self.background_normal = os.path.join(constants.gui_assets, f'big_input.png')
        self.background_active = os.path.join(constants.gui_assets, f'big_input_selected.png')
        self.background_disabled_normal = self.background_normal

        self.halign = "center"
        self.hint_text_color = (0.6, 0.6, 1, 0.4)
        self.foreground_color = (0.6, 0.6, 1, 1)
        self.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
        self.font_size = sp(22)
        self.padding_y = (12, 12)
        self.cursor_color = (0.55, 0.55, 1, 1)
        self.cursor_width = dp(3)
        self.selection_color = (0.5, 0.5, 1, 0.4)

        with self.canvas.after:
            self.rect = Image(size=(100, 15), color=screen_manager.current_screen.background_color, opacity=0, allow_stretch=True, keep_ratio=False)
            self.title = AlignLabel(halign="center", text=self.title_text, color=self.foreground_color, opacity=0, font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["regular"]}.ttf'))
            self.bind(pos=self.update_rect)
            self.bind(size=self.update_rect)
            self.bind(text=self.update_rect)
            self.bind(foreground_color=self.update_rect)
            self.bind(focused=self.update_rect)

        if self.disabled:
            c = self.foreground_color
            self.disabled_foreground_color = (c[0], c[1], c[2], 0.4)
            self.background_color = (1, 1, 1, 0.4)

        self.bind(cursor_pos=self.fix_overscroll)


    def update_rect(self, *args):
        self.rect.source = os.path.join(constants.gui_assets, f'text_input_cover{"" if self.focused else "_fade"}.png')

        self.title.text = self.title_text
        self.rect.width = (len(self.title.text) * 16) + 116 if self.title.text else 0
        if self.width > 500:
            self.rect.width += (self.width - 500)
        self.rect.pos = self.pos[0] + (self.size[0] / 2) - (self.rect.size[0] / 2) - 1, self.pos[1] + 43 + 50
        self.title.pos = self.pos[0] + (self.size[0] / 2) - (self.title.size[0] / 2), self.pos[1] + 2 + 50
        Animation(opacity=(0.85 if self.text and self.title_text else 0), color=self.foreground_color, duration=0.06).start(self.title)
        Animation(opacity=(1 if self.text and self.title_text else 0), duration=0.08).start(self.rect)

        if self.disabled:
            Animation.stop_all(self.title)
            c = self.foreground_color
            self.title.opacity = 0.85
            self.title.color = (c[0], c[1], c[2], 0.4)

        # Auto position cursor at end if typing
        if self.cursor_index() == len(self.text) - 1:
            self.do_cursor_movement('cursor_end', True)
            Clock.schedule_once(functools.partial(self.do_cursor_movement, 'cursor_end', True), 0.01)

    #               if error       visible text
    def valid(self, boolean_value, text=True):

        if boolean_value:

            # Hide text
            self.valid_text(boolean_value, text)
            self.is_valid = True

            self.background_normal = os.path.join(constants.gui_assets, f'big_input.png')
            self.background_active = os.path.join(constants.gui_assets, f'big_input_selected.png')
            self.hint_text_color = (0.6, 0.6, 1, 0.4)
            self.foreground_color = (0.6, 0.6, 1, 1)
            self.cursor_color = (0.55, 0.55, 1, 1)
            self.selection_color = (0.5, 0.5, 1, 0.4)

        else:

            # Show error
            self.valid_text(boolean_value, text)
            self.is_valid = False

            self.background_normal = os.path.join(constants.gui_assets, f'big_input_invalid.png')
            self.background_active = os.path.join(constants.gui_assets, f'big_input_invalid_selected.png')
            self.hint_text_color = (1, 0.6, 0.6, 0.4)
            self.foreground_color = (1, 0.56, 0.6, 1)
            self.cursor_color = (1, 0.52, 0.55, 1)
            self.selection_color = (1, 0.5, 0.5, 0.4)


class SearchButton(HoverButton):

    # Execute search on click
    def on_touch_down(self, touch):
        if self.collide_point(touch.x, touch.y):
            for child in self.parent.children:
                if child.id == "search_input":
                    child.focus = False
                    if child.text and self.parent.previous_search != child.text:
                        self.parent.execute_search(child.text)
                    return True

        return super().on_touch_down(touch)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.icon = os.path.join(constants.gui_assets, 'icons', 'search-sharp.png')
        self.id = "search_button"
        self.border = (0, 0, 0, 0)
        self.background_normal = self.icon
        self.background_down = self.icon
        self.color_id = [(0.341, 0.353, 0.596, 1), (0.542, 0.577, 0.918, 1)]
        self.background_color = self.color_id[0]

    def on_enter(self, *args):
        if not self.ignore_hover:
            Animation(background_color=self.color_id[1], duration=0.12).start(self)

    def on_leave(self, *args):
        if not self.ignore_hover:
            Animation(background_color=self.color_id[0], duration=0.12).start(self)

class SearchInput(BaseInput):

    def __init__(self, return_function, allow_empty=False, **kwargs):
        super().__init__(**kwargs)
        self.allow_empty = allow_empty
        self.id = "search_input"
        self.title_text = ""
        self.hint_text = "enter a query..."
        self.halign = "left"
        self.padding_x = 24
        self.background_normal = os.path.join(constants.gui_assets, f'search_input.png')
        self.background_active = os.path.join(constants.gui_assets, f'search_input_selected.png')
        self.bind(on_text_validate=self.on_enter)


    def on_enter(self, value):
        if (self.text or self.allow_empty) and self.parent.previous_search != self.text:
            self.parent.execute_search(self.text)


    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        super().keyboard_on_key_down(window, keycode, text, modifiers)

        if not self.text or str.isspace(self.text):
            self.valid(True, False)

        if self.cursor_pos[0] > (self.x + self.width) - (self.width * 0.175):
            self.scroll_x += self.cursor_pos[0] - ((self.x + self.width) - (self.width * 0.175))


    # Input validation
    def insert_text(self, substring, from_undo=False):

        if not self.text and substring == " ":
            substring = ""

        elif len(self.text) < 50:
            s = re.sub('[^a-zA-Z0-9 _().-]', '', substring.splitlines()[0])

            return super().insert_text(s, from_undo=from_undo)


    def valid(self, boolean_value, text=True):

        self.valid_text(boolean_value, text)

        self.background_normal = os.path.join(constants.gui_assets, f'search_input.png')
        self.background_active = os.path.join(constants.gui_assets, f'search_input_selected.png')
        self.hint_text_color = (0.6, 0.6, 1, 0.4)
        self.foreground_color = (0.6, 0.6, 1, 1)
        self.cursor_color = (0.55, 0.55, 1, 1)
        self.selection_color = (0.5, 0.5, 1, 0.4)

def search_input(return_function=None, server_info=None, pos_hint={"center_x": 0.5, "center_y": 0.5}, allow_empty=False):
    class SearchLayout(FloatLayout):

        def __init__(self, **kwargs):
            super().__init__(**kwargs)
            self.previous_search = ""

        # Gather search results from passed in function
        def execute_search(self, query, *a):
            self.previous_search = query

            def execute():
                current_screen = screen_manager.current_screen.name
                self.loading(True)
                results = False

                try:
                    results = return_function(query) if not server_info else return_function(query, server_info)
                except ConnectionRefusedError:
                    pass

                if not results and isinstance(results, bool):
                    self.previous_search = ""

                if screen_manager.current_screen.name == current_screen:
                    update_screen = functools.partial(screen_manager.current_screen.gen_search_results, results, True)
                    Clock.schedule_once(update_screen, 0)

                    self.loading(False)

            timer = threading.Timer(0, function=execute)
            timer.start()  # Checks for potential crash


        def loading(self, boolean_value):

            def main_thread(*a):

                for child in self.children:
                    if child.id == "load_icon":
                        if boolean_value:
                            Animation(color=(0.6, 0.6, 1, 1), duration=0.05).start(child)
                        else:
                            Animation(color=(0.6, 0.6, 1, 0), duration=0.2).start(child)

                    if child.id == "search_button":
                        constants.hide_widget(child, boolean_value)

            Clock.schedule_once(main_thread, 0)

    def repos_button(bar, button, load, *args):
        def after_window(*args):
            button.x = bar.x + bar.width - button.width - 18
            load.x = bar.x + bar.width - load.width - 14

        Clock.schedule_once(after_window, 0)

    final_layout = SearchLayout()

    # Input box
    search_bar = SearchInput(return_function, allow_empty)
    search_bar.pos_hint = pos_hint

    # Search icon on the right of box
    search_button = SearchButton()
    search_button.pos_hint = {"center_y": pos_hint['center_y']}
    search_button.size_hint_max = (search_bar.height / 3.6, search_bar.height / 3.6)

    # Loading icon to swap button
    load_icon = AsyncImage()
    load_icon.id = "load_icon"
    load_icon.source = os.path.join(constants.gui_assets, 'animations', 'loading_pickaxe.gif')
    load_icon.size_hint_max = (search_bar.height / 3, search_bar.height / 3)
    load_icon.color = (0.6, 0.6, 1, 0)
    load_icon.pos_hint = {"center_y": pos_hint['center_y']}
    load_icon.allow_stretch = True
    load_icon.anim_delay = constants.anim_speed * 0.02

    # Assemble layout
    final_layout.bind(pos=functools.partial(repos_button, search_bar, search_button, load_icon))
    final_layout.bind(size=functools.partial(repos_button, search_bar, search_button, load_icon))
    final_layout.add_widget(search_bar)
    final_layout.add_widget(search_button)
    final_layout.add_widget(load_icon)

    return final_layout



class ServerNameInput(BaseInput):

    def get_server_list(self):
        try:
            telepath_data = constants.new_server_info['_telepath_data']
            if telepath_data:
                self.server_list = constants.get_remote_var('server_list_lower', telepath_data)
                return True
        except:
            pass
        self.server_list = constants.server_list_lower

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.title_text = "name"
        self.hint_text = "enter a name..."
        self.bind(on_text_validate=self.on_enter)
        self.server_list = []
        self.get_server_list()


    def on_enter(self, value, click_next=True, *args):

        constants.new_server_info['name'] = (self.text).strip()

    # Invalid input
        if not self.text or str.isspace(self.text):
            self.valid(True, False)

        elif self.text.lower().strip() in self.server_list:
            self.valid(False)

    # Valid input
        elif click_next:
            break_loop = False
            for child in self.parent.children:
                if break_loop:
                    break
                for item in child.children:
                    try:
                        if item.id == "next_button":
                            item.force_click()
                            break_loop = True
                            break
                    except AttributeError:
                        pass


    def valid_text(self, boolean_value, text):
        for child in self.parent.children:
            try:
                if child.id == "InputLabel":

                # Empty input
                    if not text:
                        child.clear_text()
                        child.disable_text(True)

                # Valid input
                    elif boolean_value:
                        child.clear_text()
                        child.disable_text(False)

                # Invalid input
                    else:
                        child.update_text("This server already exists")
                        child.disable_text(True)
                    break

            except AttributeError:
                pass


    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        super().keyboard_on_key_down(window, keycode, text, modifiers)

        if keycode[1] == "backspace" and len(self.text) >= 1:
            # Add name to current config
            constants.new_server_info['name'] = (self.text).strip()

            self.valid((self.text).lower().strip() not in self.server_list)

        def check_validity(*a):
            if not self.text or str.isspace(self.text):
                self.valid(True, False)
        Clock.schedule_once(check_validity, 0)


    # Input validation
    def insert_text(self, substring, from_undo=False):

        if not self.text and substring == " ":
            substring = ""

        elif len(self.text) < 25:
            if '\n' in substring:
                substring = substring.splitlines()[0]
            s = re.sub('[^a-zA-Z0-9 _().-]', '', substring)

            is_valid = (self.text + s).lower().strip() not in self.server_list
            self.valid(is_valid, ((len(self.text + s) > 0) and not (str.isspace(self.text))))

            # Add name to current config
            def get_text(*a):
                constants.new_server_info['name'] = self.text.strip()
            Clock.schedule_once(get_text, 0)

            return super().insert_text(s, from_undo=from_undo)



    def update_server(self, force_ignore=False, hide_popup=False):

        def disable_next(disable=False):
            for item in screen_manager.current_screen.next_button.children:
                try:
                    if item.id == "next_button":
                        item.disable(disable)
                        break
                except AttributeError:
                    pass

        self.scroll_x = 0

        if self.text:
            if self.text.lower().strip() in self.server_list:
                self.valid(False)
                disable_next(True)

            # If server is valid, do this
            else:
                self.valid(True)
                disable_next(False)


class ServerRenameInput(BaseInput):

    def get_server_list(self):
        try:
            telepath_data = constants.server_manager.current_server._telepath_data
            if telepath_data:
                self.server_list = constants.get_remote_var('server_list_lower', telepath_data)
                return True
        except:
            pass
        self.server_list = constants.server_list_lower

    def _on_focus(self, instance, value, *largs):
        super()._on_focus(instance, value)
        if not self.focus and self.text != self.starting_text.strip():
            self.text = self.starting_text
            self.valid(True, True)

    def __init__(self, on_validate, **kwargs):
        super().__init__(**kwargs)

        self.validate = on_validate
        self.title_text = "rename"
        self.hint_text = "enter a new name..."
        self.bind(on_text_validate=self.on_enter)
        self.is_valid = False
        self.starting_text = self.text
        self.server_list = []
        self.get_server_list()


    def on_enter(self, value):

    # Invalid input
        if not self.text or str.isspace(self.text):
            self.valid(True, False)

        elif (self.text.lower().strip() in self.server_list) and (self.text.lower().strip() != self.starting_text.lower().strip()):
            self.valid(False)

        if self.is_valid and self.text.strip() and (self.text.lower().strip() != self.starting_text.lower().strip()):
            self.starting_text = self.text.strip()
            self.validate((self.text).strip())

    def valid_text(self, boolean_value, text):
        for child in self.parent.children:
            try:
                if child.id == "InputLabel":

                # Empty input
                    if not text:
                        child.clear_text()
                        child.disable_text(True)

                # Valid input
                    elif boolean_value:
                        child.clear_text()
                        child.disable_text(False)

                # Invalid input
                    else:
                        child.update_text("This server already exists")
                        child.disable_text(True)
                    break

            except AttributeError:
                pass


    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        super().keyboard_on_key_down(window, keycode, text, modifiers)

        if keycode[1] == "backspace" and len(self.text) >= 1:
            text_check = (self.text.lower().strip())
            self.valid((text_check not in self.server_list) or (text_check == self.starting_text.lower().strip()))

        def check_validity(*a):
            if not self.text or str.isspace(self.text):
                self.valid(True, False)
        Clock.schedule_once(check_validity, 0)


    # Input validation
    def insert_text(self, substring, from_undo=False):

        if not self.text and substring == " ":
            substring = ""

        elif len(self.text) < 25:
            if '\n' in substring:
                substring = substring.splitlines()[0]
            s = re.sub('[^a-zA-Z0-9 _().-]', '', substring)

            text_check = (self.text + s).lower().strip()
            self.valid((text_check not in self.server_list) or (text_check == self.starting_text.lower().strip()), ((len(self.text + s) > 0) and not (str.isspace(self.text))))

            return super().insert_text(s, from_undo=from_undo)


class ScriptNameInput(BaseInput):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.title_text = "name"
        self.hint_text = "enter a name..."
        self.bind(on_text_validate=self.on_enter)
        self.script_list = []


    def update_script_list(self, s_list):
        self.script_list = [x.file_name.lower() for x in s_list]

    @staticmethod
    def convert_name(name):
        return name.lower().strip().replace(' ', '-') + '.ams'


    def on_enter(self, value):

    # Invalid input
        if not self.text or str.isspace(self.text):
            self.valid(True, False)

        elif self.convert_name(self.text) in self.script_list:
            self.valid(False)

    # Valid input
        else:
            break_loop = False
            for child in self.parent.children:
                if break_loop:
                    break
                for item in child.children:
                    try:
                        if item.id == "main_button":
                            item.force_click()
                            break_loop = True
                            break
                    except AttributeError:
                        pass


    def valid_text(self, boolean_value, text):
        create_button = screen_manager.current_screen.create_button
        for child in self.parent.children:
            try:
                if child.id == "InputLabel":

                # Empty input
                    if not text:
                        child.clear_text()
                        child.disable_text(True)
                        create_button.disable(True)


                # Valid input
                    elif boolean_value:
                        child.clear_text()
                        child.disable_text(False)
                        create_button.disable(False)

                # Invalid input
                    else:
                        child.update_text("This script already exists")
                        child.disable_text(True)
                        create_button.disable(True)
                    break

            except AttributeError:
                pass


    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        super().keyboard_on_key_down(window, keycode, text, modifiers)

        if keycode[1] == "backspace" and len(self.text) >= 1:
            self.valid(self.convert_name(self.text) not in self.script_list)

        def check_validity(*a):
            if not self.text or str.isspace(self.text):
                self.valid(True, False)
        Clock.schedule_once(check_validity, 0)


    # Input validation
    def insert_text(self, substring, from_undo=False):

        if not self.text and substring == " ":
            substring = ""

        elif len(self.text) < 25:
            if '\n' in substring:
                substring = substring.splitlines()[0]
            s = re.sub('[^a-zA-Z0-9 _().-]', '', substring)

            self.valid(self.convert_name(self.text + s) not in self.script_list, ((len(self.text + s) > 0) and not (str.isspace(self.text))))

            return super().insert_text(s, from_undo=from_undo)


class ServerVersionInput(BaseInput):

    def __init__(self, enter_func=None, **kwargs):
        super().__init__(**kwargs)
        self.enter_func = enter_func
        self.title_text = "version"
        server_type = constants.latestMC[constants.new_server_info['type']]
        self.hint_text = f"click 'next' for latest  (${server_type}$)"
        self.bind(on_text_validate=self.on_enter)


    def on_touch_down(self, touch):
        if not constants.version_loading:
            super().on_touch_down(touch)

        else:
            self.focus = False


    def on_enter(self, value):

        if not constants.version_loading:

            if self.text:
                constants.new_server_info['version'] = (self.text).strip()
            else:
                constants.new_server_info['version'] = constants.latestMC[constants.new_server_info['type']]

            if self.enter_func:
                self.enter_func()

            break_loop = False
            for child in self.parent.children:
                if break_loop:
                    break
                for item in child.children:
                    try:
                        if item.id == "next_button":
                            item.force_click()
                            break
                    except AttributeError:
                        pass


    def valid_text(self, boolean_value, text):
        if not constants.version_loading:

            if isinstance(text, bool):
                text = ''

            for child in self.parent.children:
                try:
                    if child.id == "InputLabel":
                    # Invalid input
                        if text and not boolean_value:
                            child.update_text(text)
                            child.disable_text(True)

                        elif boolean_value and text:
                            self.text = constants.new_server_info['version']
                            child.update_text(text, warning=True)
                            child.disable_text(True)

                    # Valid input
                        else:
                            child.clear_text()
                            child.disable_text(False)

                        break

                except AttributeError:
                    pass


    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        if not constants.version_loading:

            super().keyboard_on_key_down(window, keycode, text, modifiers)

            if keycode[1] == "backspace":
                # Add name to current config
                self.valid(True, True)

                if self.text:
                    constants.new_server_info['version'] = (self.text).strip()
                else:
                    constants.new_server_info['version'] = constants.latestMC[constants.new_server_info['type']]


    # Input validation
    def insert_text(self, substring, from_undo=False):

        if not constants.version_loading:

            if not self.text and substring == " ":
                substring = ""

            elif len(self.text) < 10:
                self.valid(True, True)

                if '\n' in substring:
                    substring = substring.splitlines()[0]
                s = re.sub('[^a-eA-E0-9 .wpreWPRE-]', '', substring).lower()

                # Add name to current config
                if self.text + s:
                    def get_text(*a):
                        constants.new_server_info['version'] = self.text.strip()
                    Clock.schedule_once(get_text, 0)
                else:
                    constants.new_server_info['version'] = constants.latestMC[constants.new_server_info['type']]

                return super().insert_text(s, from_undo=from_undo)


# Auto-complete directory content
class DirectoryInput(BaseInput):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.recommended_folders = ["Users", "AppData", "Roaming", ".minecraft", "saves", "home"]

        # Create suggestion text
        with self.canvas.after:
            self.text_hint = RelativeLayout()
            self.text_hint.text = Label()
            self.text_hint.text.halign = "left"
            self.text_hint.text.valign = "middle"
            self.text_hint.text.color = (0.6, 0.6, 1, 0.4)
            self.text_hint.text.font_name = self.font_name
            self.text_hint.text.font_size = self.font_size
            self.text_hint.text.max_lines = 1
            self.text_hint.text.size_hint = (None, None)
            self.suggestion_index = 0
            self.bind(pos=self.update_suggestion)
            self.bind(focus=self.update_suggestion)
            self.bind(text=self.update_suggestion)
            self.bind(scroll_x=self.update_suggestion)

            # Cover suggestion text on sides
            self.focus_images = RelativeLayout()
            self.focus_images.ghost_cover_left = Image(source=os.path.join(constants.gui_assets, f'text_input_ghost_cover.png'))
            self.focus_images.ghost_cover_right = Image(source=os.path.join(constants.gui_assets, f'text_input_ghost_cover.png'))
            self.focus_images.ghost_image = Image(source=os.path.join(constants.gui_assets, f'text_input_ghost_selected.png'))
            self.focus_images.ghost_image.allow_stretch = True
            self.focus_images.ghost_image.keep_ratio = False
            self.focus_images.ghost_cover_left.allow_stretch = True
            self.focus_images.ghost_cover_left.keep_ratio = False
            self.focus_images.ghost_cover_right.allow_stretch = True
            self.focus_images.ghost_cover_right.keep_ratio = False
            self.focus_images.ghost_image.opacity = 0
            self.focus_images.ghost_cover_left.opacity = 0
            self.focus_images.ghost_cover_right.opacity = 0
            self.focus_images.ghost_cover_left.color = constants.background_color
            self.focus_images.ghost_cover_right.color = constants.background_color

        self.word_list = []
        self.suggestion = (0.6, 0.6, 1, 0.4)
        self.bind(text=self.on_text)

    def update_suggestion(self, *args):
        self.focus_images.ghost_image.size = (self.width+4, self.height+4)
        self.focus_images.ghost_image.pos = (self.x-2, self.y-2)
        self.focus_images.ghost_cover_left.pos = (0, self.y-(self.height/2))
        self.focus_images.ghost_cover_left.width = ((Window.size[0]/2)-(self.width/2)+self.padding_x[0])
        self.focus_images.ghost_cover_right.pos = (self.x+self.width-self.padding_x[0], self.y-(self.height/2))
        self.focus_images.ghost_cover_right.width = ((Window.size[0]/2)-(self.width/2)+self.padding_x[0])
        self.focus_images.ghost_image.opacity = 1 if self.focus else 0
        self.focus_images.ghost_cover_left.opacity = 1 if self.focus else 0
        self.focus_images.ghost_cover_right.opacity = 1 if self.focus else 0

        Animation(opacity=(1 if self.focus else 0), duration=0.05).start(self.text_hint.text)

        self.text_hint.size = self.size

        if self.focus:
            self.text_hint.text.text_size = (self.size[0] * 12, self.size[1])
            self.text_hint.text.pos = (self.x + self.padding[0] + (self.size[0] * 5.5), self.y - self.font_size)
            self.text_hint.text.width = (self.width) - (self.scroll_x * 2)

            # Gather word list
            if len(self.text) > 0:
                if (self.text[0] != ".") and (('\\' in self.text) or ('/' in self.text)):
                    self.word_list = constants.hidden_glob(self.text)
                    self.on_text(None, self.text)

    def on_text(self, instance, value):
        # Prevent extra slashes in file name

        if self.text.startswith('"') and self.text.endswith('"'):
            self.text = self.text[1:-1]

        self.text = self.text.replace("\\\\", "\\").replace("//", "/").replace("\\/", "\\").replace("/\\", "/")
        self.text = self.text.replace("/", "\\") if constants.os_name == "windows" else self.text.replace("\\", "/")
        self.text = self.text.replace("*", "")

        """ Include all current text from textinput into the word list to
        emulate the same kind of behavior as sublime text has.
        """
        self.text_hint.text.text = ''

        # for item in self.word_list:
        #     print(os.path.split(item)[1] in self.recommended_folders)
        #     if os.path.split(item)[1] in self.recommended_folders:
        #         self.suggestion_index = self.word_list.index(item)
        #         print(self.suggestion_index)
        #         break

        word_list = constants.rotate_array(sorted(list(set(
            self.word_list + value[:value.rfind('     ')].split('     ')))), self.suggestion_index)

        word_list = [item for item in word_list if not (len(item) == 3 and ":\\" in item)
                     and not (len(item) == 2 and ":" in item)
                     and item]

        val = value[value.rfind('     ') + 1:]
        if not val:
            return
        try:
            # grossly inefficient just for demo purposes
            word = [word for word in word_list
                    if word.startswith(val)][0][len(val):]
            if not word:
                return
            self.text_hint.text.text = self.text + word
        except IndexError:
            # No matches found
            pass

    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        # Add support for tab as an 'autocomplete' using the suggestion text.
        hint_text = self.text_hint.text.text[len(self.text):] + ''

        if self.text_hint.text.text and keycode[1] in ['tab', 'right']:
            self.insert_text(hint_text)

            # Automatically add slash to directory
            if os.path.isdir(self.text) and not (os.path.isfile(os.path.join(self.text, "level.dat")) or os.path.isfile(os.path.join(self.text, 'special_level.dat'))):
                self.insert_text("\\" if constants.os_name == "windows" else "/")

                if self.cursor_pos[0] > (self.x + self.width) - (self.width * 0.33):
                    self.scroll_x += self.cursor_pos[0] - ((self.x + self.width) - (self.width * 0.33))

            self.do_cursor_movement('cursor_end', True)
            Clock.schedule_once(functools.partial(self.do_cursor_movement, 'cursor_end', True), 0.01)
            Clock.schedule_once(functools.partial(self.select_text, 0), 0.01)
            self.suggestion_index = 0
            return True

        elif keycode[1] == 'backspace':
            self.suggestion_index = 0
            self.on_text(None, self.text)

        elif keycode[1] == 'tab':
            return

        elif keycode[1] == 'up':
            self.suggestion_index += 1
            if self.suggestion_index >= len(self.word_list):
                self.suggestion_index = 0
            self.on_text(None, self.text)

        elif keycode[1] == 'down':
            self.suggestion_index -= 1
            if self.suggestion_index < 0:
                self.suggestion_index = len(self.word_list)-1
            self.on_text(None, self.text)

        else:
            self.suggestion_index = 0

        return super().keyboard_on_key_down(window, keycode, text, modifiers)


class CreateServerWorldInput(DirectoryInput):

    # Hide input_button on focus
    def _on_focus(self, *args):
        super()._on_focus(*args)

        for child in self.parent.children:
            for child_item in child.children:
                try:
                    if child_item.id == "input_button":

                        if constants.new_server_info['server_settings']['world'] == "world":
                            self.hint_text = "type a directory, or click browse..." if self.focus else "create a new world"

                        # Run input validation on focus change
                        if self.focus:
                            self.valid(True, True)

                        # If unfocused, validate text
                        if not self.focus and self.text and child_item.height == 0:
                            self.on_enter(self.text)

                        # If box deleted and unfocused, set back to previous text
                        elif not self.focus and not self.text and constants.new_server_info['server_settings']['world'] != "world":
                            self.text = self.cache_text

                        # If box filled in and text box clicked
                        if self.focus and self.text:
                            self.text = constants.new_server_info['server_settings']['world']
                            self.do_cursor_movement('cursor_end', True)
                            Clock.schedule_once(functools.partial(self.do_cursor_movement, 'cursor_end', True), 0.01)
                            Clock.schedule_once(functools.partial(self.select_text, 0), 0.01)

                        [constants.hide_widget(item, self.focus) for item in child.children]

                        return

                except AttributeError:
                    continue

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.halign = "left"
        self.padding_x = 25
        self.size_hint_max = (528, 54)
        self.title_text = "world file"
        self.hint_text = "create a new world"
        self.cache_text = ""
        world = constants.new_server_info['server_settings']['world']
        self.selected_world = None if world == 'world' else world
        self.world_verified = False
        self.update_world(hide_popup=True)

    def on_enter(self, value):

        if constants.os_name == "windows" and "\\" not in self.text:
            self.text = os.path.join(constants.saveFolder, self.text)

        elif constants.os_name != "windows" and "/" not in self.text:
            self.text = os.path.join(constants.saveFolder, self.text)

        self.selected_world = self.text.replace("~", constants.home)
        self.update_world()

    # Input validation and server selection
    def valid_text(self, boolean_value, text):
        if not constants.version_loading:

            for child in self.parent.children:
                try:
                    if child.id == "InputLabel":
                    # Invalid input
                        if not boolean_value:
                            child.update_text('This world is invalid or corrupt')
                            self.text = ""
                    # Valid input
                        else:
                            child.clear_text()
                        break
                except AttributeError:
                    pass

    def update_world(self, force_ignore=False, hide_popup=False):
        if self.selected_world == "world":
            self.text = ''

        self.scroll_x = 0

        if self.selected_world:
            self.selected_world = os.path.abspath(self.selected_world)

            # Check if the selected world is invalid
            if not (os.path.isfile(os.path.join(self.selected_world, 'level.dat')) or os.path.isfile(os.path.join(self.selected_world, 'special_level.dat'))):
                if self.selected_world != os.path.abspath(os.curdir):
                    try:
                        constants.new_server_info['server_settings']['world'] = 'world'
                        if not force_ignore:
                            self.valid_text(False, False)
                        self.parent.parent.toggle_new(False)
                    except AttributeError:
                        pass

            # If world is valid, do this
            else:
                if constants.new_server_info['server_settings']['world'] != "world":
                    box_text = os.path.join(
                        *Path(os.path.abspath(constants.new_server_info['server_settings']['world'])).parts[-2:])
                    self.cache_text = self.text = box_text[:30] + "..." if len(box_text) > 30 else box_text

                def world_valid():
                    def execute(*a):
                        box_text = os.path.join(*Path(os.path.abspath(self.selected_world)).parts[-2:])
                        self.cache_text = self.text = box_text[:30] + "..." if len(box_text) > 30 else box_text
                        try:
                            constants.new_server_info['server_settings']['world'] = self.selected_world
                            self.valid_text(True, True)
                            self.parent.parent.toggle_new(True)
                        except AttributeError:
                            pass
                    Clock.schedule_once(execute, 0)

                def clear_world():
                    def execute(*a):
                        constants.new_server_info['server_settings']['world'] = 'world'
                        self.hint_text = "create a new world"
                        self.text = ""
                        self.cache_text = ""
                        self.selected_world = None
                        self.world_verified = False
                        self.update_world(hide_popup=True)
                    Clock.schedule_once(execute, 0)



                # When valid world selected, check if it matches server version
                check_world = constants.check_world_version(self.selected_world, constants.new_server_info['version'])

                if check_world[0] or hide_popup:
                    world_valid()

                else:
                    content = None
                    basename = os.path.basename(self.selected_world)
                    basename = basename[:30] + "..." if len(basename) > 30 else basename

                    if check_world[1]:
                        content = f"'{basename}' was created in\
 version {check_world[1]}, which is newer than your server. This may cause a crash.\
\n\nWould you like to use this world anyway?"
                    elif constants.version_check(constants.new_server_info['version'], "<", "1.9"):
                        content = f"'{basename}' was created in a version prior to 1.9 and may be incompatible.\
\n\nWould you like to use this world anyway?"

                    if content:
                        Clock.schedule_once(
                            functools.partial(
                                screen_manager.current_screen.show_popup,
                                "query",
                                "Potential Incompatibility",
                                content,
                                [functools.partial(clear_world), functools.partial(world_valid)]
                            ), 0
                        )

                    else:
                        world_valid()

class ServerWorldInput(DirectoryInput):

    # Hide input_button on focus
    def _on_focus(self, *args):
        super()._on_focus(*args)

        for child in self.parent.children:
            for child_item in child.children:
                try:
                    if child_item.id == "input_button":

                        if screen_manager.current_screen.new_world == "world":
                            self.hint_text = "type a directory, or click browse..." if self.focus else "create a new world"

                        # Run input validation on focus change
                        if self.focus:
                            self.valid(True, True)

                        # If unfocused, validate text
                        if not self.focus and self.text and child_item.height == 0:
                            self.on_enter(self.text)

                        # If box deleted and unfocused, set back to previous text
                        elif not self.focus and not self.text and screen_manager.current_screen.new_world != "world":
                            self.text = self.cache_text

                        # If box filled in and text box clicked
                        if self.focus and self.text:
                            self.text = screen_manager.current_screen.new_world
                            self.do_cursor_movement('cursor_end', True)
                            Clock.schedule_once(functools.partial(self.do_cursor_movement, 'cursor_end', True), 0.01)
                            Clock.schedule_once(functools.partial(self.select_text, 0), 0.01)

                        [constants.hide_widget(item, self.focus) for item in child.children]

                        return

                except AttributeError:
                    continue

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.halign = "left"
        self.padding_x = 25
        self.size_hint_max = (528, 54)
        self.title_text = "world file"
        self.hint_text = "create a new world"
        self.cache_text = ""
        world = screen_manager.current_screen.new_world
        self.selected_world = None if world == 'world' else world
        self.world_verified = False
        self.update_world(hide_popup=True)

    def on_enter(self, value):

        if constants.os_name == "windows" and "\\" not in self.text:
            self.text = os.path.join(constants.saveFolder, self.text)

        elif constants.os_name != "windows" and "/" not in self.text:
            self.text = os.path.join(constants.saveFolder, self.text)

        self.selected_world = self.text.replace("~", constants.home)
        self.update_world()

    # Input validation and server selection
    def valid_text(self, boolean_value, text):
        if not constants.version_loading:

            for child in self.parent.children:
                try:
                    if child.id == "InputLabel":
                    # Invalid input
                        if not boolean_value:
                            child.update_text('This world is invalid or corrupt')
                            self.text = ""
                    # Valid input
                        else:
                            child.clear_text()
                        break
                except AttributeError:
                    pass

    def update_world(self, force_ignore=False, hide_popup=False):
        if self.selected_world == "world":
            self.text = ''

        self.scroll_x = 0

        if self.selected_world:
            self.selected_world = os.path.abspath(self.selected_world)

            # Check if the selected world is invalid
            if not (os.path.isfile(os.path.join(self.selected_world, 'level.dat')) or os.path.isfile(os.path.join(self.selected_world, 'special_level.dat'))):
                if self.selected_world != os.path.abspath(os.curdir):
                    try:
                        screen_manager.current_screen.new_world = 'world'
                        if not force_ignore:
                            self.valid_text(False, False)
                        self.parent.parent.toggle_new(False)
                    except AttributeError:
                        pass

            # If world is valid, do this
            else:
                if screen_manager.current_screen.new_world != "world":
                    box_text = os.path.join(
                        *Path(os.path.abspath(screen_manager.current_screen.new_world)).parts[-2:])
                    self.cache_text = self.text = box_text[:30] + "..." if len(box_text) > 30 else box_text

                def world_valid():
                    def execute(*a):
                        box_text = os.path.join(*Path(os.path.abspath(self.selected_world)).parts[-2:])
                        self.cache_text = self.text = box_text[:30] + "..." if len(box_text) > 30 else box_text
                        try:
                            screen_manager.current_screen.new_world = self.selected_world
                            self.valid_text(True, True)
                            self.parent.parent.toggle_new(True)
                        except AttributeError:
                            pass
                    Clock.schedule_once(execute, 0)

                def clear_world():
                    def execute(*a):
                        screen_manager.current_screen.new_world = 'world'
                        self.hint_text = "create a new world"
                        self.text = ""
                        self.cache_text = ""
                        self.selected_world = None
                        self.world_verified = False
                        self.update_world(hide_popup=True)
                    Clock.schedule_once(execute, 0)


                # When valid world selected, check if it matches server version
                check_world = constants.check_world_version(self.selected_world, constants.server_manager.current_server.version)

                if check_world[0] or hide_popup:
                    world_valid()

                else:
                    content = None
                    basename = os.path.basename(self.selected_world)
                    basename = basename[:30] + "..." if len(basename) > 30 else basename

                    if check_world[1]:
                        content = f"'{basename}' was created in\
 version {check_world[1]}, which is newer than your server. This may cause a crash.\
\n\nWould you like to use this world anyway?"
                    elif constants.version_check(constants.server_manager.current_server.version, "<", "1.9"):
                        content = f"'{basename}' was created in a version prior to 1.9 and may be incompatible.\
\n\nWould you like to use this world anyway?"

                    if content:
                        Clock.schedule_once(
                            functools.partial(
                                screen_manager.current_screen.show_popup,
                                "query",
                                "Potential Incompatibility",
                                content,
                                [functools.partial(clear_world), functools.partial(world_valid)]
                            ), 0
                        )

                    else:
                        world_valid()


class CreateServerSeedInput(BaseInput):

    # Hide input_button on focus
    def _on_focus(self, *args):
        try:
            super()._on_focus(*args)

            if constants.version_check(constants.new_server_info['version'], '>=', "1.1"):
                for child in self.parent.children:
                    for child_item in child.children:
                        try:
                            if "drop_button" in child_item.id:

                                # If box filled in and text box clicked
                                if self.focus and self.text:
                                    self.text = constants.new_server_info['server_settings']['seed']
                                    self.do_cursor_movement('cursor_end', True)
                                    Clock.schedule_once(functools.partial(self.do_cursor_movement, 'cursor_end', True), 0.01)
                                    Clock.schedule_once(functools.partial(self.select_text, 0), 0.01)

                                if not self.focus:
                                    # If text under button, cut it off temporarily
                                    self.scroll_x = 0
                                    self.cursor = (len(self.text), 0)
                                    if self.cursor_pos[0] > (self.x + self.width) - (self.width * 0.38):
                                        self.text = constants.new_server_info['server_settings']['seed'][:16] + "..."
                                    self.scroll_x = 0
                                    Clock.schedule_once(functools.partial(self.select_text, 0), 0.01)

                                [constants.hide_widget(item, self.focus) for item in child.children]

                                return

                        except AttributeError:
                            continue

        except Exception as e:
            print(f"Warning: Failed to focus input box ({e})")

    def on_enter(self, value):

        constants.new_server_info['server_settings']['seed'] = (self.text).strip()

        break_loop = False
        for child in self.parent.children:
            if break_loop:
                break
            for item in child.children:
                try:
                    if item.id == "next_button":
                        item.force_click()
                        break
                except AttributeError:
                    pass

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.size_hint_max = (528, 54)
        self.padding_x = 25
        self.title_text = "world seed"
        self.hint_text = "enter a seed..."
        self.text = constants.new_server_info['server_settings']['seed']
        self.bind(on_text_validate=self.on_enter)

        if constants.new_server_info['server_settings']['world'] == "world":
            if constants.version_check(constants.new_server_info['version'], '>=', "1.1"):
                self.halign = "left"
                Clock.schedule_once(functools.partial(self._on_focus, self, True), 0.0)
                Clock.schedule_once(functools.partial(self._on_focus, self, False), 0.0)


    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        super().keyboard_on_key_down(window, keycode, text, modifiers)

        # if constants.version_check(constants.new_server_info['version'], '>=', "1.1"):
        #     if self.cursor_pos[0] > (self.x + self.width) - (self.width * 0.38):
        #         self.scroll_x += self.cursor_pos[0] - ((self.x + self.width) - (self.width * 0.38))

        if keycode[1] == "backspace":
            # Add seed to current config
            constants.new_server_info['server_settings']['seed'] = (self.text).strip()

    # Input validation
    def insert_text(self, substring, from_undo=False):

        if not self.text and substring == " ":
            substring = ""

        elif len(self.text) < 32:
            if '\n' in substring:
                substring = substring.splitlines()[0]
            s = re.sub('[^a-zA-Z0-9 _/{}=+|"\'()*&^%$#@!?;:,.-]', '', substring)

            # Add name to current config
            def get_text(*a):
                constants.new_server_info['server_settings']['seed'] = self.text.strip()
            Clock.schedule_once(get_text, 0)

            return super().insert_text(s, from_undo=from_undo)

class ServerSeedInput(BaseInput):

    # Hide input_button on focus
    def _on_focus(self, *args):
        try:
            super()._on_focus(*args)

            if constants.version_check(constants.server_manager.current_server.version, '>=', "1.1"):
                for child in self.parent.children:
                    for child_item in child.children:
                        try:
                            if "drop_button" in child_item.id:

                                # If box filled in and text box clicked
                                if self.focus and self.text:
                                    self.text = screen_manager.current_screen.new_seed
                                    self.do_cursor_movement('cursor_end', True)
                                    Clock.schedule_once(functools.partial(self.do_cursor_movement, 'cursor_end', True), 0.01)
                                    Clock.schedule_once(functools.partial(self.select_text, 0), 0.01)

                                if not self.focus:
                                    # If text under button, cut it off temporarily
                                    self.scroll_x = 0
                                    self.cursor = (len(self.text), 0)
                                    if self.cursor_pos[0] > (self.x + self.width) - (self.width * 0.38):
                                        self.text = screen_manager.current_screen.new_seed[:16] + "..."
                                    self.scroll_x = 0
                                    Clock.schedule_once(functools.partial(self.select_text, 0), 0.01)

                                [constants.hide_widget(item, self.focus) for item in child.children]

                                return

                        except AttributeError:
                            continue

        except Exception as e:
            print(f"Warning: Failed to focus input box ({e})")

    def on_enter(self, value):

        screen_manager.current_screen.new_seed = (self.text).strip()

        break_loop = False
        for child in self.parent.children:
            if break_loop:
                break
            for item in child.children:
                try:
                    if item.id == "next_button":
                        item.force_click()
                        break
                except AttributeError:
                    pass

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.size_hint_max = (528, 54)
        self.padding_x = 25
        self.title_text = "world seed"
        self.hint_text = "enter a seed..."
        self.text = screen_manager.current_screen.new_seed
        self.bind(on_text_validate=self.on_enter)

        if screen_manager.current_screen.new_world == "world":
            if constants.version_check(constants.server_manager.current_server.version, '>=', "1.1"):
                self.halign = "left"
                Clock.schedule_once(functools.partial(self._on_focus, self, True), 0.0)
                Clock.schedule_once(functools.partial(self._on_focus, self, False), 0.0)


    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        super().keyboard_on_key_down(window, keycode, text, modifiers)

        # if constants.version_check(constants.server_manager.current_server.version, '>=', "1.1"):
        #     if self.cursor_pos[0] > (self.x + self.width) - (self.width * 0.38):
        #         self.scroll_x += self.cursor_pos[0] - ((self.x + self.width) - (self.width * 0.38))

        if keycode[1] == "backspace":
            # Add seed to current config
            screen_manager.current_screen.new_seed = (self.text).strip()

    # Input validation
    def insert_text(self, substring, from_undo=False):

        if not self.text and substring == " ":
            substring = ""

        elif len(self.text) < 32:
            if '\n' in substring:
                substring = substring.splitlines()[0]
            s = re.sub('[^a-zA-Z0-9 _/{}=+|"\'()*&^%$#@!?;:,.-]', '', substring)

            # Add name to current config
            def get_text(*a):
                screen_manager.current_screen.new_seed = self.text.strip()
            Clock.schedule_once(get_text, 0)

            return super().insert_text(s, from_undo=from_undo)


class ServerImportPathInput(DirectoryInput):

    def get_server_list(self):
        try:
            telepath_data = constants.new_server_info['_telepath_data']
            if telepath_data:
                self.server_list = constants.get_remote_var('server_list_lower', telepath_data)
                return True
        except:
            pass
        self.server_list = constants.server_list_lower

    # Hide input_button on focus
    def _on_focus(self, *args):
        super()._on_focus(*args)

        for child in self.parent.children:
            for child_item in child.children:
                try:
                    if child_item.id == "input_button":

                        if not self.text:
                            self.hint_text = "type a path, or click browse..."

                        # Run input validation on focus change
                        if self.focus:
                            self.valid(True, True)

                        # If unfocused, validate text
                        if not self.focus and self.text and child_item.height == 0:
                            self.on_enter(self.text)

                        # If box deleted and unfocused, set back to previous text
                        elif not self.focus and not self.text:
                            self.text = self.cache_text

                        # If box filled in and text box clicked
                        if self.focus and self.text:
                            self.text = self.selected_server
                            self.do_cursor_movement('cursor_end', True)
                            Clock.schedule_once(functools.partial(self.do_cursor_movement, 'cursor_end', True), 0.01)
                            Clock.schedule_once(functools.partial(self.select_text, 0), 0.01)

                        [constants.hide_widget(item, self.focus) for item in child.children]

                        return

                except AttributeError:
                    continue

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.halign = "left"
        self.padding_x = 25
        self.size_hint_max = (528, 54)
        self.title_text = "server path"
        self.hint_text = "type a path, or click browse..."
        self.cache_text = ""
        server = ""
        self.selected_server = None if server == '' else server
        self.server_verified = False
        self.update_server(hide_popup=True)
        self.server_list = []
        self.get_server_list()

    def on_enter(self, value):
        self.selected_server = self.text.replace("~", constants.home)
        self.update_server()

    # Input validation and server selection
    def valid_text(self, boolean_value, text):
        for child in self.parent.children:
            try:
                if child.id == "InputLabel":
                # Invalid input
                    if not boolean_value:
                        if isinstance(text, str) and text:
                            child.update_text(text)
                        else:
                            child.update_text('This server is invalid or corrupt')
                        self.text = ""
                # Valid input
                    else:
                        child.clear_text()
                    break
            except AttributeError:
                pass


    def update_server(self, force_ignore=False, hide_popup=False):

        def disable_next(disable=False):
            for item in screen_manager.current_screen.next_button.children:
                try:
                    if item.id == "next_button":
                        item.disable(disable)
                        break
                except AttributeError:
                    pass

        self.scroll_x = 0

        if self.selected_server:
            self.get_server_list()

            self.selected_server = os.path.abspath(self.selected_server)

            # Check if the selected server is invalid
            if not (os.path.isfile(os.path.join(self.selected_server, 'server.properties'))):
                if self.selected_server != os.path.abspath(os.curdir):
                    try:
                        self.selected_server = ''
                        if not force_ignore:
                            self.valid_text(False, False)
                        disable_next(True)
                    except AttributeError:
                        pass


            # Don't allow import of already imported servers
            elif os.path.join(constants.applicationFolder, 'Servers') in self.selected_server and os.path.basename(self.selected_server).lower() in self.server_list:
                self.valid_text(False, "This server already exists!")
                disable_next(True)


            # If server is valid, do this
            else:
                constants.import_data = {'name': re.sub('[^a-zA-Z0-9 _().-]', '', os.path.basename(self.selected_server).splitlines()[0])[:25], 'path': self.selected_server}
                box_text = os.path.join(*Path(os.path.abspath(self.selected_server)).parts[-2:])
                self.cache_text = self.text = box_text[:30] + "..." if len(box_text) > 30 else box_text
                self.valid_text(True, True)
                disable_next(False)

class ServerImportBackupInput(DirectoryInput):

    def get_server_list(self):
        try:
            telepath_data = constants.new_server_info['_telepath_data']
            if telepath_data:
                self.server_list = constants.get_remote_var('server_list_lower', telepath_data)
                return True
        except:
            pass
        self.server_list = constants.server_list_lower

    # Hide input_button on focus
    def _on_focus(self, *args):
        super()._on_focus(*args)

        for child in self.parent.children:
            for child_item in child.children:
                try:
                    if child_item.id == "input_button":

                        if not self.text:
                            self.hint_text = "type a path, or click browse..."

                        # Run input validation on focus change
                        if self.focus:
                            self.valid(True, True)

                        # If unfocused, validate text
                        if not self.focus and self.text and child_item.height == 0:
                            self.on_enter(self.text)

                        # If box deleted and unfocused, set back to previous text
                        elif not self.focus and not self.text:
                            self.text = self.cache_text

                        # If box filled in and text box clicked
                        if self.focus and self.text:
                            self.text = self.selected_server
                            self.do_cursor_movement('cursor_end', True)
                            Clock.schedule_once(functools.partial(self.do_cursor_movement, 'cursor_end', True), 0.01)
                            Clock.schedule_once(functools.partial(self.select_text, 0), 0.01)

                        [constants.hide_widget(item, self.focus) for item in child.children]

                        return

                except AttributeError:
                    continue

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.halign = "left"
        self.padding_x = 25
        self.size_hint_max = (528, 54)
        self.title_text = "server path"
        self.hint_text = "type a path, or click browse..."
        self.cache_text = ""
        server = ""
        self.selected_server = None if server == '' else server
        self.server_verified = False
        self.update_server(hide_popup=True)

        self.server_list = []
        self.get_server_list()

    def on_enter(self, value):
        self.selected_server = self.text.replace("~", constants.home)
        self.update_server()

    # Input validation and server selection
    def valid_text(self, boolean_value, text):
        for child in self.parent.children:
            try:
                if child.id == "InputLabel":
                # Invalid input
                    if not boolean_value:
                        if isinstance(text, str) and text:
                            child.update_text(text)
                        else:
                            child.update_text('This server is invalid or corrupt')
                        self.text = ""
                # Valid input
                    else:
                        child.clear_text()
                    break
            except AttributeError:
                pass


    def update_server(self, force_ignore=False, hide_popup=False):

        def disable_next(disable=False):
            for item in screen_manager.current_screen.next_button.children:
                try:
                    if item.id == "next_button":
                        item.disable(disable)
                        break
                except AttributeError:
                    pass

        self.scroll_x = 0

        if self.selected_server:
            self.get_server_list()
            self.selected_server = os.path.abspath(self.selected_server)

            # Extract auto-mcs.ini and server.properties
            file_failure = True
            server_name = None
            new_path = None
            test_path = constants.tempDir
            cwd = constants.get_cwd()
            if (self.selected_server.endswith(".tgz") or self.selected_server.endswith(".amb") and os.path.isfile(self.selected_server)):
                constants.folder_check(test_path)
                os.chdir(test_path)
                constants.run_proc(f'tar -xf "{self.selected_server}" auto-mcs.ini')
                constants.run_proc(f'tar -xf "{self.selected_server}" .auto-mcs.ini')
                constants.run_proc(f'tar -xf "{self.selected_server}" server.properties')
                if (os.path.exists(os.path.join(test_path, "auto-mcs.ini")) or os.path.exists(os.path.join(test_path, ".auto-mcs.ini"))) and os.path.exists(os.path.join(test_path, "server.properties")):
                    if os.path.exists(os.path.join(test_path, "auto-mcs.ini")):
                        new_path = os.path.join(test_path, "auto-mcs.ini")
                    elif os.path.exists(os.path.join(test_path, ".auto-mcs.ini")):
                        new_path = os.path.join(test_path, ".auto-mcs.ini")
                    if new_path:
                        try:
                            config_file = constants.server_config(server_name=None, config_path=new_path)
                            server_name = config_file.get('general', 'serverName')
                        except:
                            pass
                        file_failure = False
                        # print(server_name, file_failure)

                os.chdir(cwd)
                constants.safe_delete(test_path)


            # Check if the selected server is invalid
            if file_failure:
                if self.selected_server != os.path.abspath(os.curdir):
                    try:
                        self.selected_server = ''
                        if not force_ignore:
                            self.valid_text(False, False)
                        disable_next(True)
                    except AttributeError:
                        pass


            # Don't allow import of already imported servers
            elif server_name.lower() in self.server_list:
                self.valid_text(False, "This server already exists!")
                disable_next(True)


            # If server is valid, do this
            else:
                constants.import_data = {'name': re.sub('[^a-zA-Z0-9 _().-]', '', server_name.splitlines()[0])[:25], 'path': self.selected_server}
                box_text = os.path.join(*Path(os.path.abspath(self.selected_server)).parts[-2:-1], server_name)
                self.cache_text = self.text = box_text[:30] + "..." if len(box_text) > 30 else box_text
                self.valid_text(True, True)
                disable_next(False)

class ServerImportModpackInput(DirectoryInput):

    # Hide input_button on focus
    def _on_focus(self, *args):
        super()._on_focus(*args)

        for child in self.parent.children:
            for child_item in child.children:
                try:
                    if child_item.id == "input_button":

                        if not self.text:
                            self.hint_text = "type a path..." if self.focused else "import from a file..."

                        # Run input validation on focus change
                        if self.focus:
                            self.valid(True, True)

                        # If unfocused, validate text
                        if not self.focus and self.text and child_item.height == 0:
                            self.on_enter(self.text)

                        # If box deleted and unfocused, set back to previous text
                        elif not self.focus and not self.text:
                            self.text = self.cache_text

                        # If box filled in and text box clicked
                        if self.focus and self.text:
                            self.text = self.selected_server
                            self.do_cursor_movement('cursor_end', True)
                            Clock.schedule_once(functools.partial(self.do_cursor_movement, 'cursor_end', True), 0.01)
                            Clock.schedule_once(functools.partial(self.select_text, 0), 0.01)

                        [constants.hide_widget(item, self.focus) for item in child.children]

                        return

                except AttributeError:
                    continue

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.halign = "left"
        self.padding_x = 25
        self.size_hint_max = (528, 54)
        self.title_text = "modpack"
        self.hint_text = "import from a file..."
        self.cache_text = ""
        server = ""
        self.selected_server = None if server == '' else server
        self.server_verified = False
        self.update_server(hide_popup=True)

    def on_enter(self, value):
        self.selected_server = self.text.replace("~", constants.home)
        self.update_server()

    # Input validation and server selection
    def valid_text(self, boolean_value, text):
        for child in self.parent.children:
            try:
                if child.id == "InputLabel":
                # Invalid input
                    if not boolean_value:
                        if isinstance(text, str) and text:
                            child.update_text(text)
                        else:
                            child.update_text('This server is invalid or corrupt')
                        self.text = ""
                # Valid input
                    else:
                        child.clear_text()
                    break
            except AttributeError:
                pass

    def update_server(self, force_ignore=False, hide_popup=False):

        def disable_next(disable=False):
            for item in screen_manager.current_screen.next_button.children:
                try:
                    if item.id == "next_button":
                        item.disable(disable)
                        break
                except AttributeError:
                    pass

        self.scroll_x = 0

        if self.selected_server:
            self.selected_server = os.path.abspath(self.selected_server)

            # Check if the selected server is invalid

            if os.path.exists(self.selected_server) and (os.path.basename(self.selected_server).endswith('.zip') or os.path.basename(self.selected_server).endswith('.mrpack')):
                constants.import_data = {'name': None, 'path': self.selected_server}
                box_text = os.path.join(*Path(os.path.abspath(self.selected_server)).parts[-2:-1], os.path.basename(self.selected_server))
                self.cache_text = self.text = box_text[:27] + "..." if len(box_text) > 30 else box_text
                self.valid_text(True, True)
                disable_next(False)

            else:

                if self.selected_server != os.path.abspath(os.curdir):
                    try:
                        self.selected_server = ''
                        if not force_ignore:
                            self.valid_text(False, False)
                        disable_next(True)
                    except AttributeError:
                        pass





class CreateServerPortInput(BaseInput):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.change_timeout = None
        self.size_hint_max = (445, 54)
        self.title_text = "IPv4/port"
        self.hint_text = "enter IPv4 or port  (localhost:25565)"
        self.stinky_text = ""
        self.bind(on_text_validate=self.on_enter)


    def on_enter(self, value):
        self.process_text()

        break_loop = False
        for child in self.parent.children:
            if break_loop:
                break
            for item in child.children:
                try:
                    if item.id == "next_button":
                        if not item.disabled:
                            item.force_click()
                        break_loop = True
                        break
                except AttributeError:
                    pass


    def valid_text(self, boolean_value, text):
        for child in self.parent.children:
            try:
                if child.id == "InputLabel":

                # Valid input
                    if boolean_value:
                        child.clear_text()
                        child.disable_text(False)

                # Invalid input
                    else:
                        child.update_text(self.stinky_text)
                        child.disable_text(True)
                    break

            except AttributeError:
                pass


    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        super().keyboard_on_key_down(window, keycode, text, modifiers)

        if keycode[1] == "backspace":
            self.process_text()


    # Input validation
    def insert_text(self, substring, from_undo=False):

        if not self.text and substring == " ":
            substring = ""

        elif len(self.text) < 21:
            if '\n' in substring:
                substring = substring.splitlines()[0]
            s = re.sub('[^0-9:.]', '', substring)

            if ":" in self.text and ":" in s:
                s = ''
            if ("." in s and ((self.cursor_col > self.text.find(":")) and (self.text.find(":") > -1))) or ("." in s and self.text.count(".") >= 3):
                s = ''

            # Add name to current config
            def process(*a):
                self.process_text(text=(self.text))
            Clock.schedule_once(process, 0)

            return super().insert_text(s, from_undo=from_undo)


    def process_text(self, text=''):

        typed_info = text if text else self.text

        # interpret typed information
        if ":" in typed_info:
            constants.new_server_info['ip'], constants.new_server_info['port'] = typed_info.split(":")
        else:
            if "." in typed_info:
                constants.new_server_info['ip'] = typed_info.replace(":", "")
                constants.new_server_info['port'] = "25565"
            else:
                constants.new_server_info['port'] = typed_info.replace(":", "")

        if not constants.new_server_info['port']:
            constants.new_server_info['port'] = "25565"

        # print("ip: " + constants.new_server_info['ip'], "port: " + constants.new_server_info['port'])

        # Input validation
        try:
            port_check = ((int(constants.new_server_info['port']) < 1024) or (int(constants.new_server_info['port']) > 65535))
        except ValueError:
            port_check = False
        ip_check = (constants.check_ip(constants.new_server_info['ip']) and '.' in typed_info)
        self.stinky_text = ''

        if typed_info:

            if not ip_check and ("." in typed_info or ":" in typed_info):
                self.stinky_text = 'Invalid IPv4 address' if not port_check else 'Invalid IPv4 and port'

            elif port_check:
                self.stinky_text = ' Invalid port  (use 1024-65535)'

        else:
            constants.new_server_info['ip'] = ''
            constants.new_server_info['port'] = '25565'

        process_ip_text()
        self.valid(not self.stinky_text)

class ServerPortInput(CreateServerPortInput):
    def update_config(self, *a):
        def write(*a):
            server_obj = constants.server_manager.current_server
            server_obj.properties_hash = server_obj._get_properties_hash()
            try:
                screen_manager.current_screen.check_changes(server_obj, force_banner=True)
            except AttributeError:
                pass
            server_obj.write_config()
            server_obj.reload_config()
            change_timeout = None

        if self.change_timeout:
            self.change_timeout.cancel()
        self.change_timeout = Clock.schedule_once(write, 0.7)

    def process_text(self, text=''):
        server_obj = constants.server_manager.current_server
        new_ip = ''
        default_port = "25565"
        new_port = default_port

        typed_info = text if text else self.text

        # interpret typed information
        if ":" in typed_info:
            new_ip, new_port = typed_info.split(":")
        else:
            if "." in typed_info or not new_port:
                new_ip = typed_info.replace(":", "")
                new_port = default_port
            else:
                new_port = typed_info.replace(":", "")

        if not str(server_obj.port) or not new_port:
            new_port = default_port

        # Input validation
        try:
            port_check = ((int(new_port) < 1024) or (int(new_port) > 65535))
        except ValueError:
            port_check = False
        ip_check = (constants.check_ip(new_ip) and '.' in typed_info)
        self.stinky_text = ''
        fail = False

        if typed_info:

            if not ip_check and ("." in typed_info or ":" in typed_info):
                self.stinky_text = 'Invalid IPv4 address' if not port_check else 'Invalid IPv4 and port'
                fail = True

            elif port_check:
                self.stinky_text = ' Invalid port  (use 1024-65535)'
                fail = True

        else:
            new_ip = ''
            new_port = '25565'

        if not fail:
            server_obj.ip = new_ip
            server_obj.server_properties['server-ip'] = new_ip
            server_obj.properties_hash = server_obj._get_properties_hash()
            try:
                screen_manager.current_screen.check_changes(server_obj, force_banner=True)
            except AttributeError:
                pass

        if new_port and not fail:
            server_obj.port = int(new_port)
            server_obj.server_properties['server-port'] = new_port

        if (new_ip or new_port) and not fail:
            self.update_config()

        process_ip_text(server_obj=server_obj)
        self.valid(not self.stinky_text)



class CreateServerMOTDInput(BaseInput):

    def on_enter(self, value):

        constants.new_server_info['server_settings']['motd'] = (self.text).strip() if self.text else "A Minecraft Server"

        break_loop = False
        for child in self.parent.children:
            if break_loop:
                break
            for item in child.children:
                try:
                    if item.id == "next_button":
                        item.force_click()
                        break
                except AttributeError:
                    pass

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.size_hint_max = (445, 54)
        self.title_text = "MOTD"
        self.hint_text = "enter a message of the day..."
        self.text = constants.new_server_info['server_settings']['motd'] if constants.new_server_info['server_settings']['motd'] != "A Minecraft Server" else ""
        self.bind(on_text_validate=self.on_enter)

    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        super().keyboard_on_key_down(window, keycode, text, modifiers)

        if keycode[1] == "backspace" and len(self.text):
            # Add name to current config
            constants.new_server_info['server_settings']['motd'] = (self.text).strip() if self.text else "A Minecraft Server"


    # Input validation
    def insert_text(self, substring, from_undo=False):

        if not self.text and substring == " ":
            substring = ""

        elif len(self.text) < 32:
            if '\n' in substring:
                substring = substring.splitlines()[0]
            s = re.sub('[^a-zA-Z0-9 _/{}=+|"\'()*&^%$#@!?;:,.-]', '', substring)

            # Add name to current config
            def get_text(*a):
                constants.new_server_info['server_settings']['motd'] = self.text.strip() if self.text else "A Minecraft Server"
            Clock.schedule_once(get_text, 0)

            return super().insert_text(s, from_undo=from_undo)

class ServerMOTDInput(BaseInput):

    def update_text(self, text):
        def write(*a):
            if self.screen_name == screen_manager.current_screen.name:
                if text != self.server_obj.server_properties['motd'] and text:
                    self.server_obj.server_properties['motd'] = text
                    self.server_obj.properties_hash = self.server_obj._get_properties_hash()
                    screen_manager.current_screen.check_changes(self.server_obj, force_banner=True)
                    self.server_obj.write_config()
                    self.server_obj.reload_config()
                    self.change_timeout = None

        if self.change_timeout:
            self.change_timeout.cancel()
        self.change_timeout = Clock.schedule_once(write, 0.5)

    def on_enter(self, value):
        self.update_text((self.text).strip() if self.text else "A Minecraft Server")

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.change_timeout = None
        self.screen_name = screen_manager.current_screen.name
        self.server_obj = constants.server_manager.current_server
        self.size_hint_max = (528, 54)
        self.title_text = "MOTD"
        self.hint_text = "enter a message of the day..."
        self.text = self.server_obj.server_properties['motd'] if self.server_obj.server_properties['motd'] != "A Minecraft Server" else ""
        self.bind(on_text_validate=self.on_enter)

    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        super().keyboard_on_key_down(window, keycode, text, modifiers)

        if keycode[1] == "backspace":
            # Add name to current config
            self.update_text((self.text).strip() if self.text else "A Minecraft Server")


    # Input validation
    def insert_text(self, substring, from_undo=False):

        if not self.text and substring == " ":
            substring = ""

        elif len(self.text) < 32:
            if '\n' in substring:
                substring = substring.splitlines()[0]
            s = re.sub('[^a-zA-Z0-9 _/{}=+|"\'()*&^%$#@!?;:,.-]', '', substring)

            # Add name to current config
            def get_text(*a):
                self.update_text(self.text.strip() if self.text else "A Minecraft Server")
            Clock.schedule_once(get_text, 0)

            return super().insert_text(s, from_undo=from_undo)



class ServerPlayerInput(BaseInput):

    def on_enter(self, value):
        constants.new_server_info['server_settings']['max_players'] = (self.text).strip() if self.text else "20"


    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.size_hint_max = (440, 54)
        self.title_text = " max players "
        self.hint_text = "max players  (20)"
        self.text = constants.new_server_info['server_settings']['max_players'] if constants.new_server_info['server_settings']['max_players'] != "20" else ""
        self.bind(on_text_validate=self.on_enter)

    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        super().keyboard_on_key_down(window, keycode, text, modifiers)

        if keycode[1] == "backspace" and len(self.text):
            # Add name to current config
            constants.new_server_info['server_settings']['max_players'] = (self.text).strip() if self.text else "20"

    # Input validation
    def insert_text(self, substring, from_undo=False):

        if not self.text and substring in [" ", "0"]:
            substring = ""

        elif len(self.text) < 7:
            if '\n' in substring:
                substring = substring.splitlines()[0]
            s = re.sub('[^0-9]', '', substring)

            # Add name to current config
            def get_text(*a):
                constants.new_server_info['server_settings']['max_players'] = self.text.strip() if self.text else "20"
            Clock.schedule_once(get_text, 0)

            return super().insert_text(s, from_undo=from_undo)



class ServerTickSpeedInput(BaseInput):

    def on_enter(self, value):
        constants.new_server_info['server_settings']['random_tick_speed'] = (self.text).strip() if self.text else "3"


    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.size_hint_max = (440, 54)
        self.title_text = "tick speed"
        self.hint_text = "random tick speed  (3)"
        self.text = constants.new_server_info['server_settings']['random_tick_speed'] if constants.new_server_info['server_settings']['random_tick_speed'] != "3" else ""
        self.bind(on_text_validate=self.on_enter)

    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        super().keyboard_on_key_down(window, keycode, text, modifiers)

        if keycode[1] == "backspace" and len(self.text):
            # Add name to current config
            constants.new_server_info['server_settings']['random_tick_speed'] = (self.text).strip() if self.text else "3"

    # Input validation
    def insert_text(self, substring, from_undo=False):

        if not self.text and substring in [" "]:
            substring = ""

        elif len(self.text) < 5:
            if '\n' in substring:
                substring = substring.splitlines()[0]
            s = re.sub('[^0-9]', '', substring)

            # Add name to current config
            def get_text(*a):
                constants.new_server_info['server_settings']['random_tick_speed'] = self.text.strip() if self.text else "3"
            Clock.schedule_once(get_text, 0)

            return super().insert_text(s, from_undo=from_undo)



class AclInput(BaseInput):

    # Hide input_button on focus
    def _on_focus(self, *args):
        super()._on_focus(*args)

        for child in self.parent.children:
            for child_item in child.children:
                try:
                    if child_item.id == "input_button":

                        # self.hint_text = "search for rules, press 'ENTER' to add..." if self.focus else "search for rules..."

                        # If box filled in and text box clicked
                        if self.focus and self.text:
                            self.text = self.actual_text
                            self.do_cursor_movement('cursor_end', True)
                            Clock.schedule_once(functools.partial(self.do_cursor_movement, 'cursor_end', True), 0.01)
                            Clock.schedule_once(functools.partial(self.select_text, 0), 0.01)

                        if not self.focus:
                            # If text under button, cut it off temporarily
                            self.scroll_x = 0
                            self.cursor = (len(self.text), 0)
                            if self.cursor_pos[0] > (self.x + self.width) - (self.width * 0.38):
                                self.text = self.text[:16] + "..."
                            self.scroll_x = 0
                            Clock.schedule_once(functools.partial(self.select_text, 0), 0.01)

                        [constants.hide_widget(item, self.focus) for item in child.children]

                        return

                except AttributeError:
                    continue

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.halign = "left"
        self.padding_x = 25
        self.size_hint_max = (528, 54)
        self.title_text = ""
        self.hint_text = "search for rules..."
        self.actual_text = ""

    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        super().keyboard_on_key_down(window, keycode, text, modifiers)
        # self.actual_text = self.text + ('' if not text else text)
        # Backspace
        if keycode[0] == 8:
            self.actual_text = self.text + ('' if not text else text)
            screen_manager.current_screen.search_filter(self.actual_text)

    def insert_text(self, substring, from_undo=False):
        if not self.text and substring in [" "]:
            substring = ""

        else:
            if '\n' in substring:
                substring = substring.splitlines()[0]
            s = re.sub('[^a-zA-Z0-9 _().!/,-]', '', substring)

            # Filter input, and process data to search_filter function in AclScreen
            def get_text(*a):
                self.actual_text = self.text.strip() if self.text else ""
                screen_manager.current_screen.search_filter(self.actual_text)
            Clock.schedule_once(get_text, 0)

            return super().insert_text(s, from_undo=from_undo)

class AclRuleInput(BaseInput):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.title_text = "enter rules"
        self.hint_text = "enter rules..."
        self.halign = "left"
        self.padding_x = 25
        self.bind(on_text_validate=self.on_enter)


    def on_enter(self, value):

    # Invalid input
        if not self.text or str.isspace(self.text):
            self.valid(True, False)

    # Valid input
        else:
            break_loop = False
            for child in self.parent.children:
                if break_loop:
                    break
                for item in child.children:
                    try:
                        if item.id == "next_button":
                            item.force_click()
                            break
                    except AttributeError:
                        pass


    def valid_text(self, boolean_value, text):
        for child in self.parent.children:
            try:
                if child.id == "InputLabel":

                # Empty input
                    if not text:
                        child.clear_text()
                        child.disable_text(True)

                # Valid input
                    elif boolean_value:
                        child.clear_text()
                        child.disable_text(False)

            except AttributeError:
                pass


    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        super().keyboard_on_key_down(window, keycode, text, modifiers)

        if not self.text or str.isspace(self.text):
            self.valid(True, False)


    # Input validation
    def insert_text(self, substring, from_undo=False):

        if not self.text and substring == " ":
            substring = ""

        else:

            if screen_manager.current_screen.current_list == "bans":
                reg_exp = '[^a-zA-Z0-9 _.,!/-]'
            else:
                reg_exp = '[^a-zA-Z0-9 _.,!]'

            if '\n' in substring:
                substring = substring.splitlines()[0]
            s = re.sub(reg_exp, '', substring)

            original_rule = self.text.split(",")[:self.text[:self.cursor_index()].count(",") + 1][-1]
            rule = original_rule + s.replace(",","")

            # Format pasted text
            if len(s) > 3:
                s = ', '.join([item.strip()[:16].strip() if not (item.count(".") >= 3) else item.strip() for item in s.split(",")])
                if len(s.split(", ")[0].strip() + original_rule) > 16 and not (original_rule.count(".") >= 3):
                    s = ", " + s + ", "


            # Format typed text
            elif len(rule.strip()) > 16 and not (rule.count(".") >= 3):
                s = ""

            if s == ",":
                s = ", "


            self.valid(True, ((len(self.text + s) > 0) and not (str.isspace(self.text))))

            return super().insert_text(s, from_undo=from_undo)



class ServerFlagInput(BaseInput):

    def write_config(self, text):
        def write(*a):
            self.server_obj.update_flags(text)
            if self.screen_name == screen_manager.current_screen.name:
                screen_manager.current_screen.check_changes(self.server_obj, force_banner=True)

        if self.change_timeout:
            self.change_timeout.cancel()
        self.change_timeout = Clock.schedule_once(write, 0.5)


    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.change_timeout = None
        self.screen_name = screen_manager.current_screen.name
        self.server_obj = constants.server_manager.current_server
        self.size_hint_max = (528, 54)
        self.title_text = "flags"
        self.halign = "left"
        self.padding_x = 25
        self.hint_text = "enter custom launch flags..." if constants.app_config.locale == 'en' else 'launch flags...'

        if self.server_obj.custom_flags:
            self.text = self.server_obj.custom_flags

        self.bind(on_text_validate=self.on_enter)


    def on_enter(self, value):
        self.process_text()


    def valid_text(self, boolean_value, text):
        for child in self.parent.children:
            try:
                if child.id == "InputLabel":

                # Valid input
                    if boolean_value:
                        child.clear_text()
                        child.disable_text(False)

                # Invalid input
                    else:
                        child.update_text(self.stinky_text)
                        child.disable_text(True)
                    break

            except AttributeError:
                pass


    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        super().keyboard_on_key_down(window, keycode, text, modifiers)

        if keycode[1] == "backspace":
            self.process_text()


    # Input validation
    def insert_text(self, substring, from_undo=False):

        if not self.text and substring[0] not in ['-', '@', '<']:
            substring = ""

        elif len(self.text) < 5000:
            if '\n' in substring:
                substring = ' '.join(substring.splitlines())
            if len(substring) > 2:
                substring = substring.strip()
            s = substring

            # Add name to current config
            def process(*a):
                self.process_text(text=(self.text))
            Clock.schedule_once(process, 0)

            return super().insert_text(s, from_undo=from_undo)


    def process_text(self, text=''):

        typed_info = (text if text else self.text).strip()

        # Input validation
        flag_check = all([
            f.strip().startswith('-') or
            f.strip().startswith('@') or
            (f.strip().startswith('<java') and f.strip().endswith('>'))
            for f in typed_info.split(' ')
        ])
        space_check = re.search(r'(-\s|\w-\s|\d-| \s+|-+$)', typed_info, re.IGNORECASE)
        memory_check = re.search(r'-xm(x|s)\d+(b|k|m|g|t)', typed_info, re.IGNORECASE)
        self.stinky_text = ''

        if typed_info:

            if space_check or not flag_check:
                self.stinky_text = 'Invalid formatting'

            elif memory_check:
                self.stinky_text = '   Configure memory above'

            else:
                self.write_config(typed_info.strip())

        else:
            self.write_config('')


        self.valid(not self.stinky_text)



class BlankInput(BaseInput):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.halign = "left"
        self.padding_x = 25
        self.size_hint_max = (440, 54)
        self.hint_text_color = (0.6, 0.6, 1, 0.8)
        self.title_text = ""
        self.hint_text = ""
        self.bind(on_text_validate=self.on_enter)


    # Make the text box non-interactive
    def on_enter(self, value):
        return

    def on_touch_down(self, touch):
        self.focus = False

    def disable(self, boolean):
        self.opacity = 0.4 if boolean else 1

    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        return

    def insert_text(self, substring, from_undo=False):
        return
def blank_input(pos_hint, hint_text, disabled=False):
    blank = BlankInput()
    blank.pos_hint = pos_hint
    blank.hint_text = hint_text
    blank.disable(disabled)
    return blank



# --------------------------------------------------  File chooser  ----------------------------------------------------

def file_popup(ask_type, start_dir=constants.home, ext=[], input_name=None, select_multiple=False, title=None):
    if not constants.check_free_space():
        return []

    final_path = ""
    file_icon = os.path.join(constants.gui_assets, "small-icon.ico")

    title = constants.translate(title)

    # Will find the first file start_dir to auto select
    def iter_start_dir(directory):
        end_dir = directory

        for dir_item in glob(os.path.join(start_dir, "*")):
            end_dir = dir_item
            break

        return end_dir

    def linux_warning():
        screen_manager.current_screen.show_popup(
            "warning",
            "No File Provider",
            "auto-mcs was unable to open a file pop-up.\n\nPlease install the package 'zenity' and try again, or input a path to the input manually.",
            None
        )

    # Make sure that ask_type file can dynamically choose between a list and a single file
    if ask_type == "file":
        try:
            final_path = filechooser.open_file(title=title, filters=ext, path=iter_start_dir(start_dir), multiple=select_multiple, icon=file_icon)
            # Ext = [("Comma-separated Values", "*.csv")]
        except:
            if constants.os_name == 'linux':
                linux_warning()

            # Attempt to use a back-up AppleScript solution for macOS
            elif constants.os_name == 'macos':
                ext_list = '", "'.join(ext)
                ext_command = f'of type {{"{ext_list}"}}'.replace('*.','') if ext else ''
                start_path_command = f'with prompt "{title}"' + (f' default location POSIX file "{start_dir}"' if start_dir else '')

                # AppleScript with f-string formatting for dynamically setting parameters
                script = f"osascript -e 'set myFile to choose file {start_path_command} {ext_command}\nPOSIX path of myFile'"
                final_path = [constants.run_proc(script, return_text=True).strip()]

    elif ask_type == "dir":
        if constants.os_name == "windows":
            root = tk.Tk()
            root.withdraw()
            root.iconbitmap(file_icon)
            final_path = filedialog.askdirectory(initialdir=start_dir, title=title)
            Window.raise_window()
        else:
            try:
                final_path = filechooser.choose_dir(path=iter_start_dir(start_dir), title=title, icon=file_icon, multiple=False)
                final_path = final_path[0] if final_path else None

            except:
                if constants.os_name == 'linux':
                    linux_warning()

                # Attempt to use a back-up AppleScript solution for macOS
                elif constants.os_name == 'macos':
                    start_path_command = f'with prompt "{title}"' + (f' default location POSIX file "{start_dir}"' if start_dir else '')

                    # AppleScript with f-string formatting for dynamically setting parameters
                    script = f"    osascript -e 'set myFolder to choose folder {start_path_command}\nPOSIX path of myFolder'"
                    final_path = constants.run_proc(script, return_text=True).strip()

    # World screen
    if input_name:
        break_loop = False
        for item in screen_manager.current_screen.children:
            if break_loop:
                break
            for child in item.children:
                if break_loop:
                    break
                if child.__class__.__name__ == input_name:
                    if "ServerWorldInput" in input_name:
                        if final_path:
                            child.selected_world = os.path.abspath(final_path)
                            child.update_world()
                    break_loop = True
                    break

    # Import screen
    if input_name:
        break_loop = False
        for child in screen_manager.current_screen.walk():
            if break_loop:
                break
            if child.__class__.__name__ == input_name:
                if input_name.startswith("ServerImport"):
                    if final_path:
                        child.selected_server = os.path.abspath(final_path) if isinstance(final_path, str) else os.path.abspath(final_path[0])
                        child.update_server()
                break_loop = True
                break

    return final_path

# ----------------------------------------------------------------------------------------------------------------------



class HeaderBackground(Widget):

    y_offset = dp(62)

    def update_rect(self, *args):
        self.rect.size = self.size[0], self.y_offset
        self.rect.pos = (self.pos[0], round(Window.height) - self.rect.size[1])

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        with self.canvas.before:
            self.rect = Image(pos=self.pos, size=self.size, allow_stretch=True, keep_ratio=False, source=os.path.join(constants.gui_assets, 'header_background.png'))

        with self.canvas.after:
            self.canvas.clear()

        self.bind(pos=self.update_rect)
        self.bind(size=self.update_rect)



class FooterBackground(Widget):

    y_offset = dp(50)

    def update_rect(self, *args):
        self.rect.size = self.size[0], self.y_offset
        self.rect.pos = self.pos

    def __init__(self, no_background=False, **kwargs):
        super().__init__(**kwargs)

        if no_background:
            source = os.path.join(constants.gui_assets, 'no_background_footer.png')
            color = screen_manager.current_screen.background_color
        else:
            source = os.path.join(constants.gui_assets, 'footer_background.png')
            color = self.background_color = constants.brighten_color(constants.background_color, -0.02)

        with self.canvas.before:
            self.rect = Image(pos=self.pos, size=self.size, allow_stretch=True, keep_ratio=False, source=source)
            self.rect.color = color

        with self.canvas.after:
            self.canvas.clear()

        self.bind(pos=self.update_rect)
        self.bind(size=self.update_rect)



class AlignLabel(Label):
    def on_size(self, *args):
        self.text_size = self.size



def generate_title(title):
    header = FloatLayout()

    text_layout = BoxLayout()
    text_layout.pos = (0, -8)

    background = HeaderBackground()
    label = AlignLabel(color=(0.2, 0.2, 0.4, 0.8), font_name=os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["very-bold"]}.ttf'), font_size=sp(25), size_hint=(1.0, 1.0), halign="center", valign="top")


    # Split title to check for server name before translation
    found_server = False
    if ":" in title:
        title_start, possible_server_name = title.split(':', 1)
        if possible_server_name.strip()[1:-1].lower() in constants.server_list_lower:
            title = f"{constants.translate(title_start)}:{possible_server_name}"
            found_server = True
    if not found_server:
        title = constants.translate(title)


    label.__translate__ = False
    label.text = title
    text_layout.add_widget(label)

    header.add_widget(background)
    header.add_widget(text_layout)
    return header



class SettingsButton(RelativeLayout):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.shown = False

        # Parent button to show/hide settings
        self.hide_button = RelativeIconButton('close', {'center_x': 1}, (0, 5), (None, None), 'close-sharp.png', anchor='right', clickable=True, click_func=self.hide, anchor_text='right', text_offset=(-85, 40), force_color=[[(0.05, 0.05, 0.1, 1), (0.85, 0.6, 0.9, 1)], 'pink'])
        self.hide_button.x = -35

        self.settings_button = RelativeIconButton('settings', {'center_x': 1}, (0, 5), (None, None), 'settings-sharp.png', anchor='right', clickable=True, click_func=self.show, anchor_text='right', text_offset=(-73, 40))
        self.settings_button.x = -35
        self.add_widget(self.settings_button)


        # Buttons when settings menu is opened

        # Changelog button
        def open_changelog(*a):
            if constants.app_online:
                url = f'{constants.project_link}/releases/latest'
                webbrowser.open_new_tab(url)
        self.changelog_button = RelativeIconButton('view changelog', {'center_x': 1}, (0, 5), (None, None), 'document-text-sharp.png', anchor='right', clickable=True, click_func=open_changelog, anchor_text='right', text_offset=(-40, 40))
        self.changelog_button.x = -35
        self.changelog_button.y = 50
        self.changelog_button.opacity = 0
        self.changelog_button.button.disabled = True
        self.add_widget(self.changelog_button)


        # Telepath menu button
        def change_telepath_screen(*a):
            screen_manager.current = 'TelepathManagerScreen'
        self.telepath_button = RelativeIconButton('$telepath$', {'center_x': 1}, (0, 5), (None, None), 'telepath.png', anchor='right', clickable=True, click_func=change_telepath_screen, anchor_text='right', text_offset=(-70, 40))
        self.telepath_button.x = -35
        self.telepath_button.y = 100
        self.telepath_button.opacity = 0
        self.telepath_button.button.disabled = True
        self.add_widget(self.telepath_button)


        # Locale menu button
        def change_locale_screen(*a):
            screen_manager.current = 'ChangeLocaleScreen'
        self.locale_button = RelativeIconButton(constants.get_locale_string(), {'center_x': 1}, (0, 5), (None, None), 'language.png', anchor='right', clickable=True, click_func=change_locale_screen, anchor_text='right', text_offset=(-55, 40))
        self.locale_button.x = -35
        self.locale_button.y = 150
        self.locale_button.opacity = 0
        self.locale_button.button.disabled = True
        self.add_widget(self.locale_button)


        # Discord rich presence toggle
        class DiscordButton(RelativeIconButton):
            def on_hover(self, hovered, *a):
                conn = constants.discord_presence.connected
                disabled = hovered and conn or not hovered and not conn
                Clock.schedule_once(lambda *_: self.change_data(
                    icon = 'discord-strike.png' if disabled else 'discord.png',
                    text = 'disable rich presence' if disabled else 'enable rich presence'
                ), 0.05)
        def toggle_presence():
            toggle_discord_presence()
            self.discord_button.on_hover(False)
            self.hide()
        self.discord_button = DiscordButton('disable rich presence', {'center_x': 1}, (0, 5), (None, None), 'discord.png', anchor='right', clickable=True, click_func=toggle_presence, anchor_text='right', text_offset=(-15, 40))
        self.discord_button.on_hover(False)
        self.discord_button.x = -35
        self.discord_button.y = 200
        self.discord_button.opacity = 0
        self.discord_button.button.disabled = True
        self.add_widget(self.discord_button)


    def show(self, *a):
        self.shown = True
        Animation(opacity=1, duration=0.45).start(self.discord_button)
        Animation(opacity=1, duration=0.4).start(self.locale_button)
        Animation(opacity=1, duration=0.3).start(self.telepath_button)
        Animation(opacity=1, duration=0.15).start(self.changelog_button)
        self.remove_widget(self.settings_button)
        self.add_widget(self.hide_button)
        self.telepath_button.button.disabled = False
        self.locale_button.button.disabled = False
        self.discord_button.button.disabled = False
        self.changelog_button.button.disabled = False

    def hide(self, *a):
        self.shown = False
        Animation(opacity=0, duration=0.03).start(self.discord_button)
        Animation(opacity=0, duration=0.08).start(self.locale_button)
        Animation(opacity=0, duration=0.16).start(self.telepath_button)
        Animation(opacity=0, duration=0.24).start(self.changelog_button)
        self.remove_widget(self.hide_button)
        self.add_widget(self.settings_button)
        def after(*a):
            self.telepath_button.button.disabled = True
            self.locale_button.button.disabled = True
            self.discord_button.button.disabled = True
            self.changelog_button.button.disabled = True
        Clock.schedule_once(after, 0.25)


def footer_label(path, color, progress_screen=False):

    # If remote server, put the instance name behind it
    if constants.server_manager.current_server:
        server_obj = constants.server_manager.current_server
        data = server_obj._telepath_data
        try:
            if data and path.strip().startswith(server_obj.name):
                path = f'[color=#353565]{data["display-name"]}/[/color]{path}'
        except:
            pass

    # Translate footer paths that don't include the server name
    t_path = []
    for i in path.split(', '):
        if '/' in i.lower():
            t_path.append(i)
        elif i.lower() in constants.server_list_lower:
            t_path.append(i)
        else:
            t_path.append(constants.translate(i))
    path = ', '.join(t_path)


    def fit_to_window(label_widget, path_string, *args):
        x = 1
        text = ""
        shrink_value = round(Window.width / 20)
        if len(path_list) > 2:
            shrink_value -= (len("".join(path_list[2:])))

        for item in path_list:
            item_no_tag = item.strip('[color=#353565]').replace('[/color]','')
            if x == 2 and len(item_no_tag) > shrink_value and len(path_list) > 2:
                item = item_no_tag
                item = item[:shrink_value - 4] + f"...{item[-1]}" if (item.endswith("'") or item.endswith("\"")) else item[:shrink_value - 5] + "..."

            text += f'[color={"555599" if x < len(path_list) else color}]' + item + '[/color]'
            if x < len(path_list):
                text += f"[size={round(sp(22))}][font={arrow_font}]  â–¸  [/font][/size]"
            x += 1

        label.text = text

    arrow_font = os.path.join(constants.gui_assets, 'fonts', 'DejaVuSans.otf')

    path_list = path.split(', ')
    path_list.insert(0, "       ")

    final_layout = FloatLayout()

    text_layout = BoxLayout()
    text_layout.pos = (15, 12)
    version_layout = BoxLayout()
    search_layout = RelativeLayout()

    version_layout.pos = (-10 if progress_screen else -60, 13) # x=-10
    label = AlignLabel(color=(0.6, 0.6, 1, 0.2), font_name=os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["bold"]}.ttf'), font_size=sp(22), markup=True, size_hint=(1.0, 1.0), halign="left", valign="bottom")
    label.__translate__ = False
    version_text = f"{constants.app_version}{' (dev)' if constants.dev_version else ''}"
    version = AlignLabel(color=(0.6, 0.6, 1, 0.2), font_name=os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf'), font_size=sp(23), markup=True, size_hint=(1.0, 1.0), halign="right", valign="bottom")
    version.__translate__ = False
    version.text = f"auto-mcs[size={round(sp(18))}]  [/size]v{version_text}"
    if constants.is_admin() and constants.bypass_admin_warning:
        version.text = f"[color=#FF8793]{version.text}[/color]"

    text_layout.bind(pos=functools.partial(fit_to_window, label, path_list))
    text_layout.bind(size=functools.partial(fit_to_window, label, path_list))

    text_layout.add_widget(label)
    version_layout.add_widget(version)

    final_layout.add_widget(text_layout)
    final_layout.add_widget(version_layout)

    if not progress_screen:
        search_button = IconButton('search', {}, (-40, 0), (None, None), 'global-search.png', clickable=True, text_offset=(30, 0), click_func=screen_manager.current_screen.show_search)
        search_layout.add_widget(search_button)
        search_layout.pos_hint = {'center_x': 1}
        search_layout.size_hint_max = (50, 50)
        final_layout.add_widget(search_layout)

    return final_layout

def generate_footer(menu_path, color="9999FF", func_dict=None, progress_screen=False, no_background=False):

    # Sanitize footer path for crash logs to remove server name
    if ", Launch" in menu_path or ", Access Control" in menu_path or ", Back-ups" in menu_path or ", Add-ons" in menu_path or ", amscript" in menu_path or ", Settings" in menu_path:
        constants.footer_path = "Server Manager > " + " > ".join(menu_path.split(", ")[1:])
    elif menu_path.startswith('Create'):
        constants.footer_path = "Create new server"
    elif menu_path.startswith('Import'):
        constants.footer_path = "Import server"
    elif menu_path.split(", ")[0].count("'") == 2:
        constants.footer_path = menu_path.split(", ")[0].split("'")[0] + "Server" + " > ".join(menu_path.split(", ")[1:])
    else:
        constants.footer_path = " > ".join(menu_path.split(", "))

    # Update Discord rich presence
    constants.discord_presence.update_presence(constants.footer_path)

    # Add time modified
    constants.footer_path += f" @ {constants.format_now()}"


    footer = FloatLayout()

    if menu_path == 'splash':
        constants.footer_path = 'Main Menu'

        if constants.app_online:
            footer.add_widget(IconButton('connected', {}, (0, 5), (None, None), 'wifi-sharp.png', clickable=False))

            if constants.app_latest:
                footer.add_widget(IconButton('up to date', {}, (51, 5), (None, None), 'checkmark-sharp.png', clickable=False))
            else:
                click_func = None
                try:
                    if func_dict:
                        click_func = func_dict['update']
                except:
                    pass
                footer.add_widget(IconButton('update now', {}, (51, 5), (None, None), 'sync.png', clickable=True, click_func=click_func, force_color=[[(0.05, 0.08, 0.07, 1), (0.5, 0.9, 0.7, 1)], 'green']))

            click_func = None
            try:
                if func_dict:
                    click_func = func_dict['donate']
            except:
                pass
            footer.add_widget(IconButton('support us', {}, (102, 5), (None, None), 'sponsor.png', clickable=True, force_color=[[(0.05, 0.08, 0.07, 1), (0.6, 0.6, 1, 1)], 'pink'], click_func=click_func, text_hover_color=(0.85, 0.6, 0.95, 1)))

        else:
            footer.add_widget(IconButton('no connection', {}, (0, 5), (None, None), 'ban.png', clickable=True, force_color=[[(0.07, 0.07, 0.07, 1), (0.7, 0.7, 0.7, 1)], 'gray']))

        # Settings button
        settings_button = SettingsButton()
        footer.add_widget(settings_button)

    else:
        footer.add_widget(FooterBackground(no_background=no_background))
        footer.add_widget(footer_label(path=menu_path, color=color, progress_screen=progress_screen)) # menu_path
        if not progress_screen:
            footer.add_widget(IconButton('main menu', {}, (-5, 0), (None, None), 'home-sharp.png', clickable=True))
        else:
            footer.add_widget(AnimButton('please wait...', {}, (0, 0), (None, None), 'loading_pickaxe.gif', clickable=False))

    return footer



def page_counter(index, total, pos):
    layout = FloatLayout()
    label = Label(halign="center")
    label.__translate__ = False
    label.size_hint = (None, None)
    label.pos_hint = {"center_x": 0.5, "center_y": pos[1] - 0.07}
    label.markup = True
    label.font_name = os.path.join(constants.gui_assets, 'fonts', 'DejaVuSans.otf')
    label.font_size = sp(9)
    label.opacity = 1

    text = ''

    for x in range(0, total):
        if x == index - 1:
            text += f'[color=8B8BF9]{"â¬¤   " if x + 1 != total else "â¬¤"}[/color]'
        else:
            text += f'[color=292942]{"â¬¤   " if x + 1 != total else "â¬¤"}[/color]'

    label.text = text

    layout.add_widget(label)
    return layout



class PageButton(HoverButton):

    # Execute page swap on click
    def on_touch_down(self, touch):
        if not self.disabled and self.click_function and self.hovered and self.parent.total_pages > 1:
            self.click_function()

        return super().on_touch_down(touch)

    def __init__(self, facing="left", **kwargs):
        super().__init__(**kwargs)

        # Comments for build script;
        # "caret-back-sharp.png"
        # "caret-forward-sharp.png"
        self.icon = os.path.join(constants.gui_assets, 'icons', f'caret-{"back" if facing == "left" else "forward"}-sharp.png')
        self.facing = facing
        self.id = "page_button"
        self.border = (0, 0, 0, 0)
        self.background_normal = self.icon
        self.background_down = self.icon
        self.color_id = [(0.3, 0.3, 0.53, 1), (0.542, 0.577, 0.918, 1), (0.3, 0.3, 0.53, 0.4)]
        self.background_color = self.color_id[0]
        self.disabled = False
        self.click_function = None
        self.original_size = (22, 22)
        self.size_hint_max = (22, 22)
        self.size_offset = 5
        self.pos_hint = {"center_y": 0.5}
        self.original_x = None

    def on_enter(self, *args):
        if not self.ignore_hover and not self.disabled and self.parent.total_pages > 1:
            new_x = (self.x - self.size_offset / 2)
            new_hint = (self.original_size[0] + self.size_offset, self.original_size[1] + self.size_offset)
            Animation(background_color=self.color_id[1], size_hint_max=new_hint, x=new_x, duration=0.11).start(self)

    def on_leave(self, *args):
        if not self.ignore_hover and self.parent.total_pages > 1:
            Animation(background_color=self.color_id[0], size_hint_max=self.original_size, x=self.original_x, duration=0.11).start(self)

class PageSwitcher(RelativeLayout):

    def resize_self(self, *args):
        self.width = len(self.label.text) * 0.74 + 45

        # if not self.left_button.hovered:
        self.left_button.pos = (Window.center[0] - self.width / 2 - self.left_button.width, Window.center[1])
        self.left_button.original_x = self.left_button.x

        # if not self.right_button.hovered:
        self.right_button.pos = (Window.center[0] + self.width / 2, Window.center[1])
        self.right_button.original_x = self.right_button.x


    def update_index(self, index, total):
        text = ''
        self.total_pages = total

        if index > 0 and total > 0:

            for x in range(0, total):
                if x == index - 1:
                    text += f'[color=8B8BF9]{"â¬¤   " if x + 1 != total else "â¬¤"}[/color]'
                else:
                    text += f'[color=292942]{"â¬¤   " if x + 1 != total else "â¬¤"}[/color]'

            self.label.text = text
            constants.hide_widget(self, False)

            if not (self.left_button.hovered or self.right_button.hovered):
                self.resize_self()

        else:
            constants.hide_widget(self, True)

        # Update button colors if disabled
        Animation(background_color=self.left_button.color_id[(1 if (total > 1 and self.left_button.hovered) else 0 if (total > 1) else 2)], duration=0.2).start(self.left_button)
        Animation(background_color=self.right_button.color_id[(1 if (total > 1 and self.right_button.hovered) else 0 if (total > 1) else 2)], duration=0.2).start(self.right_button)


    def __init__(self, index, total, pos, function, **kwargs):
        super().__init__(**kwargs)

        self.total_pages = 0
        self.size_hint_max_y = 50
        self.pos_hint = {"center_x": 0.5, "center_y": pos[1] - 0.07}

        # Page dots
        self.label = Label(halign="center")
        self.label.__translate__ = False
        self.label.size_hint = (None, None)
        self.label.pos_hint = {"center_x": 0.5, "center_y": 0.5}
        self.label.markup = True
        self.label.font_name = os.path.join(constants.gui_assets, 'fonts', 'DejaVuSans.otf')
        self.label.font_size = sp(9)
        self.label.opacity = 1

        # Buttons
        self.left_button = PageButton(facing="left")
        self.left_button.click_function = functools.partial(function, "left")
        self.right_button = PageButton(facing="right")
        self.right_button.click_function = functools.partial(function, "right")

        self.add_widget(self.label)
        self.add_widget(self.left_button)
        self.add_widget(self.right_button)

        self.update_index(index, total)
        self.bind(pos=self.resize_self)
        Clock.schedule_once(self.resize_self, 0)



class ParagraphObject(RelativeLayout):

    def update_rect(self, *args):

        self.rect.source = os.path.join(constants.gui_assets, f'text_input_cover_fade.png')

        self.title.text = self.title_text
        self.rect.width = (len(self.title.text) * 16) + 116 if self.title.text else 0
        if self.width > 500:
            self.rect.width += (self.width - 500)
        self.rect.pos = self.pos[0] + (self.size[0] / 2) - (self.rect.size[0] / 2) - 1, self.pos[1] + 45 + self.height-56
        self.title.pos = self.pos[0] + (self.size[0] / 2) - (self.title.size[0] / 2), self.pos[1] + 4 + self.height-56

        # Background sizes
        body_offset = 29

        self.background_top.width = self.width
        self.background_top.height = body_offset
        self.background_top.x = self.x
        self.background_top.y = self.y + self.height - self.background_top.height

        self.background_bottom.width = self.width
        self.background_bottom.height = 0 - body_offset
        self.background_bottom.x = self.x
        self.background_bottom.y = self.y

        self.background.width = self.width
        self.background.x = self.x
        self.background.y = self.background_bottom.y + abs(self.background_bottom.height) - body_offset
        self.background.height = self.height - abs(self.background_bottom.height) - abs(self.background_top.height) + body_offset

        self.text_content.y = self.background.y - 25
        self.text_content.x = self.x + 25
        self.text_content.size = self.size
        self.text_content.width = self.width

    def __init__(self, font, **kwargs):
        super().__init__(**kwargs)

        self.title_text = "Paragraph"
        self.size_hint = (None, None)
        self.size_hint_max = (None, None)

        with self.canvas.after:
            # Top
            self.background_top = Image(source=os.path.join(constants.gui_assets, "paragraph_edge.png"))
            self.background_top.allow_stretch = True
            self.background_top.keep_ratio = False

            # Body
            self.background = Image(source=os.path.join(constants.gui_assets, "paragraph_background.png"))
            self.background.allow_stretch = True
            self.background.keep_ratio = False

            # Top
            self.background_bottom = Image(source=os.path.join(constants.gui_assets, "paragraph_edge.png"))
            self.background_bottom.allow_stretch = True
            self.background_bottom.keep_ratio = False

            # Title
            self.rect = Image(size=(110, 15), color=constants.background_color, allow_stretch=True, keep_ratio=False)
            self.title = AlignLabel(halign="center", text=self.title_text, color=(0.6, 0.6, 1, 1), font_size=sp(17), font_name=os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["regular"]}.ttf'))
            self.bind(pos=self.update_rect)
            self.bind(size=self.update_rect)

            # Text content
            self.text_content = AlignLabel(halign="left", valign="top", color=(0.65, 0.65, 1, 1), font_name=font if font else os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["regular"]}.ttf'), markup=True)
            self.text_content.line_height = 1.3

def paragraph_object(size, name, content, font_size, font):
    paragraph_obj = ParagraphObject(font)
    paragraph_obj.pos_hint = {"center_x": 0.5} # , "center_y": 0.5
    paragraph_obj.width = size[0]
    paragraph_obj.height = size[1] + 10
    paragraph_obj.title_text = name
    paragraph_obj.text_content.__translate__ = False
    paragraph_obj.text_content.text = content
    paragraph_obj.text_content.font_size = font_size
    return paragraph_obj



# Scroll View Items
class ScrollViewWidget(ScrollView):
    def __init__(self, position=(0.5, 0.52), **kwargs):
        super().__init__(**kwargs)
        self.size_hint = (1, None)
        self.size = (Window.width, Window.height // 2)
        self.do_scroll_x = False
        self.pos_hint = {"center_x": position[0], "center_y": position[1]}
        self.bar_width = 6
        self.drag_pad = self.bar_width * 15
        self.bar_color = (0.6, 0.6, 1, 1)
        self.bar_inactive_color = (0.6, 0.6, 1, 0.25)
        self.scroll_wheel_distance = dp(55)
        self.scroll_timeout = 250

    # Allow scroll bar to be dragged
    def on_touch_move(self, touch, *args):
        if touch.pos[0] > self.x + (self.width - self.drag_pad) and (self.y + self.height > touch.pos[1] > self.y):
            try:
                new_scroll = ((touch.pos[1] - self.y) / (self.height - (self.height * (self.vbar[1])))) - (self.vbar[1])
                self.scroll_y = 1 if new_scroll > 1 else 0 if new_scroll < 0 else new_scroll
                return True
            except ZeroDivisionError:
                pass
        return super().on_touch_move(touch)

    def on_touch_down(self, touch, *args):
        if touch.pos[0] > self.x + (self.width - self.drag_pad) and (self.y + self.height > touch.pos[1] > self.y):
            try:
                new_scroll = ((touch.pos[1] - self.y) / (self.height - (self.height * (self.vbar[1])))) - (self.vbar[1])
                self.scroll_y = 1 if new_scroll > 1 else 0 if new_scroll < 0 else new_scroll
                return True
            except ZeroDivisionError:
                pass
        return super().on_touch_down(touch)

class ScrollItem(RelativeLayout):
    def __init__(self, widget=None, **kwargs):
        super().__init__(**kwargs)
        self.height = 85
        self.size_hint_y = None

        if widget:
            self.add_widget(widget)

def scroll_background(pos_hint, pos, size, highlight=False, color=None):

    class ScrollBackground(Image):

        def resize(self, *args):
            self.width = Window.width-20

        def __init__(self, **kwargs):
            super().__init__(**kwargs)
            self.allow_stretch = True
            self.keep_ratio = False
            self.size_hint = (None, None)
            if color:
                self.color = color
            else:
                self.color = (1, 1, 1, 1) if highlight else constants.background_color
            self.source = os.path.join(constants.gui_assets, 'scroll_gradient.png')
            Window.bind(on_resize=self.resize)

    img = ScrollBackground()
    img.pos = pos
    img.pos_hint = pos_hint
    img.size = size
    img.width = 830

    Clock.schedule_once(img.resize, 0)

    return img


# Recycle View Items
# Scroll View Items
class RecycleViewWidget(RecycleView):
    def __init__(self, position=(0.5, 0.52), view_class=None, **kwargs):
        super().__init__(**kwargs)
        self.size_hint = (1, None)
        self.size = (Window.width, Window.height // 2)
        self.do_scroll_x = False
        if position:
            self.pos_hint = {"center_x": position[0], "center_y": position[1]}
        self.bar_width = 6
        self.drag_pad = self.bar_width * 15
        self.bar_color = (0.6, 0.6, 1, 1)
        self.bar_inactive_color = (0.6, 0.6, 1, 0.25)
        self.scroll_wheel_distance = dp(55)
        Clock.schedule_once(functools.partial(self.assign_viewclass, view_class), 0)

    # Allow scroll bar to be dragged
    def on_touch_move(self, touch, *args):
        if (touch.pos[0] > self.x + (self.width - self.drag_pad) and (self.y + self.height > touch.pos[1] > self.y)) and touch.button in ['left', 'right']:
            try:
                new_scroll = ((touch.pos[1] - self.y) / (self.height - (self.height * (self.vbar[1])))) - (self.vbar[1])
                self.scroll_y = 1 if new_scroll > 1 else 0 if new_scroll < 0 else new_scroll
                return True
            except ZeroDivisionError:
                pass
        return super().on_touch_move(touch)

    def on_touch_down(self, touch, *args):
        if (touch.pos[0] > self.x + (self.width - self.drag_pad) and (self.y + self.height > touch.pos[1] > self.y)) and touch.button in ['left', 'right']:
            try:
                new_scroll = ((touch.pos[1] - self.y) / (self.height - (self.height * (self.vbar[1])))) - (self.vbar[1])
                self.scroll_y = 1 if new_scroll > 1 else 0 if new_scroll < 0 else new_scroll
                return True
            except ZeroDivisionError:
                pass
        return super().on_touch_down(touch)

    def assign_viewclass(self, view_class, *args):
        self.viewclass = view_class



# Banner layout with random ID
class BannerLayout(FloatLayout):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.id = constants.gen_rstring(10)

# Notification banner object
class BannerObject(RelativeLayout):

    def resize_self(self, *args):
        self.left_side.x = 0
        self.right_side.x = self.size[0]
        self.middle.x = self.left_side.x + self.left_side.width

        if self.icon:
            self.icon.pos_hint = {"center_y": 0.5}

            if self.icon_side == "left":
                self.icon.x = (self.height - 105) * 0.5

            else:
                self.icon.x = self.width - ((self.height + 95) * 0.5)


    def show_animation(self, show=True, *args):

        # On show
        if show:
            for widget in self.children:

                if widget == self.text_object:
                    text_size = self.text_object.font_size
                    self.text_object.font_size = text_size - 12
                    Animation(font_size=text_size, duration=0.15).start(widget)

                if self.icon:
                    if widget == self.icon:
                        original_size = (self.icon.width, self.icon.height)
                        self.icon.size = (self.icon.width - 9, self.icon.height - 9)
                        Animation(size=original_size, duration=0.2).start(widget)

                Animation(opacity=1, duration=0.3).start(widget)

        # On hide
        else:
            for widget in self.children:

                if widget == self.text_object:
                    Animation(font_size=self.text_object.font_size - 15, duration=0.15).start(widget)

                if self.icon:
                    if widget == self.icon:
                        new_size = (self.icon.width - 6, self.icon.height - 6)
                        Animation(size=new_size, duration=0.2).start(widget)

                Animation(opacity=0, duration=0.3).start(widget)


    def __init__(self, pos_hint={"center_x": 0.5, "center_y": 0.5}, size=(200,50), color=(1,1,1,1), text="", icon=None, icon_side="left", animate=False, __translate__=True, **kwargs):
        super().__init__(**kwargs)

        self.size = size
        self.size_hint_max = size
        self.pos_hint = pos_hint
        self.icon_side = icon_side


        # Text
        self.text_object = Label()
        self.text_object.__translate__ = __translate__
        self.text_object.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
        self.text_object.font_size = sp(round(self.height / 1.8))
        self.text_object.color = (0, 0, 0, 0.75)
        self.text_object.markup = True
        if icon:
            self.text_object.text = ("    " + text) if self.icon_side == "left" else (text + "    ")
        else:
            self.text_object.text = "    " + text + "    "

        # Readjust width to fit text if it's too small
        if text:
            new_width = (((len(self.text_object.text) - 4) * (self.text_object.font_size - 8)) / 1.09)

            if new_width > self.width:
                size = (new_width, size[1])
                self.size = size
                self.size_hint_max = size


        # Left side
        self.left_side = Image()
        self.left_side.source = os.path.join(constants.gui_assets, "banner_edge.png")
        self.left_side.color = color
        self.left_side.allow_stretch = True
        self.left_side.keep_ratio = False
        self.left_side.size_hint = (None, None)
        self.left_side.height = size[1]
        self.left_side.width = (size[1] / 2.2)

        # Middle stretched image
        self.middle = Image()
        self.middle.source = os.path.join(constants.gui_assets, "banner_middle.png")
        self.middle.color = color
        self.middle.allow_stretch = True
        self.middle.keep_ratio = False
        self.middle.size_hint = (None, None)
        self.middle.height = size[1]
        self.middle.width = size[0] - ((size[1] / 2.2) * 2)

        # Right side
        self.right_side = Image()
        self.right_side.source = os.path.join(constants.gui_assets, "banner_edge.png")
        self.right_side.color = color
        self.right_side.allow_stretch = True
        self.right_side.keep_ratio = False
        self.right_side.size_hint = (None, None)
        self.right_side.height = size[1]
        self.right_side.width = -(size[1] / 2.2)


        self.add_widget(self.left_side)
        self.add_widget(self.middle)
        self.add_widget(self.right_side)
        self.add_widget(self.text_object)


        # If icon is specified
        if icon:
            self.icon = Image()
            self.icon.source = os.path.join(constants.gui_assets, 'icons', icon)
            self.icon.color = (0, 0, 0, 0.8)
            self.icon.size_hint = (None, None)
            self.icon.allow_stretch = True
            self.icon.height = size[1] / 1.6

            self.add_widget(self.icon)
        else:
            self.icon = None


        self.bind(pos=self.resize_self)
        Clock.schedule_once(self.resize_self, 0)

        if animate:
            for widget in self.children:
                widget.opacity = 0
            Clock.schedule_once(functools.partial(self.show_animation, True), 0)



# ----------------------------------------------------  Buttons  -------------------------------------------------------
class MainButton(FloatLayout):

    def repos_icon(self, *args):

        def resize(*args):
            pos_calc = ((self.button.width/2 - 35) if self.button.center[0] > 0 else (-self.button.width/2 + 35))
            self.icon.center[0] = self.button.center[0] + pos_calc

        Clock.schedule_once(resize, 0)

    def __init__(self, name, position, icon_name=None, width=None, icon_offset=None, auto_adjust_icon=False, click_func=None, **args):
        super().__init__(**args)

        self.id = name

        self.button = HoverButton()
        self.button.id = 'main_button'
        self.button.color_id = [(0.05, 0.05, 0.1, 1), (0.6, 0.6, 1, 1)]
        self.button.size_hint = (None, None)
        self.button.size = (dp(450 if not width else width), dp(72))
        self.button.pos_hint = {"center_x": position[0], "center_y": position[1]}
        self.button.border = (30, 30, 30, 30)
        self.button.background_normal = os.path.join(constants.gui_assets, 'main_button.png')
        self.button.background_down = os.path.join(constants.gui_assets, 'main_button_click.png')

        self.text = Label()
        self.text.id = 'text'
        self.text.size_hint = (None, None)
        self.text.pos_hint = {"center_x": position[0], "center_y": position[1]}

        # Justify text spacing for other languages
        translated = constants.translate(name)
        if auto_adjust_icon:
            if position[0] >= 0.5:
                text = name.upper() + (int(round(len(translated)*.7))*' ')
            else:
                text = (int(round(len(translated)*.7))*' ') + name.upper()
        elif len(translated) > 28:
            text = (int(round(len(translated)*.2))*' ') + name.upper()
        else:
            text = name.upper()
        self.text.text = text

        self.text.font_size = sp(19)
        self.text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["bold"]}.ttf')
        self.text.color = (0.6, 0.6, 1, 1)


        # Button click behavior
        self.button.on_release = functools.partial(button_action, name, self.button)
        self.add_widget(self.button)

        if icon_name:
            self.icon = Image()
            self.icon.id = 'icon'
            self.icon.source = icon_path(icon_name)
            self.icon.size = (dp(1), dp(1))
            self.icon.color = (0.6, 0.6, 1, 1)
            self.icon.pos_hint = {"center_y": position[1]}
            self.icon.pos = (icon_offset if icon_offset else -190 if not width else (-190 - (width / 13)), 200)
            self.add_widget(self.icon)

        self.add_widget(self.text)

        if auto_adjust_icon and icon_name:
            Clock.schedule_once(self.repos_icon, 0)

        if click_func:
            self.button.bind(on_press=click_func)



def color_button(name, position, icon_name=None, width=None, icon_offset=None, auto_adjust_icon=False, click_func=None, color=(1, 1, 1, 1), disabled=False, hover_data={'color': None, 'image': None}):

    def repos_icon(icon_widget, button_widget, *args):

        def resize(*args):
            pos_calc = ((button_widget.width/2 - 35) if button_widget.center[0] > 0 else (-button_widget.width/2 + 35))
            icon_widget.center[0] = button_widget.center[0] + pos_calc

        Clock.schedule_once(resize, 0)

    final = FloatLayout()
    final.id = name

    class ColorButton(HoverButton):
        def on_enter(self, *args):
            if not self.ignore_hover:
                if hover_data['color'] or hover_data['image']:
                    animate_button(self, image=hover_data['image'], color=hover_data['color'])
                else:
                    super().on_enter(*args)

    final.button = ColorButton()
    final.button.id = 'color_button'
    final.button.color_id = [constants.brighten_color(color, -0.9), color]

    final.button.size_hint = (None, None)
    final.button.size = (dp(450 if not width else width), dp(72))
    final.button.pos_hint = {"center_x": position[0], "center_y": position[1]}
    final.button.border = (30, 30, 30, 30)
    final.button.background_normal = os.path.join(constants.gui_assets, 'color_button.png')
    final.button.background_down = os.path.join(constants.gui_assets, 'color_button_click.png') if not disabled else final.button.background_normal
    final.button.background_disabled_normal = os.path.join(constants.gui_assets, 'color_button.png')
    final.button.background_disabled_down = os.path.join(constants.gui_assets, 'color_button_click.png')
    final.button.background_color = final.button.color_id[1]

    text = Label()
    text.id = 'text'
    text.size_hint = (None, None)
    text.pos_hint = {"center_x": position[0], "center_y": position[1]}
    text.text = name.upper()
    text.font_size = sp(19)
    text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["bold"]}.ttf')
    text.color = final.button.color_id[1]


    # Button click behavior
    final.button.on_release = functools.partial(button_action, name, final.button)
    final.add_widget(final.button)

    if icon_name:
        icon = Image()
        icon.id = 'icon'
        icon.source = icon_path(icon_name)
        icon.size = (dp(1), dp(1))
        icon.color = final.button.color_id[1]
        icon.pos_hint = {"center_y": position[1]}
        icon.pos = (icon_offset if icon_offset else -190 if not width else (-190 - (width / 13)), 200)
        if disabled:
            icon.opacity = 0
        final.add_widget(icon)

    final.add_widget(text)

    if auto_adjust_icon and icon_name:
        Clock.schedule_once(functools.partial(repos_icon, icon, final.button), 0)

    if click_func and not disabled:
        final.button.bind(on_press=click_func)

    final.button.ignore_hover = disabled
    if disabled:
        final.opacity = 0.4
        final.button.opacity = 0.5

    return final


class WaitButton(FloatLayout):

    def repos_icon(self, *args):

        def resize(*args):
            pos_calc = ((self.button.width/2 - 35) if self.button.center[0] > 0 else (-self.button.width/2 + 35))
            self.icon.center[0] = self.button.center[0] + pos_calc
            self.load_icon.center[0] = self.button.center[0] + pos_calc

        Clock.schedule_once(resize, 0)

    def loading(self, boolean_value, *args):
        self.button.on_leave()
        self.disable(boolean_value)
        self.load_icon.color = (0.6, 0.6, 1, 1) if boolean_value else (0.6, 0.6, 1, 0)

    def disable(self, disable=False, animate=True):
        self.button.disabled = disable
        duration = (0.12 if animate else 0)
        Animation(color=(0.6, 0.6, 1, 0.4) if self.button.disabled else (0.6, 0.6, 1, 1), duration=duration).start(self.text)
        Animation(color=(0.6, 0.6, 1, 0) if self.button.disabled else (0.6, 0.6, 1, 1), duration=duration).start(self.icon)

    def __init__(self, name, position, icon_name=None, width=None, icon_offset=None, auto_adjust_icon=False, click_func=None, disabled=False, start_loading=False, **kwargs):
        super().__init__(**kwargs)

        self.id = name

        self.button = HoverButton()
        self.button.id = 'main_button'
        self.button.color_id = [(0.05, 0.05, 0.1, 1), (0.6, 0.6, 1, 1)]

        self.button.size_hint = (None, None)
        self.button.size = (dp(450 if not width else width), dp(72))
        self.button.pos_hint = {"center_x": position[0], "center_y": position[1]}
        self.button.border = (30, 30, 30, 30)
        self.button.background_normal = os.path.join(constants.gui_assets, 'main_button.png')
        self.button.background_down = os.path.join(constants.gui_assets, 'main_button_click.png')
        self.button.background_disabled_normal = os.path.join(constants.gui_assets, 'main_button_disabled.png')
        self.button.background_disabled_down = os.path.join(constants.gui_assets, 'main_button_disabled.png')

        self.text = Label()
        self.text.id = 'text'
        self.text.size_hint = (None, None)
        self.text.pos_hint = {"center_x": position[0], "center_y": position[1]}
        self.text.text = name.upper()
        self.text.font_size = sp(19)
        self.text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["bold"]}.ttf')
        self.text.color = (0.6, 0.6, 1, 1)


        # Button click behavior
        self.button.on_release = functools.partial(button_action, name, self.button)
        self.add_widget(self.button)

        if icon_name:
            self.icon = Image()
            self.icon.id = 'icon'
            self.icon.source = icon_path(icon_name)
            self.icon.size = (dp(1), dp(1))
            self.icon.color = (0.6, 0.6, 1, 1)
            self.icon.pos_hint = {"center_y": position[1]}
            self.icon.pos = (icon_offset if icon_offset else -190 if not width else (-190 - (width / 13)), 200)
            self.add_widget(self.icon)


        # Loading icon
        self.load_icon = AsyncImage()
        self.load_icon.id = 'load_icon'
        self.load_icon.source = os.path.join(constants.gui_assets, 'animations', 'loading_pickaxe.gif')
        self.load_icon.size_hint_max_y = 40
        self.load_icon.color = (0.6, 0.6, 1, 0)
        self.load_icon.pos_hint = {"center_y": position[1]}
        self.load_icon.pos = (icon_offset if icon_offset else -190 if not width else (-190 - (width / 13)), 200)
        self.load_icon.allow_stretch = True
        self.load_icon.anim_delay = constants.anim_speed * 0.02
        self.add_widget(self.load_icon)


        self.add_widget(self.text)

        if auto_adjust_icon and icon_name:
            Clock.schedule_once(self.repos_icon, 0)

        if click_func:
            self.button.bind(on_press=click_func)

        if disabled:
            self.disable(True, False)

        if start_loading:
            self.loading(True)



class IconButton(FloatLayout):

    def change_data(self, icon=None, text=None, click_func=None):
        if icon:
            self.icon.source = icon_path(icon)

        if text:
            self.text.text = text.lower()

        if click_func:
            self.button.on_release = functools.partial(click_func)

    def resize(self, *args):
        self.x = Window.width - self.default_pos[0]
        self.y = Window.height - self.default_pos[1]

        if self.default_pos:
            self.button.pos = (self.x + 11, self.y)
            self.icon.pos = (self.x, self.y - 11)

            if self.anchor == "left":
                self.text.pos = (self.x - 10, self.y + 17)
                if self.text.pos[0] <= 0:
                    self.text.pos[0] += sp(len(self.text.text) * 3)

            elif self.anchor == "right":
                self.text.pos = (self.x - 4, self.y - 17)
                if self.text.pos[0] >= Window.width - self.button.width * 2:
                    self.text.pos[0] -= sp(len(self.text.text) * 3)
                    self.text.pos[1] -= self.button.height

        if self.text.offset[0] != 0 or self.text.offset[1] != 0:
            self.text.pos[0] = self.text.pos[0] - self.text.offset[0]
            self.text.pos[1] = self.text.pos[1] - self.text.offset[1]

    def __init__(self, name, pos_hint, position, size_hint, icon_name=None, clickable=True, force_color=None, anchor='left', click_func=None, text_offset=(0, 0), text_hover_color=None, **kwargs):
        super().__init__(**kwargs)

        self.default_pos = position
        self.anchor = anchor

        self.button = HoverButton()
        self.button.id = 'icon_button'
        self.button.color_id = [(0.05, 0.05, 0.1, 1), (0.6, 0.6, 1, 1)] if not force_color else force_color[0]

        if force_color and force_color[1]:
            self.button.alt_color = "_" + force_color[1]

        self.button.size_hint = size_hint
        self.button.size = (dp(50), dp(50))
        self.button.pos_hint = pos_hint

        if position:
            self.button.pos = (position[0] + 11, position[1])

        self.button.border = (0, 0, 0, 0)
        self.button.background_normal = os.path.join(constants.gui_assets, f'{self.button.id}.png')

        if not force_color or not force_color[1]:
            self.button.background_down = os.path.join(constants.gui_assets, f'{self.button.id}_click.png' if clickable else f'{self.button.id}_hover.png')
        else:
            self.button.background_down = os.path.join(constants.gui_assets, f'{self.button.id}_click_{force_color[1]}.png' if clickable else f'{self.button.id}_hover_{force_color[1]}.png')

        self.text = Label()
        self.text.id = 'text'
        self.text.size_hint = size_hint
        self.text.pos_hint = pos_hint
        self.text.text = name.lower()
        self.text.hover_color = text_hover_color if text_hover_color else None
        self.text.font_size = sp(19)
        self.text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
        self.text.color = (0, 0, 0, 0)
        self.text.offset = text_offset

        if position:
            self.text.pos = (position[0] - 10, position[1] + 17)

        if self.text.pos[0] <= 0:
            self.text.pos[0] += sp(len(self.text.text) * 3)

        if self.text.offset[0] != 0 or self.text.offset[1] != 0:
            self.text.pos[0] = self.text.pos[0] - self.text.offset[0]
            self.text.pos[1] = self.text.pos[1] - self.text.offset[1]


        if clickable:
            # Button click behavior
            if click_func:
                self.button.on_release = functools.partial(click_func)
            else:
                self.button.on_release = functools.partial(button_action, name, self.button)


        self.add_widget(self.button)

        if icon_name:
            self.icon = Image()
            self.icon.id = 'icon'
            self.icon.size_hint = size_hint
            self.icon.source = icon_path(icon_name)
            self.icon.size = (dp(72), dp(72))
            self.icon.color = self.button.color_id[1]
            self.icon.pos_hint = pos_hint

            if position:
                self.icon.pos = (position[0], position[1] - 11)

            self.add_widget(self.icon)

        self.add_widget(self.text)

        # Check for right float
        if anchor == "right":
            self.bind(size=self.resize)
            self.bind(pos=self.resize)

class RelativeIconButton(RelativeLayout):

    def change_data(self, icon=None, text=None, click_func=None):
        if icon:
            self.icon.source = icon_path(icon)

        if text:
            self.text.text = text.lower()

        if click_func:
            self.button.on_release = functools.partial(click_func)

    def resize(self, *args):
        self.text.x = Window.width - self.text.texture_size[0] + 25
        if self.text_offset:
            self.text.x += self.text_offset[0]

    def on_hover(self, hovered=False, *a):
        pass

    def __init__(self, name, pos_hint, position, size_hint, icon_name=None, clickable=True, force_color=None, anchor='left', click_func=None, text_offset=(0, 0), text_hover_color=None, anchor_text=None, **kwargs):
        super().__init__(**kwargs)

        self.default_pos = position
        self.anchor = anchor

        self.button = HoverButton()
        self.button.id = 'icon_button'
        self.button.color_id = [(0.05, 0.05, 0.1, 1), (0.6, 0.6, 1, 1)] if not force_color else force_color[0]
        self.text_offset = text_offset

        if force_color and force_color[1]:
            self.button.alt_color = "_" + force_color[1]

        self.button.size_hint = size_hint
        self.button.size = (dp(50), dp(50))
        self.button.pos_hint = pos_hint

        if position:
            self.button.pos = (position[0] + 11, position[1])

        self.button.border = (0, 0, 0, 0)
        self.button.background_normal = os.path.join(constants.gui_assets, f'{self.button.id}.png')

        if not force_color or not force_color[1]:
            self.button.background_down = os.path.join(constants.gui_assets, f'{self.button.id}_click.png' if clickable else f'{self.button.id}_hover.png')
        else:
            self.button.background_down = os.path.join(constants.gui_assets, f'{self.button.id}_click_{force_color[1]}.png' if clickable else f'{self.button.id}_hover_{force_color[1]}.png')

        if anchor_text:
            self.text = AlignLabel()
            self.text.halign = anchor_text
        else:
            self.text = Label()
        self.text.id = 'text'
        self.text.size_hint = size_hint
        if pos_hint and not anchor_text:
            self.text.pos_hint = pos_hint
        self.text.text = name.lower()
        self.text.hover_color = text_hover_color if text_hover_color else None
        self.text.font_size = sp(19)
        self.text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
        self.text.color = (0, 0, 0, 0)
        self.text.offset = text_offset

        if position:
            self.text.pos = (position[0] - 10, position[1] + 17)

        if self.text.pos[0] <= 0:
            self.text.pos[0] += sp(len(self.text.text) * 3)

        self.text.original_pos = self.text.pos

        if self.text.offset[0] != 0 or self.text.offset[1] != 0:
            self.text.pos[0] = self.text.original_pos[0] - self.text.offset[0]
            self.text.pos[1] = self.text.original_pos[1] - self.text.offset[1]


        if clickable:
            # Button click behavior
            if click_func:
                self.button.on_release = functools.partial(click_func)
            else:
                self.button.on_release = functools.partial(button_action, name, self.button)


        self.add_widget(self.button)

        if icon_name:
            self.icon = Image()
            self.icon.id = 'icon'
            self.icon.size_hint = size_hint
            self.icon.source = icon_path(icon_name)
            self.icon.size = (dp(72), dp(72))
            self.icon.color = self.button.color_id[1]
            if pos_hint:
                self.icon.pos_hint = pos_hint

            if position:
                self.icon.pos = (position[0], position[1] - 11)

            self.add_widget(self.icon)

        self.add_widget(self.text)

        if anchor_text == "right":
            self.bind(size=self.resize)
            self.bind(pos=self.resize)

        if screen_manager.current_screen.name == 'MainMenuScreen':
            Clock.schedule_once(self.text.texture_update, 0)
            Clock.schedule_once(self.resize, 0)

        # Hover hook
        self.button.bind(on_enter=lambda *_: self.on_hover(True))
        self.button.bind(on_leave=lambda *_: self.on_hover(False))

class AnimButton(FloatLayout):

    def resize(self, *args):
        self.x = Window.width - self.default_pos[0]
        self.y = Window.height - self.default_pos[1]

        if self.default_pos:
            self.button.pos = (self.x + 11, self.y)
            self.icon.pos = (self.x, self.y - 11)

            if self.anchor == "left":
                self.text.pos = (self.x - 10, self.y + 17)
                if self.text.pos[0] <= 0:
                    self.text.pos[0] += sp(len(self.text.text) * 3)

            elif self.anchor == "right":
                self.text.pos = (self.x - 4, self.y - 17)
                if self.text.pos[0] >= Window.width - self.button.width * 2:
                    self.text.pos[0] -= sp(len(self.text.text) * 3)
                    self.text.pos[1] -= self.button.height

    def __init__(self, name, pos_hint, position, size_hint, icon_name=None, clickable=True, force_color=None, anchor='left', click_func=None, text_hover_color=None, **kwargs):
        super().__init__(**kwargs)

        self.default_pos = position
        self.anchor = anchor

        self.button = HoverButton()
        self.button.id = 'icon_button'
        self.button.color_id = [(0.05, 0.05, 0.1, 1), (0.6, 0.6, 1, 1)] if not force_color else force_color[0]

        if force_color:
            self.button.alt_color = "_" + force_color[1]

        self.button.size_hint = size_hint
        self.button.size = (dp(50), dp(50))
        self.button.pos_hint = pos_hint

        if position:
            self.button.pos = (position[0] + 11, position[1])

        self.button.border = (0, 0, 0, 0)
        self.button.background_normal = os.path.join(constants.gui_assets, f'{self.button.id}.png')

        if not force_color:
            self.button.background_down = os.path.join(constants.gui_assets, f'{self.button.id}_click.png' if clickable else f'{self.button.id}_hover.png')
        else:
            self.button.background_down = os.path.join(constants.gui_assets, f'{self.button.id}_click_{force_color[1]}.png' if clickable else f'{self.button.id}_hover_{force_color[1]}.png')

        self.text = Label()
        self.text.id = 'text'
        self.text.size_hint = size_hint
        self.text.pos_hint = pos_hint
        self.text.text = name.lower()
        self.text.hover_color = text_hover_color if text_hover_color else None
        self.text.font_size = sp(19)
        self.text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
        self.text.color = (0, 0, 0, 0)

        if position:
            self.text.pos = (position[0] - 10, position[1] + 17)

        if self.text.pos[0] <= 0:
            self.text.pos[0] += sp(len(self.text.text) * 3)

        if clickable:
            # Button click behavior
            if click_func:
                self.button.on_release = functools.partial(click_func)
            else:
                self.button.on_release = functools.partial(button_action, name, self.button)

        self.add_widget(self.button)

        if icon_name:
            self.icon = AsyncImage()
            self.icon.id = 'icon'
            self.icon.source = os.path.join(constants.gui_assets, 'animations', icon_name)
            self.icon.size_hint_max = (dp(45), dp(45))
            self.icon.color = self.button.color_id[1]
            self.icon.pos_hint = pos_hint
            self.icon.allow_stretch = True
            self.icon.anim_delay = constants.anim_speed * 0.02

            if position:
                self.icon.texture_update()
                self.icon.pos = (self.button.pos[0] + 2.2, self.button.pos[1] + 2.2)

            self.add_widget(self.icon)

        self.add_widget(self.text)

        # Check for right float
        if anchor == "right":
            self.bind(size=self.resize)
            self.bind(pos=self.resize)

class BigIcon(HoverButton):

    def deselect(self):
        self.selected = False
        for child in [x for x in self.parent.children if x.id == "icon"]:
            if child.type == self.type:
                self.on_leave()
        self.background_normal = os.path.join(constants.gui_assets, f'{self.id}.png')
        self.background_down = os.path.join(constants.gui_assets, f'{self.id}_click.png')
        self.background_hover = os.path.join(constants.gui_assets, f'{self.id}_hover.png')

    def on_click(self):
        cl1 = screen_manager.current_screen.content_layout_1
        cl2 = screen_manager.current_screen.content_layout_2

        if self.type == 'more':
            if cl2.opacity == 0:
                constants.hide_widget(cl2, False)
                constants.hide_widget(cl1)
            else:
                constants.hide_widget(cl1, False)
                constants.hide_widget(cl2)
            return

        def iterator(layout, *a):
            for item in layout.children:
                for child_item in item.children:
                    for child_button in child_item.children:
                        if child_button.id == 'big_icon_button':

                            if child_button.type == 'more':
                                child_button.deselect()
                                continue

                            if child_button.hovered is True:
                                child_button.selected = True
                                child_button.on_enter()
                                child_button.background_down = os.path.join(constants.gui_assets, f'{child_button.id}_selected.png')
                                constants.new_server_info['type'] = child_button.type

                            else:
                                child_button.deselect()

                            break
        iterator(cl1)
        iterator(cl2)


def big_mode_button(name, pos_hint, position, size_hint, icon_name=None, clickable=True, force_color=None, text_hover_color=None, click_func=None):

    final = RelativeLayout()
    final.size_hint_max_y = dp(150)
    final.pos_hint = {'center_y': 0.5, 'center_x': 0.5}
    final.anchor_x = 'center'

    button = BigIcon()
    button.id = 'big_icon_button'
    button.color_id = [(0.47, 0.52, 1, 1), (0.6, 0.6, 1, 1)] if not force_color else force_color[0]
    button.type = icon_name

    if force_color:
        button.alt_color = "_" + force_color[1]

    button.size_hint = size_hint
    button.size = (dp(150), dp(150))
    button.pos_hint = pos_hint

    if position:
        button.pos = (position[0] + 11, position[1])

    button.border = (0, 0, 0, 0)
    button.background_normal = os.path.join(constants.gui_assets, f'{button.id}.png')

    if not force_color:
        if button.selected:
            button.background_down = os.path.join(constants.gui_assets, f'{button.id}_selected.png')
        else:
            button.background_down = os.path.join(constants.gui_assets, f'{button.id}_click.png' if clickable else f'{button.id}_hover.png')
    else:
        button.background_down = os.path.join(constants.gui_assets, f'{button.id}_click_{force_color[1]}.png' if clickable else f'{button.id}_hover_{force_color[1]}.png')

    text = Label()
    text.id = 'text'
    text.size_hint = size_hint
    text.pos_hint = {'center_x': pos_hint['center_x'], 'center_y': pos_hint['center_y'] - 0.11}
    text.text = name.lower()
    text.hover_color = text_hover_color if text_hover_color else None
    text.font_size = sp(19)
    text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
    text.color = (0, 0, 0, 0)

    if position:
        text.pos = (position[0] - 10, position[1] - 17)

    if text.pos[0] <= 0:
        text.pos[0] += sp(len(text.text) * 3)


    if clickable and click_func:
        # Button click behavior
        button.on_release = functools.partial(click_func)


    final.add_widget(button)

    if icon_name:
        icon = Image()
        icon.id = 'icon'
        icon.type = button.type
        icon.size_hint = size_hint
        icon.source = icon_path(os.path.join('big', 'modes', f'{icon_name}.png'))
        icon.size = (dp(125), dp(125))
        icon.color = button.color_id[1]
        icon.pos_hint = {'center_x': pos_hint['center_x'], 'center_y': pos_hint['center_y'] + 0.005}

        if position:
            icon.pos = (position[0], position[1] - 11)

        final.add_widget(icon)


        icon_text = Label()
        icon_text.id = 'icon'
        icon_text.size_hint_max = (130, 120)
        icon_text.text_size = (130, 120)
        icon_text.halign = 'center'
        icon_text.pos_hint = {"center_x": 0.5, "center_y": 0.5}
        icon_text.text = icon_name.lower()
        icon_text.font_size = sp(23)
        icon_text.font_name = os.path.join(constants.gui_assets, 'fonts', 'CenturyGothic.ttf')
        icon_text.color = (0.6, 0.6, 1, 1)

        final.add_widget(icon_text)

    final.add_widget(text)

    return final


def big_icon_button(name, pos_hint, position, size_hint, icon_name=None, clickable=True, force_color=None, selected=False, text_hover_color=None):

    final = FloatLayout()

    button = BigIcon()
    button.selected = selected
    button.id = 'big_icon_button'
    button.color_id = [(0.47, 0.52, 1, 1), (0.6, 0.6, 1, 1)] if not force_color else force_color[0]
    button.type = icon_name

    if force_color:
        button.alt_color = "_" + force_color[1]

    button.size_hint = size_hint
    button.size = (dp(150), dp(150))
    button.pos_hint = pos_hint

    if position:
        button.pos = (position[0] + 11, position[1])

    button.border = (0, 0, 0, 0)
    button.background_normal = os.path.join(constants.gui_assets, f'{button.id}{"_selected" if selected else ""}.png')

    if not force_color:
        if button.selected:
            button.background_down = os.path.join(constants.gui_assets, f'{button.id}_selected.png')
        else:
            button.background_down = os.path.join(constants.gui_assets, f'{button.id}_click.png' if clickable else f'{button.id}_hover.png')
    else:
        button.background_down = os.path.join(constants.gui_assets, f'{button.id}_click_{force_color[1]}.png' if clickable else f'{button.id}_hover_{force_color[1]}.png')

    text = Label()
    text.id = 'text'
    text.size_hint = size_hint
    text.pos_hint = {'center_x': pos_hint['center_x'], 'center_y': pos_hint['center_y'] - 0.11}
    text.text = name.lower()
    text.hover_color = text_hover_color if text_hover_color else None
    text.font_size = sp(19)
    text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
    text.color = (0, 0, 0, 0)

    if position:
        text.pos = (position[0] - 10, position[1] - 17)

    if text.pos[0] <= 0:
        text.pos[0] += sp(len(text.text) * 3)


    if clickable:
        # Button click behavior
        button.on_release = functools.partial(button.on_click)


    final.add_widget(button)

    if icon_name:
        icon = Image()
        icon.id = 'icon'
        icon.type = button.type
        icon.size_hint = size_hint
        icon.source = icon_path(os.path.join('big', f'{icon_name}.png'))
        icon.size = (dp(125), dp(125))
        icon.color = button.color_id[1] if not selected else (0.05, 0.05, 0.1, 1)
        icon.pos_hint = pos_hint

        if position:
            icon.pos = (position[0], position[1] - 11)

        final.add_widget(icon)

    final.add_widget(text)

    return final



class ExitButton(RelativeLayout):

    def __init__(self, name, position, cycle=False, custom_func=None, **args):
        super().__init__(**args)

        self.button = HoverButton()
        self.button.id = 'exit_button'
        self.button.color_id = [(0.1, 0.05, 0.05, 1), (0.6, 0.6, 1, 1)]
        self.button.size_hint = (None, None)
        self.button.size = (dp(195), dp(55))
        self.button.pos_hint = {"center_x": position[0], "center_y": position[1]}
        self.button.border = (-10, -10, -10, -10)
        self.button.background_normal = os.path.join(constants.gui_assets, 'exit_button.png')
        self.button.background_down = os.path.join(constants.gui_assets, 'exit_button_click.png')
        self.custom_func = custom_func

        self.text = Label()
        self.text.id = 'text'
        self.text.size_hint = (None, None)
        self.text.pos_hint = {"center_x": position[0], "center_y": position[1]}

        # Justify text spacing for other languages
        translated = constants.translate(name)
        if len(translated) == len(name):
            text = name.upper()
        else:
            text = (int(round(len(translated)*.7))*' ') + name.upper()
        self.text.text = text

        self.text.font_size = sp(19)
        self.text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["bold"]}.ttf')
        self.text.color = (0.6, 0.6, 1, 1)

        self.icon = Image()
        self.icon.id = 'icon'
        self.icon.source = icon_path('close-circle-outline.png' if name.lower() == "quit" else 'back-outline.png')
        self.icon.size = (dp(1), dp(1))
        self.icon.color = (0.6, 0.6, 1, 1)
        self.icon.pos_hint = {"center_y": position[1]}
        self.icon.pos = (-70, 200)


        # Button click behavior
        def execute(*a):
            if self.custom_func:
                self.custom_func()
            else:
                button_action(name, self.button)

        self.button.on_release = execute


        self.add_widget(self.button)
        self.add_widget(self.icon)
        self.add_widget(self.text)



class NextButton(HoverButton):

    def disable(self, disable):

        self.disabled = disable
        for item in self.parent.children:
            try:
                if item.id == 'text':
                    Animation(color=(0.6, 0.6, 1, 0.4) if self.disabled else (0.6, 0.6, 1, 1), duration=0.12).start(item)
                elif item.id == 'icon':
                    Animation(color=(0.6, 0.6, 1, 0) if self.disabled else (0.6, 0.6, 1, 1), duration=0.12).start(item)

            except AttributeError:
                pass

    def loading(self, boolean_value):
        self.on_leave()

        for child in self.parent.children:
            if child.id == "load_icon":
                self.disable(boolean_value)
                if boolean_value:
                    child.color = (0.6, 0.6, 1, 1)
                else:
                    child.color = (0.6, 0.6, 1, 0)
                break

    def update_next(self, boolean_value, message, *a):

        if message:
            for child in self.parent.parent.children:
                if "ServerVersionInput" in child.__class__.__name__:
                    child.focus = False
                    child.valid(boolean_value, message)

        self.disable(not boolean_value)

    def on_press(self):
        super().on_press()
        if self.click_func:
            self.click_func()
        for child in self.parent.parent.children:
            if "ServerVersionInput" in child.__class__.__name__:
                # Reset geyser_selected if version is less than 1.13.2
                if constants.version_check(child.text, "<", "1.13.2") or constants.new_server_info['type'] not in ['spigot', 'paper', 'purpur', 'fabric', 'quilt', 'neoforge']:
                    constants.new_server_info['server_settings']['geyser_support'] = False

                # Reset gamerule settings if version is less than 1.4.2
                if constants.version_check(child.text, "<", "1.4.2"):
                    constants.new_server_info['server_settings']['keep_inventory'] = False
                    constants.new_server_info['server_settings']['daylight_weather_cycle'] = True
                    constants.new_server_info['server_settings']['command_blocks'] = False
                    constants.new_server_info['server_settings']['random_tick_speed'] = "3"

                # Reset level_type if level type not supported
                if constants.version_check(child.text, "<", "1.1"):
                    constants.new_server_info['server_settings']['level_type'] = "default"
                elif constants.version_check(child.text, "<", "1.3.1") and constants.new_server_info['server_settings']['level_type'] not in ['default', 'flat']:
                    constants.new_server_info['server_settings']['level_type'] = "default"
                elif constants.version_check(child.text, "<", "1.7.2") and constants.new_server_info['server_settings']['level_type'] not in ['default', 'flat', 'large_biomes']:
                    constants.new_server_info['server_settings']['level_type'] = "default"

                # Disable chat reporting
                if constants.version_check(child.text, "<", "1.19") or constants.new_server_info['type'] == "vanilla":
                    constants.new_server_info['server_settings']['disable_chat_reporting'] = False
                else:
                    constants.new_server_info['server_settings']['disable_chat_reporting'] = True

                # Check for potential world incompatibilities
                if constants.new_server_info['server_settings']['world'] != "world":
                    check_world = constants.check_world_version(constants.new_server_info['server_settings']['world'], constants.new_server_info['version'])
                    if not check_world[0] and check_world[1]:
                        constants.new_server_info['server_settings']['world'] = "world"

                child.valid_text(True, True)

            if "Input" in child.__class__.__name__:
                child.focus = False
def next_button(name, position, disabled=False, next_screen="MainMenuScreen", show_load_icon=False, click_func=None):

    final = FloatLayout()

    button = NextButton(disabled=disabled)
    button.id = 'next_button'
    button.color_id = [(0.05, 0.05, 0.1, 1), (0.6, 0.6, 1, 1)]

    button.click_func = click_func
    button.size_hint = (None, None)
    button.size = (dp(240), dp(67))
    button.pos_hint = {"center_x": position[0], "center_y": position[1]}
    button.border = (-25, -25, -25, -25)
    button.background_normal = os.path.join(constants.gui_assets, 'next_button.png')
    button.background_down = os.path.join(constants.gui_assets, 'next_button_click.png')
    button.background_disabled_normal = os.path.join(constants.gui_assets, 'next_button_disabled.png')
    button.background_disabled_down = os.path.join(constants.gui_assets, 'next_button_disabled.png')

    text = Label()
    text.id = 'text'
    text.size_hint = (None, None)
    text.pos_hint = {"center_x": position[0], "center_y": position[1]}
    text.text = name.upper()
    text.font_size = sp(19)
    text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["bold"]}.ttf')
    text.color = (0.6, 0.6, 1, 0.4) if disabled else (0.6, 0.6, 1, 1)

    # Button click behavior
    if not click_func:
        button.on_release = functools.partial(button_action, name, button, next_screen)

    icon = Image()
    icon.id = 'icon'
    icon.source = icon_path('arrow-forward-circle-outline.png')
    icon.size = (dp(1), dp(1))
    icon.color = (0.6, 0.6, 1, 0) if disabled else (0.6, 0.6, 1, 1)
    icon.pos_hint = {"center_y": position[1]}
    icon.pos = (-90, 200)

    if show_load_icon:
        load_icon = AsyncImage()
        load_icon.id = 'load_icon'
        load_icon.source = os.path.join(constants.gui_assets, 'animations', 'loading_pickaxe.gif')
        load_icon.size_hint_max_y = 40
        load_icon.color = (0.6, 0.6, 1, 0)
        load_icon.pos_hint = {"center_y": position[1]}
        load_icon.pos = (-87, 200)
        load_icon.allow_stretch = True
        load_icon.anim_delay = constants.anim_speed * 0.02
        final.add_widget(load_icon)

    final.add_widget(button)
    final.add_widget(icon)

    final.add_widget(text)

    return final


class HeaderText(FloatLayout):

    def __init__(self, display_text, more_text, position, fixed_x=False, no_line=False, __translate__ = (True, True), **kwargs):
        super().__init__(**kwargs)

        self.text = Label()
        self.text.__translate__ = __translate__[0]
        self.text.id = 'text'
        self.text.size_hint = (None, None)
        self.text.markup = True
        if not fixed_x:
            self.text.pos_hint = {"center_x": 0.5, "center_y": position[1]}
        else:
            self.text.pos_hint = {"center_y": position[1]}
        self.text.text = display_text
        self.text.font_size = sp(23)
        self.text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
        self.text.color = (0.6, 0.6, 1, 1)

        self.lower_text = Label()
        self.lower_text.__translate__ = __translate__[1]
        self.lower_text.id = 'lower_text'
        self.lower_text.size_hint = (None, None)
        self.lower_text.markup = True
        self.lower_text.pos_hint = {"center_x": 0.5, "center_y": position[1] - 0.07}
        self.lower_text.text = more_text
        self.lower_text.font_size = sp(19)
        self.lower_text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
        self.lower_text.color = (0.6, 0.6, 1, 0.6)

        self.separator = Label(pos_hint={"center_y": position[1] - 0.025}, color=(0.6, 0.6, 1, 0.1), font_name=os.path.join(constants.gui_assets, 'fonts', 'LLBI.otf'), font_size=sp(25))
        self.separator.__translate__ = False
        self.separator.text = "_" * 48
        self.separator.id = 'separator'
        if not no_line:
            self.add_widget(self.separator)
        self.add_widget(self.text)

        if self.lower_text:
            self.add_widget(self.lower_text)



def input_button(name, position, file=(), input_name=None, title=None, ext_list=[], offset=0):

    final = FloatLayout()
    final.x += (190 + offset)

    button = HoverButton()
    button.id = 'input_button'
    button.color_id = [(0.05, 0.05, 0.1, 1), (0.6, 0.6, 1, 1)]

    button.size_hint_max = (151, 58)
    button.pos_hint = {"center_x": position[0], "center_y": position[1]}
    button.border = (0, 0, 0, 0)
    button.background_normal = os.path.join(constants.gui_assets, 'input_button.png')
    button.background_down = os.path.join(constants.gui_assets, 'input_button_click.png')

    text = Label()
    text.id = 'text'
    text.size_hint = (None, None)
    text.pos_hint = {"center_x": position[0], "center_y": position[1]}
    text.text = name.upper()
    text.font_size = sp(17)
    text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["bold"]}.ttf')
    text.color = (0.6, 0.6, 1, 1)

    # Button click behavior
    if file:
        button.on_release = functools.partial(file_popup, file[0], file[1], ext_list, input_name, title=title)
    else:
        button.on_release = functools.partial(button_action, name, button)

    final.add_widget(button)
    final.add_widget(text)

    return final


# Facing: left, right, center
class DropButton(FloatLayout):

    def __init__(self, name, position, options_list, input_name=None, x_offset=0, facing='left', custom_func=None, change_text=True, **kwargs):
        super().__init__(**kwargs)

        self.text_padding = 5
        self.facing = facing
        self.options_list = options_list

        self.x += 133 + x_offset

        self.button = HoverButton()
        self.id = self.button.id = 'drop_button' if facing == 'center' else f'drop_button_{self.facing}'
        self.button.color_id = [(0.05, 0.05, 0.1, 1), (0.6, 0.6, 1, 1)]

        self.button.size_hint_max = (182, 58)
        self.button.pos_hint = {"center_x": position[0], "center_y": position[1]}
        self.button.border = (0, 0, 0, 0)
        self.button.background_normal = os.path.join(constants.gui_assets, f'{self.id}.png')
        self.button.background_down = os.path.join(constants.gui_assets, f'{self.id}_click.png')

        # Change background when expanded - A
        def toggle_background(boolean, *args):

            self.button.ignore_hover = boolean

            for child in self.button.parent.children:
                if child.id == 'icon':
                    Animation(height=-abs(child.init_height) if boolean else abs(child.init_height), duration=0.15).start(child)

            if boolean:
                Animation(opacity=1, duration=0.13).start(self.dropdown)
                self.button.background_normal = os.path.join(constants.gui_assets, f'{self.id}_expand.png')
            else:
                self.button.on_mouse_pos(None, Window.mouse_pos)
                if self.button.hovered:
                    self.button.on_enter()
                else:
                    self.button.on_leave()

        self.text = Label()
        self.text.id = 'text'
        self.text.size_hint = (None, None)
        self.text.pos_hint = {"center_x": position[0], "center_y": position[1]}
        self.text.text = name.upper() + (" " * self.text_padding)
        self.text.font_size = sp(17)
        self.text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["bold"]}.ttf')
        self.text.color = (0.6, 0.6, 1, 1)


        # Dropdown list
        class FadeDrop(DropDown):
            def dismiss(self, *largs):
                Animation(opacity=0, duration=0.13).start(self)
                super().dismiss(self, *largs)
                Clock.schedule_once(functools.partial(self.deselect_buttons), 0.15)

            def deselect_buttons(self, *args):
                for child in self.children:
                    for child_item in child.children:
                        for child_button in child_item.children:
                            if "button" in child_button.id:
                                child_button.on_leave()

        self.dropdown = FadeDrop()
        self.dropdown.id = 'dropdown'
        self.dropdown.opacity = 0
        self.dropdown.min_state_time = 0.13

        for item in self.options_list:

            # Middle of the list
            if item != self.options_list[-1]:
                mid_btn = self.list_button(item, sub_id='list_mid_button')
                self.dropdown.add_widget(mid_btn)

            # Last button
            else:
                end_btn = self.list_button(item, sub_id='list_end_button')
                self.dropdown.add_widget(end_btn)

        # Button click behavior
        def set_var(var, result):

            # Gamemode drop-down
            if var == 'ServerModeInput':
                constants.new_server_info['server_settings']['gamemode'] = result
            elif var == 'ServerDiffInput':
                constants.new_server_info['server_settings']['difficulty'] = result
            elif var == 'ServerLevelTypeInput':
                result = result.replace("normal", "default").replace("superflat", "flat").replace("large biomes", "large_biomes")
                constants.new_server_info['server_settings']['level_type'] = result


        self.button.on_release = functools.partial(lambda: self.dropdown.open(self.button))

        if change_text:
            self.dropdown.bind(on_select=lambda instance, x: setattr(self.text, 'text', x.upper() + (" " * self.text_padding)))

        if custom_func:
            self.dropdown.bind(on_select=lambda instance, x: custom_func(x))
        else:
            self.dropdown.bind(on_select=lambda instance, x: set_var(input_name, x))

        # Change background when expanded - B
        self.button.bind(on_release=functools.partial(toggle_background, True))
        self.dropdown.bind(on_dismiss=functools.partial(toggle_background, False))


        self.add_widget(self.button)
        self.add_widget(self.text)

        # dropdown arrow
        self.icon = Image()
        self.icon.id = 'icon'
        self.icon.source = os.path.join(constants.gui_assets, 'drop_arrow.png')
        self.icon.init_height = 14
        self.icon.size = (14, self.icon.init_height)
        self.icon.allow_stretch = True
        self.icon.keep_ratio = True
        self.icon.size_hint_y = None
        self.icon.color = (0.6, 0.6, 1, 1)
        self.icon.pos_hint = {"center_y": position[1]}
        self.icon.pos = (195 + x_offset, 200)

        self.add_widget(self.icon)

    def change_text(self, text, translate=True):
        self.text.__translate__ = translate
        self.text.text = text.upper() + (" " * self.text_padding)

    # Create button in drop-down list
    def list_button(self, sub_name, sub_id, translate=True):

        sub_final = AnchorLayout()
        sub_final.id = sub_name
        sub_final.size_hint_y = None
        sub_final.height = 42 if "mid" in sub_id else 46

        sub_button = HoverButton()
        sub_button.id = sub_id
        sub_button.color_id = [(0.05, 0.05, 0.1, 1), (0.6, 0.6, 1, 1)]

        sub_button.border = (0, 0, 0, 0)
        sub_button.background_normal = os.path.join(constants.gui_assets, f'{sub_id}.png')
        sub_button.background_down = os.path.join(constants.gui_assets, f'{sub_id}_click.png')

        sub_text = Label()
        sub_text.__translate__ = translate
        sub_text.id = 'text'
        sub_text.text = sub_name
        sub_text.font_size = sp(19)
        sub_text.padding_y = 100
        sub_text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
        sub_text.color = (0.6, 0.6, 1, 1)

        sub_button.bind(on_release=lambda btn: self.dropdown.select(sub_name))

        sub_final.add_widget(sub_button)
        sub_final.add_widget(sub_text)

        return sub_final

    # Update list options
    def change_options(self, options_list):
        self.options_list = options_list
        self.dropdown.clear_widgets()

        for item in self.options_list:

            # Middle of the list
            if item != self.options_list[-1]:
                mid_btn = self.list_button(item, sub_id='list_mid_button')
                self.dropdown.add_widget(mid_btn)

            # Last button
            else:
                end_btn = self.list_button(item, sub_id='list_end_button')
                self.dropdown.add_widget(end_btn)

# Figure out where self.change_text is called, and add telepath icon to label
class TelepathDropButton(DropButton):
    def __init__(self, type, position, x_offset=0, facing='center', *args, **kwargs):
        FloatLayout.__init__(self, *args, **kwargs)
        telepath_data = constants.server_manager.online_telepath_servers

        if type == 'create':
            name = 'create a server on'
        elif type == 'install':
            name = 'install server on'
        elif type == 'clone':
            name = 'clone server to'
        else:
            name = 'import server to'

        # Side label
        self.label_layout = RelativeLayout(pos_hint={"center_x": 0.5, "center_y": position[1]})
        self.label_layout.size_hint_max = (400, 40)
        self.label_layout.id = 'relative_layout'
        self.label = AlignLabel()
        self.label.halign = 'right'
        self.label.valign = 'center'
        self.label.id = 'label'
        self.label.size_hint_max = (300, 50)
        self.label.text = name
        self.label.x -= 210
        self.label.y += 2
        self.label.font_size = sp(25)
        self.label.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
        self.label.color = (0.6, 0.6, 1, 1)
        self.label_layout.add_widget(self.label)

        self.label_icon = Image(source=icon_path('telepath.png'))
        self.label_icon.size_hint_max = (35, 35)
        self.label_icon.allow_stretch = True
        self.label_icon.keep_ratio = False
        self.label_icon.pos = (self.label.x + 20, self.label.y + 3)
        self.color_id = [(0.2, 0.2, 0.4, 1), (0.65, 0.65, 1, 1)]
        self.label_icon.color = self.color_id[0]
        self.label_layout.add_widget(self.label_icon)
        self.add_widget(self.label_layout)

        self.text_padding = 5
        self.facing = facing

        self.options_list = {'this machine': None}
        self.options_list.update(constants.deepcopy(telepath_data))

        self.x += 152 + x_offset

        self.button = HoverButton()
        self.id = self.button.id = 'drop_button' if facing == 'center' else f'drop_button_{self.facing}'
        self.button.color_id = [(0.05, 0.05, 0.1, 1), (0.6, 0.6, 1, 1)]

        self.button.size_hint_max = (200, 65)
        self.button.pos_hint = {"center_x": position[0], "center_y": position[1]}
        self.button.border = (0, 0, 0, 0)
        self.button.background_normal = os.path.join(constants.gui_assets, f'{self.id}.png')
        self.button.background_down = os.path.join(constants.gui_assets, f'{self.id}_click.png')

        # Change background when expanded - A
        def toggle_background(boolean, *args):

            self.button.ignore_hover = boolean

            for child in self.button.parent.children:
                if child.id == 'icon':
                    Animation(height=-abs(child.init_height) if boolean else abs(child.init_height), duration=0.15).start(child)

            if boolean:
                Animation(opacity=1, duration=0.13).start(self.dropdown)
                self.button.background_normal = os.path.join(constants.gui_assets, f'{self.id}_expand.png')
            else:
                self.button.on_mouse_pos(None, Window.mouse_pos)
                if self.button.hovered:
                    self.button.on_enter()
                else:
                    self.button.on_leave()

        self.text = Label()
        self.text.id = 'text'
        self.text.size_hint = (None, None)
        self.text.pos_hint = {"center_x": position[0], "center_y": position[1]}
        self.text.text = 'THIS MACHINE' + (" " * self.text_padding)
        self.text.font_size = sp(17)
        self.text.shorten = True
        self.text.shorten_from = 'right'
        self.text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["bold"]}.ttf')
        self.text.color = (0.6, 0.6, 1, 1)

        # Dropdown list
        class FadeDrop(DropDown):
            def dismiss(self, *largs):
                Animation(opacity=0, duration=0.13).start(self)
                super().dismiss(self, *largs)
                Clock.schedule_once(functools.partial(self.deselect_buttons), 0.15)

            def deselect_buttons(self, *args):
                for child in self.children:
                    for child_item in child.children:
                        for child_button in child_item.children:
                            if "button" in child_button.id:
                                child_button.on_leave()

        self.dropdown = FadeDrop()
        self.dropdown.id = 'dropdown'
        self.dropdown.opacity = 0
        self.dropdown.min_state_time = 0.13

        for item, telepath_data in self.options_list.items():
            original_item = item

            # Set display name
            if telepath_data:
                telepath_data['host'] = item
                if telepath_data['nickname']:
                    item = telepath_data['nickname']

            # Middle of the list
            if original_item != list(self.options_list.keys())[-1]:
                mid_btn = self.list_button(item, sub_id='list_mid_button', translate=(original_item=='this machine'))
                self.dropdown.add_widget(mid_btn)

            # Last button
            else:
                end_btn = self.list_button(item, sub_id='list_end_button')
                self.dropdown.add_widget(end_btn)

        # Button click behavior
        def set_var(parent, result):
            for k, v in self.options_list.items():
                if (k == 'this machine' == result) or (v and (('.' in result and result == k) or (result == v['nickname']))):
                    constants.new_server_info['_telepath_data'] = v
                    if type in ['import', 'clone']:
                        constants.import_data['_telepath_data'] = v

                    # Change icon color
                    Animation.stop_all(parent.label_icon)
                    Animation(color=parent.color_id[0 if result == 'this machine' else 1], duration=0.2).start(parent.label_icon)

                    # Update name list if creating a server
                    try:
                        screen_manager.current_screen.name_input.get_server_list()
                    except:
                        pass
                    try:
                        screen_manager.current_screen.name_input.update_server()
                    except:
                        pass

                    break

        self.button.on_release = functools.partial(lambda: self.dropdown.open(self.button))
        self.dropdown.bind(on_select=lambda instance, x: self.change_text(x, translate=(x=='this machine')))
        self.dropdown.bind(on_select=lambda instance, x: set_var(self, x))

        # Change background when expanded - B
        self.button.bind(on_release=functools.partial(toggle_background, True))
        self.dropdown.bind(on_dismiss=functools.partial(toggle_background, False))

        self.add_widget(self.button)
        self.add_widget(self.text)

        # dropdown arrow
        self.icon = Image()
        self.icon.id = 'icon'
        self.icon.source = os.path.join(constants.gui_assets, 'drop_arrow.png')
        self.icon.init_height = 14
        self.icon.size = (14, self.icon.init_height)
        self.icon.allow_stretch = True
        self.icon.keep_ratio = True
        self.icon.size_hint_y = None
        self.icon.color = (0.6, 0.6, 1, 1)
        self.icon.pos_hint = {"center_y": position[1]}
        self.icon.pos = (225 + x_offset, 200)

        self.add_widget(self.icon)


        if '_telepath_data' in constants.new_server_info and constants.new_server_info['_telepath_data']:
            self.label_icon.color = self.color_id[1]
            if constants.new_server_info['_telepath_data']['nickname']:
                name = constants.new_server_info['_telepath_data']['nickname']
            else:
                name = constants.new_server_info['_telepath_data']['host']
            self.text.text = name.upper() + (" " * self.text_padding)


# Similar to DropButton, but for a right-click context menu
# Options are assigned from children of the HoverButton class:
# self.context_options = [{'name': 'Test option', 'icon': 'test-icon.png', 'action': self.do_something}]
class ContextMenu(GridLayout):

    # Object for all children in layout
    class ListButton(RelativeLayout):

        def animate(self, fade_in=True, delay=0):

            def delay_anim(*a):
                Animation.stop_all(self.text)
                Animation.stop_all(self.icon)
                self.text.x = self.text_x
                self.icon.x = self.icon_x

                if fade_in:
                    self.text.x -= 15
                    self.icon.x -= 15
                    self.text.opacity = 0
                    self.icon.opacity = 0
                    Animation(opacity=1, x=self.text_x, duration=0.3, transition='out_sine').start(self.text)
                    Animation(opacity=1, x=self.icon_x, duration=0.3, transition='out_sine').start(self.icon)

                else:
                    Animation(opacity=0, duration=0.15).start(self.text)
                    Animation(opacity=0, x=self.icon_x-40, duration=0.15).start(self.icon)

            Clock.schedule_once(delay_anim, delay)

        def __init__(self, sub_data, sub_id, selected=False, **kw):
            super().__init__(**kw)

            self.id = sub_data['name']
            self.size_hint_y = None
            self.height = 42 if "mid" in sub_id else 46
            self.width = 200
            self.text_x = 0
            self.icon_x = 0
            self.selected = selected

            # Add button
            self.button = HoverButton()
            self.button.id = sub_id
            self.button.height = self.height

            if sub_id == 'list_red_button':
                self.button.color_id = [(0.1, 0.07, 0.07, 1), (1, 0.6, 0.7, 1)]
            elif self.selected:
                self.button.color_id = [(0.05, 0.05, 0.1, 1), (0.76, 0.76, 1, 1)]
                self.button.background_color = (0.7, 0.7, 0.7, 1)
            else:
                self.button.color_id = [(0.05, 0.05, 0.1, 1), (0.6, 0.6, 1, 1)]

            self.button.border = (0, 0, 0, 0)
            self.button.background_normal = os.path.join(constants.gui_assets, f'{sub_id}.png')
            self.button.background_down = os.path.join(constants.gui_assets, f'{sub_id}_click.png')

            # Add text
            self.text = Label()
            self.text.id = 'text'
            self.text.opacity = 0
            self.text.text = sub_data['name']
            self.text.font_size = sp(19)
            self.text.padding_y = 100
            self.text.halign = 'left'
            self.text.x = 15
            self.text_x = self.text.x
            self.text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
            self.text.color = self.button.color_id[1]
            def adjust_text(*a):
                self.text.text_size = (200, None)
                self.text.texture_update()
            Clock.schedule_once(adjust_text, 0)

            self.add_widget(self.button)
            self.add_widget(self.text)

            # Add icon (optional)
            self.icon = Image()
            if sub_data['icon']:
                self.icon.id = 'icon'
                self.icon.opacity = 0
                self.icon.source = icon_path(sub_data['icon'])
                self.icon.size_hint_max = (25, 25)
                self.icon.pos_hint = {'center_y': 0.5}
                self.icon.x = self.width - (self.icon.size_hint_max[0] * 1.5)
                self.icon_x = self.icon.x
                self.icon.allow_stretch = True
                self.icon.keep_ratio = False
                self.icon.color = self.button.color_id[1]

                self.add_widget(self.icon)

            # Action when clicked
            if sub_data['action']:
                self.button.bind(on_press=sub_data['action'])

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.id = 'context_menu'
        self.cols = 1
        self.spacing = (0, 0.01)
        self.options_list = None
        self.size_hint_max_x = 138
        self.opacity = 0
        self.visible = False
        self.rounded = False
        self.widget = None

    # Shows menu on the current screen
    def show(self, widget, options_list=None):
        self.widget = widget
        if options_list:
            self._change_options(options_list)
        self.visible = True

        def wait(*a):
            self._update_pos()
            Animation(opacity=1, size_hint_max_x=200, duration=0.13, transition='in_out_sine').start(self)
            for x, b in enumerate(reversed(self.children), 0):
                b.animate(True, (math.log(x + 1) / math.log(1.17)) / 70) # (len(options_list)*5)
        Clock.schedule_once(wait, 0)

    # Hides the menu, and deletes it from the current screen
    def hide(self, animate=True, *args):
        Clock.schedule_once(self.widget.on_leave, 0.05)

        def delete(*a):
            try:
                for widget in self.parent.children:
                    if "ContextMenu" in widget.__class__.__name__:
                        self.parent.context_menu = None
                        self.parent.remove_widget(widget)
            except AttributeError:
                if constants.debug:
                    print("Window ContextMenu Error: Failed to delete menu as the parent window doesn't exist")

        if animate:
            Animation(opacity=0, size_hint_max_x=150, duration=0.13, transition='in_out_sine').start(self)
            for b in self.children:
                b.animate(False)
            Clock.schedule_once(functools.partial(self._deselect_buttons), 0.14)
            Clock.schedule_once(delete, 0.141)
        else:
            delete()

    # Executes 'self.on_leave()' for all children
    def _deselect_buttons(self, *args):
        for child in self.children:
            child.button.on_leave()

    # Changes button textures when position is fixed on screen
    def _round_top_left(self, *a):
        b = self.children[-1]
        b.button.id = 'list_start_flip_button'
        b.button.background_down = os.path.join(constants.gui_assets, f'{b.button.id}_click.png')
        b.button.on_leave()

    # Moves menu to cursor, and prevents it from going off-screen
    def _update_pos(self):

        # Set initial position
        pos = Window.mouse_pos
        self.x = pos[0]
        self.y = pos[1] - self.height

        # Check if the menu goes off-screen
        off_y = pos[1] - self.minimum_height
        if off_y <= 0:
            self.y -= off_y
            Clock.schedule_once(self._round_top_left, 0)

        off_x = pos[0] + self.width
        if off_x >= Window.width:
            self.x -= (off_x - Window.width)
            Clock.schedule_once(self._round_top_left, 0)

    # Update list options with 'options_list'
    def _change_options(self, options_list):
        self.options_list = options_list
        self.clear_widgets()

        for item in self.options_list:
            if not item:
                continue

            # Start of the list
            if item == self.options_list[0]:
                start_btn = self.ListButton(item, sub_id='list_start_button')
                self.add_widget(start_btn)

            # Middle of the list
            elif item != self.options_list[-1]:
                mid_btn = self.ListButton(item, sub_id='list_mid_button')
                self.add_widget(mid_btn)

            # Last button
            else:
                if 'color' in item:
                    sub_id = f'list_{item["color"]}_button'
                else:
                    sub_id = 'list_end_button'
                end_btn = self.ListButton(item, sub_id=sub_id)
                self.add_widget(end_btn)

    # Modifies global click behavior when the menu is visible
    def on_touch_down(self, touch):

        if self.visible:

            # Hide menu on any touch that isn't right
            if touch.button != 'right':
                self.hide()
                self.visible = False

            # Ignore touch unless it's right, or clicked on any children
            if touch.button == 'right' or any([b.button.hovered for b in self.children]):
                return super().on_touch_down(touch)

            return True

        # Ignore if the menu isn't visible
        else:
            return super().on_touch_down(touch)



def toggle_button(name, position, default_state=True, x_offset=0, custom_func=None, disabled=False):

    knob_limits = (156.4 + x_offset, 193 + x_offset) # (Left, Right) (156.7 on left, 191 on right with border)
    bgc = constants.background_color
    color_id = [(bgc[0] - 0.021, bgc[1] - 0.021, bgc[2] - 0.021, bgc[3]), (0.6, 0.6, 1, 1)]

    # When switch is toggled
    def on_active(button_name, *args):
        if disabled:
            return

        # Log for crash info
        try:
            interaction = "ToggleButton"
            if name:
                interaction += f" ({name})"
            constants.last_widget = interaction + f" @ {constants.format_now()}"
        except:
            pass

        state = args[0].state == "down"

        for child in args[0].parent.children:
            if child.id == "knob":
                Animation(x=knob_limits[1] if state else knob_limits[0], color=color_id[0] if state else color_id[1], duration=0.12).start(child)
                child.source = os.path.join(constants.gui_assets, f'toggle_button_knob{"_enabled" if state else ""}.png')

        if custom_func:
            custom_func(state)

        # Change settings of ID
        elif button_name == "geyser_support":
            constants.new_server_info['server_settings']['geyser_support'] = state
        elif button_name == 'chat_report':
            constants.new_server_info['server_settings']['disable_chat_reporting'] = state
        elif button_name == "pvp":
            constants.new_server_info['server_settings']['pvp'] = state
        elif button_name == "spawn_protection":
            constants.new_server_info['server_settings']['spawn_protection'] = state
        elif button_name == "keep_inventory":
            constants.new_server_info['server_settings']['keep_inventory'] = state
        elif button_name == "daylight_weather_cycle":
            constants.new_server_info['server_settings']['daylight_weather_cycle'] = state
        elif button_name == "spawn_creatures":
            constants.new_server_info['server_settings']['spawn_creatures'] = state
        elif button_name == "command_blocks":
            constants.new_server_info['server_settings']['command_blocks'] = state


    final = FloatLayout()
    final.x += 174 + x_offset

    final.button = button = ToggleButton(state='down' if default_state else 'normal')
    button.id = 'toggle_button'
    button.pos_hint = {"center_x": position[0], "center_y": position[1]}
    button.size_hint_max = (82, 42)
    button.border = (0, 0, 0, 0)
    button.background_normal = os.path.join(constants.gui_assets, 'toggle_button.png')
    button.background_down = button.background_normal if disabled else os.path.join(constants.gui_assets, 'toggle_button_enabled.png')
    button.bind(on_press=functools.partial(on_active, name))

    final.knob = knob = Image()
    knob.id = 'knob'
    knob.source = os.path.join(constants.gui_assets, f'toggle_button_knob{"_enabled" if default_state else ""}.png')
    knob.size = (30, 30)
    knob.pos_hint = {"center_y": position[1]}
    knob.x = knob_limits[1] if default_state else knob_limits[0]
    knob.color = color_id[0] if default_state else color_id[1]

    if disabled:
        final.opacity = 0.4

    final.add_widget(button)
    final.add_widget(knob)
    return final


class NumberSlider(FloatLayout):

    def on_value(self, *args):
        spos = self.slider.value_pos
        lpos = self.label.size_hint_max
        self.label.pos = (spos[0] - (lpos[0]/2) + 0.7, spos[1] + lpos[1] + 1)

        if self.max_icon or self.min_icon:
            ipos = self.icon_widget.size_hint_max
            self.icon_widget.pos = (spos[0] - (ipos[0] / 2), spos[1] + ipos[1])

        self.slider_val = self.slider.value.__floor__()
        self.label.text = str(self.slider_val)


        if (self.slider_val != self.last_val) or self.init:

            # Show self.icon_widget if maximum or minimum value
            if self.max_icon:
                if (self.slider_val == self.slider.range[1]):
                    self.label.opacity = 0
                    self.icon_widget.opacity = 1
                else:
                    self.label.opacity = 1
                    self.icon_widget.opacity = 0
            elif self.min_icon:
                if (self.slider_val == self.slider.range[0]):
                    self.label.opacity = 0
                    self.icon_widget.opacity = 1
                else:
                    self.label.opacity = 1
                    self.icon_widget.opacity = 0


        self.last_val = self.slider_val
        self.init = False

    def __init__(self, default_value, position, input_name, limits=(0, 100), max_icon=None, min_icon=None, function=None, **kwargs):
        super().__init__(**kwargs)

        self.x += 125
        self.function = function
        self.last_val = default_value
        self.slider_val = default_value
        self.init = True
        self.max_icon = max_icon
        self.min_icon = min_icon

        # Main slider widget
        self.slider = Slider(value=default_value, value_track=True, range=limits)
        self.slider.background_width = 12
        self.slider.border_horizontal = [6, 6, 6, 6]
        self.slider.value_track_width = 5
        self.slider.value_track_color = (0.6, 0.6, 1, 1)
        self.slider.cursor_size = (42, 42)
        self.slider.cursor_image = os.path.join(constants.gui_assets, 'slider_knob.png')
        self.slider.background_horizontal = os.path.join(constants.gui_assets, 'slider_rail.png')
        self.slider.size_hint_max_x = 205
        self.slider.pos_hint = {'center_x': 0.5, 'center_y': 0.5}
        self.slider.padding = 30
        self.add_widget(self.slider)

        # Kivy spams this function 3 times because it can't return the touch properly
        def on_touch_up(touch):

            # Execute function with value if it's added
            if self.function and not self.init and touch.button == 'left' and self.slider.parent.collide_point(*touch.pos):
                self.function(self.slider_val)

                # Log for crash info
                try:
                    interaction = "NumberSlider"
                    if input_name:
                        interaction += f" ({input_name})"
                    constants.last_widget = interaction + f" @ {constants.format_now()}"
                except:
                    pass

            return super(type(self.slider), self.slider).on_touch_up(touch)

        self.slider.on_touch_up = on_touch_up

        # Number label
        self.label = AlignLabel()
        self.label.text = str(default_value)
        self.label.halign = "center"
        self.label.valign = "center"
        self.label.size_hint_max = (30, 28)
        self.label.color = (0.15, 0.15, 0.3, 1)
        self.label.font_size = sp(20)
        self.label.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["very-bold"]}.ttf')
        self.add_widget(self.label)

        # Infinity label
        if self.max_icon or self.min_icon:
            self.icon_widget = Image()
            self.icon_widget.size_hint_max = (28, 28)
            self.icon_widget.color = (0.15, 0.15, 0.3, 1)
            self.icon_widget.source = os.path.join(constants.gui_assets, 'icons', self.max_icon if self.max_icon else self.min_icon)
            self.icon_widget.opacity = 0
            self.add_widget(self.icon_widget)
        

        # Bind to number change
        self.slider.bind(value=self.on_value, pos=self.on_value)
        Clock.schedule_once(self.on_value, 0)


# ---------------------------------------------------- Screens ---------------------------------------------------------

# Popup widgets
popup_blur_amount = 7       # 0-10 int:   Higher is blurrier  (originally 5)
popup_blur_darkness = 0.9   # 0-1 float:  Lower is darker
class PopupWindow(RelativeLayout):

    def generate_blur_background(self, *args):
        image_path = os.path.join(constants.gui_assets, 'live', 'blur_background.png')
        try:
            constants.folder_check(os.path.join(constants.gui_assets, 'live'))
        except:
            self.blur_background.color = constants.background_color
            return

        # Prevent this from running every resize
        def reset_activity(*args):
            self.generating_background = False

        if not self.generating_background:
            self.generating_background = True

            if self.shown:
                for widget in self.window.children:
                    widget.opacity = 0
                self.blur_background.opacity = 0

            screen_manager.current_screen.export_to_png(image_path)
            im = PILImage.open(image_path)
            im = ImageEnhance.Brightness(im)
            im = im.enhance(popup_blur_darkness)
            im1 = im.filter(GaussianBlur(popup_blur_amount))
            im1.save(image_path)
            self.blur_background.reload()

            if self.shown:
                for widget in self.window.children:
                    widget.opacity = 1
                self.blur_background.opacity = 1

            self.resize_window()
            Clock.schedule_once(reset_activity, 0.5)

    # Annoying hack to fix canvas lag
    def resize_window(*args):
        Window.on_resize(*Window.size)


    def click_event(self, *args):

        button_pressed = 'ignore'
        try:
            button_pressed = args[1].button
        except:
            pass

        if not self.clicked and button_pressed in ('left', 'ignore'):

            if isinstance(args[1], str):
                force_button = args[1]
                rel_coord = (0, Window.height)
            else:
                force_button = None
                rel_coord = (args[1].pos[0] - self.x - self.window.x, args[1].pos[1] - self.y - self.window.y)

            rel_color = self.window_background.color

            # Single, wide button
            if self.ok_button:
                if (force_button in ('ok', 'yes')) or (not force_button and (rel_coord[0] < self.ok_button.width and rel_coord[1] < self.ok_button.height)):
                    self.ok_button.background_color = tuple([px + 0.12 if px < 0.88 else px for px in rel_color])
                    self.resize_window()

                    if self.callback:
                        self.callback()
                        self.clicked = True

                    Clock.schedule_once(functools.partial(self.self_destruct, True), 0.1)


            elif self.no_button and self.yes_button:

                # Right button
                if force_button == 'yes' or (not force_button and (rel_coord[0] > self.no_button.width + 5 and rel_coord[1] < self.yes_button.height)):
                    self.yes_button.background_color = tuple([px + 0.12 if px < 0.88 else px for px in rel_color])
                    self.resize_window()

                    if self.callback:
                        callback = self.callback[1]
                        if callback:
                            callback()
                            self.clicked = True

                    Clock.schedule_once(functools.partial(self.self_destruct, True), 0.1)

                # Left button
                elif force_button == 'no' or (not force_button and (rel_coord[0] < self.no_button.width - 5 and rel_coord[1] < self.no_button.height)):
                    self.no_button.background_color = tuple([px + 0.12 if px < 0.88 else px for px in rel_color])
                    self.resize_window()

                    if self.callback:
                        callback = self.callback[0]
                        if callback:
                            callback()
                            self.clicked = True

                    Clock.schedule_once(functools.partial(self.self_destruct, True), 0.1)


    def resize(self):
        self.window.size = self.window_background.size
        self.window.pos = (Window.size[0]/2 - self.window_background.width/2, Window.size[1]/2 - self.window_background.height/2)
        if self.shown:
            Clock.schedule_once(self.generate_blur_background, 0.1)


    def animate(self, show=True, *args):
        window_func = functools.partial(self.resize_window)
        Clock.schedule_interval(window_func, 0.015)

        def is_shown(*args):
            self.shown = True

        if show:
            for widget in self.window.children:
                original_size = (widget.width, widget.height)
                widget.size = (original_size[0] * 0.8, original_size[1] * 0.8)
                anim = Animation(size=original_size, duration=0.05)
                anim &= Animation(opacity=1, duration=0.25)
                anim.start(widget)
            Animation(opacity=1, duration=0.25).start(self.blur_background)
            Clock.schedule_once(functools.partial(is_shown), 0.5)
        else:
            for widget in self.window.children:
                if "button" in widget.id:
                    widget.opacity = 0

            image_path = os.path.join(constants.gui_assets, 'live', 'popup.png')
            self.window.export_to_png(image_path)

            for widget in self.window.children:
                if widget != self.window_background and "button" not in widget.id:
                    widget.opacity = 0
                else:
                    if widget == self.window_background:
                        widget.color = (1,1,1,1)
                        widget.source = image_path
                        widget.reload()
                    original_size = (widget.width, widget.height)
                    new_size = (original_size[0] * 0.85, original_size[1] * 0.85)
                    anim = Animation(size=new_size, duration=0.08)
                    anim &= Animation(opacity=0, duration=0.25)

                    if "ok_button" in widget.id:
                        widget.opacity = 1
                        original_pos = (widget.pos[0], widget.pos[1] + 28)
                        anim &= Animation(font_size=widget.font_size-3.5, pos=original_pos, duration=0.08)

                    elif "button" in widget.id:
                        widget.opacity = 1
                        original_pos = (widget.pos[0] + (-34.25 if "yes" in widget.id else +34.25 if "no" in widget.id else 0), widget.pos[1] + 28)
                        anim &= Animation(font_size=widget.font_size-3.5, pos=original_pos, duration=0.08)

                    anim.start(widget)

            Animation(opacity=0, duration=0.28).start(self.blur_background)

        Clock.schedule_once(functools.partial(Clock.unschedule, window_func), 0.35)


    # Delete popup bind
    def self_destruct(self, animate, *args):

        if not self.shown:
            return

        def delete(*args):

            try:
                for widget in self.parent.children:
                    if "Popup" in widget.__class__.__name__:
                        self.parent.popup_widget = None
                        self.parent.canvas.after.clear()
                        self.parent.remove_widget(widget)
                        self.canvas.after.clear()
            except AttributeError:
                if constants.debug:
                    print("Window Popup Error: Failed to delete popup as the parent window doesn't exist")

        if animate:
            self.animate(False)
            Clock.schedule_once(delete, 0.4)
        else:
            delete()


    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # Popup window layout
        self.window = RelativeLayout()
        self.callback = None
        self.window_sound = None
        self.shown = False
        self.clicked = False

        with self.canvas.after:
            # Blurred background
            self.blur_background = Image()
            self.blur_background.opacity = 0
            self.blur_background.id = "blur_background"
            self.blur_background.source = os.path.join(constants.gui_assets, 'live', 'blur_background.png')
            self.blur_background.allow_stretch = True
            self.blur_background.keep_ratio = False
            self.generating_background = False


            # Popup window background
            self.window_background = Image(source=os.path.join(constants.gui_assets, "popup_background.png"))
            self.window_background.id = "window_background"
            self.window_background.size_hint = (None, None)
            self.window_background.allow_stretch = True
            self.window_background.keep_ratio = False
            self.window_background.color = self.window_color
            self.window_background.size = (460, 360)
            self.window_background.pos_hint = {"center_x": 0.5, "center_y": 0.5}


            # Popup window title
            self.window_icon = Image(source=self.window_icon_path)
            self.window_icon.id = "window_icon"
            self.window_icon.size_hint = (None, None)
            self.window_icon.allow_stretch = True
            self.window_icon.color = self.window_text_color
            self.window_icon.size = (36, 36)
            self.window_icon.pos = (self.window.x + 13, self.window.y + self.window_background.height - 48)

            self.window_title = Label()
            self.window_title.id = "window_title"
            self.window_title.color = self.window_text_color
            self.window_title.font_size = sp(25)
            self.window_title.y = (self.window_background.height / 3 + 30)
            self.window_title.pos_hint = {"center_x": 0.5}
            self.window_title.font_name = os.path.join(constants.gui_assets,'fonts',f'{constants.fonts["italic"]}.ttf')
            self.window_title.text_size[0] = (self.window_background.size[0] * 0.7)
            self.window_title.halign = "center"
            self.window_title.shorten = True
            self.window_title.markup = True
            self.window_title.shorten_from = "right"


            # Popup window content
            self.window_content = Label()
            self.window_content.id = "window_content"
            self.window_content.color = tuple([px * 1.5 if px < 1 else px for px in self.window_text_color])
            self.window_content.font_size = sp(23)
            self.window_content.line_height = 1.15
            self.window_content.halign = "center"
            self.window_content.valign = "center"
            self.window_content.text_size = (self.window_background.width - 40, self.window_background.height - 25)
            self.window_content.pos_hint = {"center_x": 0.5, "center_y": 0.52}
            self.window_content.font_name = os.path.join(constants.gui_assets,'fonts',f'{constants.fonts["bold"]}.ttf')


        self.add_widget(self.blur_background)
        self.window.add_widget(self.window_background)
        self.window.add_widget(self.window_icon)
        self.window.add_widget(self.window_title)
        self.window.add_widget(self.window_content)

# Normal info
class PopupInfo(PopupWindow):
    def __init__(self, **kwargs):
        self.window_color = (0.42, 0.475, 1, 1)
        self.window_text_color = (0.1, 0.1, 0.2, 1)
        self.window_icon_path = os.path.join(constants.gui_assets, 'icons', 'information-circle.png')
        super().__init__(**kwargs)

        # Modal specific settings
        self.window_sound = sa.WaveObject.from_wave_file(os.path.join(constants.gui_assets, 'sounds', 'popup_normal.wav'))
        self.no_button = None
        self.yes_button = None
        with self.canvas.after:
            self.ok_button = Button()
            self.ok_button.id = "ok_button"
            self.ok_button.size_hint = (None, None)
            self.ok_button.size = (459, 65)
            self.ok_button.border = (0, 0, 0, 0)
            self.ok_button.background_color = self.window_color
            self.ok_button.background_normal = os.path.join(constants.gui_assets, "popup_full_button.png")
            self.ok_button.pos_hint = {"center_x": 0.5}
            self.ok_button.text = "OKAY"
            self.ok_button.color = self.window_text_color
            self.ok_button.font_name = os.path.join(constants.gui_assets,'fonts',f'{constants.fonts["very-bold"]}.ttf')
            self.ok_button.font_size = sp(22)
            self.bind(on_touch_down=self.click_event)

        self.window.add_widget(self.ok_button)
        self.canvas.after.clear()

        self.blur_background.opacity = 0
        for widget in self.window.children:
            widget.opacity = 0

# Warning
class PopupWarning(PopupWindow):
    def __init__(self, **kwargs):
        self.window_color = (1, 0.56, 0.6, 1)
        self.window_text_color = (0.2, 0.1, 0.1, 1)
        self.window_icon_path = os.path.join(constants.gui_assets, 'icons', 'alert-circle-sharp.png')
        super().__init__(**kwargs)

        # Modal specific settings
        self.window_sound = sa.WaveObject.from_wave_file(os.path.join(constants.gui_assets, 'sounds', 'popup_warning.wav'))
        self.no_button = None
        self.yes_button = None
        with self.canvas.after:
            self.ok_button = Button()
            self.ok_button.id = "ok_button"
            self.ok_button.size_hint = (None, None)
            self.ok_button.size = (459, 65)
            self.ok_button.border = (0, 0, 0, 0)
            self.ok_button.background_color = self.window_color
            self.ok_button.background_normal = os.path.join(constants.gui_assets, "popup_full_button.png")
            self.ok_button.pos_hint = {"center_x": 0.5}
            self.ok_button.text = "OKAY"
            self.ok_button.color = self.window_text_color
            self.ok_button.font_name = os.path.join(constants.gui_assets,'fonts',f'{constants.fonts["very-bold"]}.ttf')
            self.ok_button.font_size = sp(22)
            self.bind(on_touch_down=self.click_event)

        self.window.add_widget(self.ok_button)
        self.canvas.after.clear()

        self.blur_background.opacity = 0
        for widget in self.window.children:
            widget.opacity = 0

# Yes/No
class PopupQuery(PopupWindow):
    def __init__(self, **kwargs):
        self.window_color = (0.42, 0.475, 1, 1)
        self.window_text_color = (0.1, 0.1, 0.2, 1)
        self.window_icon_path = os.path.join(constants.gui_assets, 'icons', 'question-circle.png')
        super().__init__(**kwargs)

        # Modal specific settings
        self.window_sound = sa.WaveObject.from_wave_file(os.path.join(constants.gui_assets, 'sounds', 'popup_normal.wav'))
        self.ok_button = None
        with self.canvas.after:
            self.no_button = Button()
            self.no_button.id = "no_button"
            self.no_button.size_hint = (None, None)
            self.no_button.size = (229.5, 65)
            self.no_button.border = (0, 0, 0, 0)
            self.no_button.background_color = self.window_color
            self.no_button.background_normal = os.path.join(constants.gui_assets, "popup_half_button.png")
            self.no_button.pos = (0.5, -0.3)
            self.no_button.text = "NO"
            self.no_button.color = self.window_text_color
            self.no_button.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["very-bold"]}.ttf')
            self.no_button.font_size = sp(22)


            self.yes_button = Button()
            self.yes_button.id = "yes_button"
            self.yes_button.size_hint = (None, None)
            self.yes_button.size = (-229.5, 65)
            self.yes_button.border = (0, 0, 0, 0)
            self.yes_button.background_color = self.window_color
            self.yes_button.background_normal = os.path.join(constants.gui_assets, "popup_half_button.png")
            self.yes_button.pos = (self.window_background.size[0] - 0.5, -0.3)
            self.yes_button.text = "YES"
            self.yes_button.color = self.window_text_color
            self.yes_button.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["very-bold"]}.ttf')
            self.yes_button.font_size = sp(22)
            self.bind(on_touch_down=self.click_event)


        self.window.add_widget(self.no_button)
        self.window.add_widget(self.yes_button)
        self.canvas.after.clear()

        self.blur_background.opacity = 0
        for widget in self.window.children:
            widget.opacity = 0

# Yes/No
class PopupWarningQuery(PopupWindow):
    def __init__(self, **kwargs):
        self.window_color = (1, 0.56, 0.6, 1)
        self.window_text_color = (0.2, 0.1, 0.1, 1)
        self.window_icon_path = os.path.join(constants.gui_assets, 'icons', 'alert-circle-sharp.png')
        super().__init__(**kwargs)

        # Modal specific settings
        self.window_sound = sa.WaveObject.from_wave_file(os.path.join(constants.gui_assets, 'sounds', 'popup_warning.wav'))
        self.ok_button = None
        with self.canvas.after:
            self.no_button = Button()
            self.no_button.id = "no_button"
            self.no_button.size_hint = (None, None)
            self.no_button.size = (229.5, 65)
            self.no_button.border = (0, 0, 0, 0)
            self.no_button.background_color = self.window_color
            self.no_button.background_normal = os.path.join(constants.gui_assets, "popup_half_button.png")
            self.no_button.pos = (0.5, -0.3)
            self.no_button.text = "NO"
            self.no_button.color = self.window_text_color
            self.no_button.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["very-bold"]}.ttf')
            self.no_button.font_size = sp(22)


            self.yes_button = Button()
            self.yes_button.id = "yes_button"
            self.yes_button.size_hint = (None, None)
            self.yes_button.size = (-229.5, 65)
            self.yes_button.border = (0, 0, 0, 0)
            self.yes_button.background_color = self.window_color
            self.yes_button.background_normal = os.path.join(constants.gui_assets, "popup_half_button.png")
            self.yes_button.pos = (self.window_background.size[0] - 0.5, -0.3)
            self.yes_button.text = "YES"
            self.yes_button.color = self.window_text_color
            self.yes_button.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["very-bold"]}.ttf')
            self.yes_button.font_size = sp(22)
            self.bind(on_touch_down=self.click_event)


        self.window.add_widget(self.no_button)
        self.window.add_widget(self.yes_button)
        self.canvas.after.clear()

        self.blur_background.opacity = 0
        for widget in self.window.children:
            widget.opacity = 0

# View/Back
class PopupErrorLog(PopupWindow):
    def __init__(self, **kwargs):
        self.window_color = (1, 0.56, 0.6, 1)
        self.window_text_color = (0.2, 0.1, 0.1, 1)
        self.window_icon_path = os.path.join(constants.gui_assets, 'icons', 'question-circle.png')
        super().__init__(**kwargs)

        # Modal specific settings
        self.window_sound = sa.WaveObject.from_wave_file(os.path.join(constants.gui_assets, 'sounds', 'popup_warning.wav'))
        self.ok_button = None
        with self.canvas.after:
            self.no_button = Button()
            self.no_button.id = "no_button"
            self.no_button.size_hint = (None, None)
            self.no_button.size = (229.5, 65)
            self.no_button.border = (0, 0, 0, 0)
            self.no_button.background_color = self.window_color
            self.no_button.background_normal = os.path.join(constants.gui_assets, "popup_half_button.png")
            self.no_button.pos = (0.5, -0.3)
            self.no_button.text = "BACK"
            self.no_button.color = self.window_text_color
            self.no_button.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["very-bold"]}.ttf')
            self.no_button.font_size = sp(22)


            self.yes_button = Button()
            self.yes_button.id = "yes_button"
            self.yes_button.size_hint = (None, None)
            self.yes_button.size = (-229.5, 65)
            self.yes_button.border = (0, 0, 0, 0)
            self.yes_button.background_color = self.window_color
            self.yes_button.background_normal = os.path.join(constants.gui_assets, "popup_half_button.png")
            self.yes_button.pos = (self.window_background.size[0] - 0.5, -0.3)
            self.yes_button.text = "VIEW LOG"
            self.yes_button.color = self.window_text_color
            self.yes_button.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["very-bold"]}.ttf')
            self.yes_button.font_size = sp(22)
            self.bind(on_touch_down=self.click_event)


        self.window.add_widget(self.no_button)
        self.window.add_widget(self.yes_button)
        self.canvas.after.clear()

        self.blur_background.opacity = 0
        for widget in self.window.children:
            widget.opacity = 0

# Telepath pop-up window
class PopupTelepathPair(PopupWindow):

    def close_pair(self, *a):
        self.self_destruct(True)
        constants.telepath_pair.close()

    def update_expiry_bar(self):
        pair_data = constants.api_manager.pair_data
        Animation(size_hint_max_x=0, duration=(pair_data['expire'] - dt.now()).seconds).start(self.pair_bar)

        def later(*a):
            pair_data = constants.api_manager.pair_data
            if pair_data:
                Clock.schedule_once(later, 0.2)

                # Resize bar based on time remaining
                remaining = (pair_data['expire'] - dt.now()).seconds / (telepath.PAIR_CODE_EXPIRE_MINUTES * 60)
                if remaining <= 1:

                    # Change color if the code is about to expire
                    if remaining < 0.2:
                        self.pair_bar.color = (1, 0.56, 0.6, 1)
                        self.pair_rail.color = (0.2, 0.1, 0.1, 0.3)

                    self.resize_window()

            else:
                self.close_pair()

        later()

    def __init__(self, prompt=False, **kwargs):
        self.window_color = (0.3, 1, 0.6, 1)
        self.window_text_color = (0.07, 0.2, 0.12, 1)
        self.window_icon_path = os.path.join(constants.gui_assets, 'icons', 'telepath.png')
        super().__init__(**kwargs)

        # Check if pair succeeded with an API call from constants.telepath_pair
        if prompt:
            window_sound = 'popup_telepath_request.wav'
            title = '$Telepath$ Pair Request'
            button_text = 'CANCEL'
            self.data = constants.deepcopy(constants.telepath_pair.pair_data)

            # Override to show pair code
            self.window_content.markup = True
            code = f"{self.data['code'][0:3]}-{self.data['code'][3:]}"
            user_string = f'{self.data["host"]["host"]}/{self.data["host"]["user"]}'
            very_bold = os.path.join(constants.gui_assets, 'fonts', constants.fonts["mono-bold"])
            self.window_content.text = f"Pair '${user_string}$' with[size={round(sp(13))}]\n\n[/size][font={very_bold}.otf][size={round(sp(70))}]{code}[/size][/font]\n\n"
            self.window_content.pos_hint = {'center_y': 0.47, 'center_x': 0.5}

            # Pair texture
            self.bar_width = 250
            self.bar_offset = 0.32 if len(user_string) > 25 else 0.35
            with self.canvas.after:
                self.pair_rail = Image()
                self.pair_rail.id = "pair_bar"
                self.pair_rail.allow_stretch = True
                self.pair_rail.keep_ratio = False
                self.pair_rail.color = (*self.window_text_color[:-1], 0.3)
                self.pair_rail.size_hint_max = (self.bar_width, 10)
                self.pair_rail.pos_hint = {"center_x": 0.5, "center_y": self.bar_offset}

                self.pair_bar = Image()
                self.pair_bar.id = "pair_bar"
                self.pair_bar.allow_stretch = True
                self.pair_bar.keep_ratio = False
                self.pair_bar.color = self.window_color
                self.pair_bar.size_hint_max = (self.bar_width, 10)
                self.pair_bar.pos_hint = {"center_x": 0.5, "center_y": self.bar_offset}
            self.window.add_widget(self.pair_rail)
            self.window.add_widget(self.pair_bar)
            self.update_expiry_bar()

        else:
            success = True
            if success:
                window_sound = 'popup_telepath_success.wav'
                title = 'Pair Success'
                button_text = 'OKAY'
            else:
                window_sound = 'popup_warning.wav'
                title = 'Pair Failure'
                button_text = 'OKAY'

        # Modal specific settings
        self.window_title.text = title
        self.window_sound = sa.WaveObject.from_wave_file(os.path.join(constants.gui_assets, 'sounds', window_sound))
        self.no_button = None
        self.yes_button = None
        with self.canvas.after:
            self.ok_button = Button()
            self.ok_button.id = "ok_button"
            self.ok_button.size_hint = (None, None)
            self.ok_button.size = (459, 65)
            self.ok_button.border = (0, 0, 0, 0)
            self.ok_button.background_color = self.window_color
            self.ok_button.background_normal = os.path.join(constants.gui_assets, "popup_full_button.png")
            self.ok_button.pos_hint = {"center_x": 0.5}
            self.ok_button.text = button_text
            self.ok_button.color = self.window_text_color
            self.ok_button.font_name = os.path.join(constants.gui_assets,'fonts',f'{constants.fonts["very-bold"]}.ttf')
            self.ok_button.font_size = sp(22)
            self.bind(on_touch_down=self.click_event)

        self.window.add_widget(self.ok_button)
        self.canvas.after.clear()

        self.blur_background.opacity = 0
        for widget in self.window.children:
            widget.opacity = 0



# Big popup widgets
class BigPopupWindow(RelativeLayout):

    def generate_blur_background(self, *args):
        image_path = os.path.join(constants.gui_assets, 'live', 'blur_background.png')
        try:
            constants.folder_check(os.path.join(constants.gui_assets, 'live'))
        except:
            self.blur_background.color = constants.background_color
            return

        # Prevent this from running every resize
        def reset_activity(*args):
            self.generating_background = False

        if not self.generating_background:
            self.generating_background = True

            if self.shown:
                for widget in self.window.children:
                    widget.opacity = 0
                self.blur_background.opacity = 0

            screen_manager.current_screen.export_to_png(image_path)
            im = PILImage.open(image_path)
            im = ImageEnhance.Brightness(im)
            im = im.enhance(popup_blur_darkness)
            im1 = im.filter(GaussianBlur(popup_blur_amount))
            im1.save(image_path)
            self.blur_background.reload()

            if self.shown:
                for widget in self.window.children:
                    widget.opacity = 1
                self.blur_background.opacity = 1

            self.resize_window()
            Clock.schedule_once(reset_activity, 0.5)

    # Annoying hack to fix canvas lag
    def resize_window(*args):
        Window.on_resize(*Window.size)

    def body_button_click(self):
        pass

    def click_event(self, *args):

        button_pressed = 'ignore'
        try:
            button_pressed = args[1].button
        except:
            pass

        if not self.clicked and button_pressed in ('left', 'ignore'):

            def check_body_button(*a):
                if self.body_button:
                    if force_button == 'body' or (not force_button and ((self.body_button.x < rel_coord[0] < self.body_button.x + self.body_button.width) and (self.body_button.y < rel_coord[1] < self.body_button.y + self.body_button.height))):
                        Animation.stop_all(self.body_button)
                        self.body_button.background_color = (
                        self.window_text_color[0], self.window_text_color[1], self.window_text_color[2], 0.3)
                        Animation(background_color=self.window_text_color, duration=0.3).start(self.body_button)
                        self.body_button_click()
                        for x in range(10):
                            Clock.schedule_once(self.resize_window, x/30)

            if isinstance(args[1], str):
                force_button = args[1]
                rel_coord = (0, Window.height)
            else:
                force_button = None
                rel_coord = (args[1].pos[0] - self.x - self.window.x, args[1].pos[1] - self.y - self.window.y)

            rel_color = self.window_background.color

            # Single, wide button
            if self.ok_button:
                if (force_button in ('ok', 'yes')) or (not force_button and (rel_coord[0] < self.ok_button.width and rel_coord[1] < self.ok_button.height)):
                    self.ok_button.background_color = tuple([px + 0.12 if px < 0.88 else px for px in rel_color])
                    self.resize_window()

                    if self.callback:
                        self.callback()
                        self.clicked = True

                    Clock.schedule_once(functools.partial(self.self_destruct, True), 0.1)

                else:
                    check_body_button()


            elif (self.no_button and self.yes_button) or self.__class__.__name__ == 'PopupFile':

                # Right button
                if force_button == 'yes' or (not force_button and (rel_coord[0] > self.no_button.width + 5 and rel_coord[1] < self.yes_button.height)):
                    self.yes_button.background_color = tuple([px + 0.12 if px < 0.88 else px for px in rel_color])
                    self.resize_window()

                    if self.callback:
                        callback = self.callback[1]
                        if callback:
                            callback()
                            self.clicked = True

                    Clock.schedule_once(functools.partial(self.self_destruct, True), 0.1)

                # Left button
                elif force_button == 'no' or (not force_button and (rel_coord[0] < self.no_button.width - 5 and rel_coord[1] < self.no_button.height)):
                    self.no_button.background_color = tuple([px + 0.12 if px < 0.88 else px for px in rel_color])
                    self.resize_window()

                    if self.callback:
                        callback = self.callback[0]
                        if callback:
                            callback()
                            self.clicked = True

                    Clock.schedule_once(functools.partial(self.self_destruct, True), 0.1)

                # Body button if it exists
                elif self.body_button:
                    check_body_button()


    def resize(self):
        self.window.size = self.window_background.size
        self.window.pos = (Window.size[0]/2 - self.window_background.width/2, Window.size[1]/2 - self.window_background.height/2)
        if self.shown:
            Clock.schedule_once(self.generate_blur_background, 0.1)


    def animate(self, show=True, *args):
        window_func = functools.partial(self.resize_window)
        Clock.schedule_interval(window_func, 0.015)

        def is_shown(*args):
            self.shown = True

        if show:
            for widget in self.window.children:
                original_size = (widget.width, widget.height)
                widget.size = (original_size[0] * 0.8, original_size[1] * 0.8)
                anim = Animation(size=original_size, duration=0.05)
                anim &= Animation(opacity=1, duration=0.25)
                anim.start(widget)
            Animation(opacity=1, duration=0.25).start(self.blur_background)
            Clock.schedule_once(functools.partial(is_shown), 0.5)
        else:
            for widget in self.window.children:
                if "button" in widget.id:
                    widget.opacity = 0

            image_path = os.path.join(constants.gui_assets, 'live', 'popup.png')
            self.window.export_to_png(image_path)

            for widget in self.window.children:
                if widget != self.window_background and "button" not in widget.id:
                    widget.opacity = 0
                else:
                    if widget == self.window_background:
                        widget.color = (1,1,1,1)
                        widget.source = image_path
                        widget.reload()
                    original_size = (widget.width, widget.height)
                    new_size = (original_size[0] * 0.85, original_size[1] * 0.85)
                    anim = Animation(size=new_size, duration=0.08)
                    anim &= Animation(opacity=0, duration=0.25)

                    if widget.id == "body_button":
                        widget.opacity = 1
                        original_pos = (widget.pos[0] + 13, widget.pos[1] + 45)
                        anim &= Animation(font_size=widget.font_size-3.5, pos=original_pos, duration=0.08)

                    elif "ok_button" in widget.id:
                        widget.opacity = 1
                        original_pos = (widget.pos[0], widget.pos[1] + 49.25)
                        anim &= Animation(font_size=widget.font_size-3.5, pos=original_pos, duration=0.08)

                    elif "button" in widget.id:
                        widget.opacity = 1
                        original_pos = (widget.pos[0] + (-49.25 if widget.id.replace("_button", "") in ["yes", "install"] else +49.25 if "no" in widget.id else 0), widget.pos[1] + 48)
                        anim &= Animation(font_size=widget.font_size-3.5, pos=original_pos, duration=0.08)

                    anim.start(widget)

            Animation(opacity=0, duration=0.28).start(self.blur_background)

        Clock.schedule_once(functools.partial(Clock.unschedule, window_func), 0.35)


    # Delete popup bind
    def self_destruct(self, animate, *args):

        if not self.shown:
            return

        def delete(*args):

            try:
                for widget in self.parent.children:
                    if "Popup" in widget.__class__.__name__:
                        self.parent.popup_widget = None
                        self.parent.canvas.after.clear()
                        self.parent.remove_widget(widget)
                        self.canvas.after.clear()
            except AttributeError:
                if constants.debug:
                    print("Window Popup Error: Failed to delete popup as the parent window doesn't exist")

        if animate:
            self.animate(False)
            Clock.schedule_once(delete, 0.36)
        else:
            delete()


    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # Popup window layout
        self.window = RelativeLayout()
        self.callback = None
        self.window_sound = None
        self.shown = False
        self.clicked = False
        self.body_button = None

        with self.canvas.after:
            # Blurred background
            self.blur_background = Image()
            self.blur_background.opacity = 0
            self.blur_background.id = "blur_background"
            self.blur_background.source = os.path.join(constants.gui_assets, 'live', 'blur_background.png')
            self.blur_background.allow_stretch = True
            self.blur_background.keep_ratio = False
            self.generating_background = False


            # Popup window background
            self.window_background = Image(source=os.path.join(constants.gui_assets, "big_popup_background.png"))
            self.window_background.id = "window_background"
            self.window_background.size_hint = (None, None)
            self.window_background.allow_stretch = True
            self.window_background.keep_ratio = False
            self.window_background.color = self.window_color
            self.window_background.size = (650, 650)
            self.window_background.pos_hint = {"center_x": 0.5, "center_y": 0.5}


            # Popup window title
            self.window_icon = Image(source=self.window_icon_path)
            self.window_icon.id = "window_icon"
            self.window_icon.size_hint = (None, None)
            self.window_icon.allow_stretch = True
            self.window_icon.color = self.window_text_color
            self.window_icon.size = (32, 32)
            self.window_icon.pos = (self.window.x + 20, self.window.y + self.window_background.height - 44.5)

            self.window_title = Label()
            self.window_title.id = "window_title"
            self.window_title.color = self.window_text_color
            self.window_title.font_size = sp(25)
            self.window_title.y = (self.window_background.height / 3 + 80)
            self.window_title.pos_hint = {"center_x": 0.5}
            self.window_title.font_name = os.path.join(constants.gui_assets,'fonts',f'{constants.fonts["italic"]}.ttf')


            # Popup window content
            self.window_content = Label()
            self.window_content.id = "window_content"
            self.window_content.color = tuple([px * 1.5 if px < 1 else px for px in self.window_text_color])
            self.window_content.font_size = sp(23)
            self.window_content.line_height = 1.15
            self.window_content.halign = "center"
            self.window_content.valign = "center"
            self.window_content.text_size = (self.window_background.width - 40, self.window_background.height - 25)
            self.window_content.pos_hint = {"center_x": 0.5, "center_y": 0.52}
            self.window_content.font_name = os.path.join(constants.gui_assets,'fonts',f'{constants.fonts["bold"]}.ttf')


        self.add_widget(self.blur_background)
        self.window.add_widget(self.window_background)
        self.window.add_widget(self.window_icon)
        self.window.add_widget(self.window_title)
        self.window.add_widget(self.window_content)

# Controls popup for biggg stuff
class PopupControls(BigPopupWindow):
    def __init__(self, **kwargs):
        self.window_color = (0.42, 0.475, 1, 1)
        self.window_text_color = (0.1, 0.1, 0.2, 1)
        self.window_icon_path = os.path.join(constants.gui_assets, 'icons', 'information-circle.png')
        super().__init__(**kwargs)


        # Align window content
        self.window_content.halign = "left"
        self.window_content.valign = "top"
        self.window_content.pos_hint = {"center_x": 0.5, "center_y": 0.4}
        self.window_content.max_lines = 15 # Cuts off the beginning of content??


        # Modal specific settings
        self.window_sound = None
        self.no_button = None
        self.yes_button = None
        with self.canvas.after:
            self.ok_button = Button()
            self.ok_button.id = "ok_button"
            self.ok_button.size_hint = (None, None)
            self.ok_button.size = (650.6, 65)
            self.ok_button.border = (0, 0, 0, 0)
            self.ok_button.background_color = self.window_color
            self.ok_button.background_normal = os.path.join(constants.gui_assets, "big_popup_full_button.png")
            self.ok_button.pos_hint = {"center_x": 0.5006}
            self.ok_button.text = "OKAY"
            self.ok_button.color = self.window_text_color
            self.ok_button.font_name = os.path.join(constants.gui_assets,'fonts',f'{constants.fonts["very-bold"]}.ttf')
            self.ok_button.font_size = sp(22)
            self.bind(on_touch_down=self.click_event)

        self.window.add_widget(self.ok_button)
        self.canvas.after.clear()

        self.blur_background.opacity = 0
        for widget in self.window.children:
            widget.opacity = 0

# Popup for text files
class PopupFile(BigPopupWindow):
    def body_button_click(self):
        if self.file_path:
            view_file(self.file_path)

    def set_text(self, path: str, *a):
        if os.path.isfile(path):
            with open(path, 'r') as f:
                self.window_content.text = f.read()
                self.file_path = path
        else:
            self.window_content.text = 'No content available'

    def __init__(self, **kwargs):
        self.file_path = None

        self.window_color = (0.42, 0.475, 1, 1)
        self.window_text_color = (0.1, 0.1, 0.2, 1)
        self.window_icon_path = os.path.join(constants.gui_assets, 'icons', 'information-circle.png')
        super().__init__(**kwargs)


        # Align window content
        self.window_content.__translate__ = False
        self.window_content.halign = "left"
        self.window_content.valign = "top"
        self.window_content.pos_hint = {"center_x": 0.5, "center_y": 0.41}
        self.window_content.max_lines = 14 # Cuts off the beginning of content??


        # Modal specific settings
        self.window_sound = None
        self.no_button = None
        self.yes_button = None
        with self.canvas.after:

            # Body Button (Open in logviewer)
            self.body_button = Button()
            self.body_button.id = "body_button"
            self.body_button.size_hint = (None, None)
            self.body_button.size = (200 if constants.app_config.locale == 'en' else 260, 40)
            self.body_button.border = (0, 0, 0, 0)
            self.body_button.background_color = self.window_text_color
            self.body_button.background_normal = os.path.join(constants.gui_assets, "addon_view_button.png")
            self.body_button.pos = ((self.window_background.size[0] / 2) - (self.body_button.size[0] / 2), 77)
            self.body_button.text = "click to view more"
            self.body_button.color = self.window_color
            self.body_button.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
            self.body_button.font_size = sp(20)


            self.ok_button = Button()
            self.ok_button.id = "ok_button"
            self.ok_button.size_hint = (None, None)
            self.ok_button.size = (650.6, 65)
            self.ok_button.border = (0, 0, 0, 0)
            self.ok_button.background_color = self.window_color
            self.ok_button.background_normal = os.path.join(constants.gui_assets, "big_popup_full_button.png")
            self.ok_button.pos_hint = {"center_x": 0.5006}
            self.ok_button.text = "OKAY"
            self.ok_button.color = self.window_text_color
            self.ok_button.font_name = os.path.join(constants.gui_assets,'fonts',f'{constants.fonts["very-bold"]}.ttf')
            self.ok_button.font_size = sp(22)
            self.bind(on_touch_down=self.click_event)

        self.window.add_widget(self.ok_button)
        self.window.add_widget(self.body_button)
        self.canvas.after.clear()

        self.blur_background.opacity = 0
        for widget in self.window.children:
            widget.opacity = 0

# Addon popup
class PopupAddon(BigPopupWindow):
    def body_button_click(self):
        if self.addon_object:
            if self.addon_object.type in ["forge", "neoforge", "fabric", "quilt", "modpack"]:
                url = self.addon_object.url
            else:
                url = "https://dev.bukkit.org" + self.addon_object.url

            webbrowser.open_new_tab(url)

    def __init__(self, addon_object=None, **kwargs):
        self.window_color = (0.42, 0.475, 1, 1)
        self.window_text_color = (0.1, 0.1, 0.2, 1)
        self.window_icon_path = os.path.join(constants.gui_assets, 'icons', 'extension-puzzle-sharp.png')
        self.installed = False

        # Assign addon info to popup
        if addon_object:
            if addon_object.__class__.__name__ == "partial":
                addon_info = addon_object()
                self.addon_object = addon_info[0]
                self.installed = addon_info[1]
        else:
            self.addon_object = None

        # If addon is unavailable, show info
        if not self.addon_object:
            del self
            return


        super().__init__(**kwargs)

        self.is_modpack = screen_manager.current_screen.name == "ServerImportModpackSearchScreen"


        # Title
        self.window_title.text_size[0] = (self.window_background.size[0] * 0.7)
        self.window_title.__translate__ = False
        self.window_title.halign = "center"
        self.window_title.shorten = True
        self.window_title.markup = True
        self.window_title.shorten_from = "right"
        self.window_title.text = f"{self.addon_object.name}  [color=#3E4691]-[/color]  {self.addon_object.author if self.addon_object.author else 'Unknown'}"


        # Description
        self.window_content.__translate__ = False
        self.window_content.text = "" if not addon_object else self.addon_object.description
        if not self.window_content.text.strip():
            self.window_content.text = "description unavailable"
        else:
            self.window_content.halign = "left"
            self.window_content.valign = "top"
            self.window_content.pos_hint = {"center_x": 0.5, "center_y": 0.465 if self.is_modpack else 0.4}

        if self.is_modpack:
            self.window_content.max_lines = 15 # Cuts off the beginning of content??
        else:
            self.window_content.max_lines = 13 if self.installed else 14  # Cuts off the beginning of content??


        # Modal specific settings
        self.window_sound = None
        self.ok_button = None
        with self.canvas.after:

            # Body Button (Open in browser)
            self.body_button = Button()
            self.body_button.id = "body_button"
            self.body_button.size_hint = (None, None)
            self.body_button.size = (200 if constants.app_config.locale == 'en' else 260, 40)
            self.body_button.border = (0, 0, 0, 0)
            self.body_button.background_color = self.window_text_color
            self.body_button.background_normal = os.path.join(constants.gui_assets, "addon_view_button.png")
            self.body_button.pos = ((self.window_background.size[0] / 2) - (self.body_button.size[0] / 2), 77)
            self.body_button.text = "click to view more"
            self.body_button.color = self.window_color
            self.body_button.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
            self.body_button.font_size = sp(20)



            self.no_button = Button()
            self.no_button.id = "no_button"
            self.no_button.size_hint = (None, None)
            self.no_button.size = (327, 65)
            self.no_button.border = (0, 0, 0, 0)
            self.no_button.background_color = self.window_color
            self.no_button.background_normal = os.path.join(constants.gui_assets, "big_popup_half_button.png")
            self.no_button.pos = (0, -0.3)
            self.no_button.text = "BACK"
            self.no_button.color = self.window_text_color
            self.no_button.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["very-bold"]}.ttf')
            self.no_button.font_size = sp(22)

            self.yes_button = Button()
            self.yes_button.id = "install_button"
            self.yes_button.size_hint = (None, None)
            self.yes_button.size = (-327, 65)
            self.yes_button.border = (0, 0, 0, 0)
            self.yes_button.background_color = self.window_color
            self.yes_button.background_normal = os.path.join(constants.gui_assets, "big_popup_half_button.png")
            self.yes_button.pos = (self.window_background.size[0] + 1, -0.3)
            self.yes_button.text = "INSTALL" if not self.installed else "UNINSTALL"
            self.yes_button.color = self.window_text_color
            self.yes_button.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["very-bold"]}.ttf')
            self.yes_button.font_size = sp(22)


            # Version Banner
            if not self.is_modpack:
                addon_supported = False
                if not self.addon_object.versions:
                    addon_versions = "None"

                elif len(self.addon_object.versions) == 1:
                    addon_versions = self.addon_object.versions[0]

                else:
                    addon_versions = f"{self.addon_object.versions[-1]}-{self.addon_object.versions[0]}"

                if screen_manager.current_screen.name == "CreateServerAddonSearchScreen":
                    server_version = constants.new_server_info['version']
                else:
                    server_version = constants.server_manager.current_server.version

                if self.addon_object.versions:
                    addon_supported = constants.version_check(server_version, ">=", self.addon_object.versions[-1]) and constants.version_check(server_version, "<=", self.addon_object.versions[0])

                version_text = f"{constants.translate('Supported' if addon_supported else 'Unsupported')}:  {addon_versions}"

                self.version_banner = BannerObject(
                    __translate__ = False,
                    pos_hint = {"center_x": (0.5 if not self.installed else 0.36), "center_y": 0.877},
                    size = (250, 40),
                    color = (0.4, 0.682, 1, 1) if addon_supported else (1, 0.53, 0.58, 1),
                    text = version_text,
                    icon = "information-circle.png"
                )
                self.version_banner.id = "version_banner"


                # Installed banner
                if self.installed:
                    self.installed_banner = BannerObject(
                        pos_hint = {"center_x": 0.74, "center_y": 0.877},
                        size = (150, 40),
                        color = (0.553, 0.902, 0.675, 1),
                        text = "installed",
                        icon = "checkmark-circle.png",
                        icon_side = "right"
                    )
                    self.installed_banner.id = "installed_banner"



        self.window.add_widget(self.no_button)
        self.window.add_widget(self.yes_button)
        self.window.add_widget(self.body_button)

        if not self.is_modpack:
            self.window.add_widget(self.version_banner)
            if self.installed:
                self.window.add_widget(self.installed_banner)

        self.bind(on_touch_down=self.click_event)

        self.canvas.after.clear()

        self.blur_background.opacity = 0
        for widget in self.window.children:
            widget.opacity = 0

# Script popup
class PopupScript(BigPopupWindow):
    def body_button_click(self):
        if self.script_object:
            webbrowser.open_new_tab(self.script_object.url)

    def __init__(self, script_object=None, **kwargs):

        self.window_color = (0.42, 0.475, 1, 1)
        self.window_text_color = (0.1, 0.1, 0.2, 1)
        self.window_icon_path = os.path.join(constants.gui_assets, 'icons', 'amscript.png')
        self.installed = False

        # Assign addon info to popup
        if script_object:
            self.script_object = script_object[1]
            self.installed = script_object[0]
        else:
            self.script_object = None

        # If addon is unavailable, show info
        if not self.script_object:
            del self
            return


        super().__init__(**kwargs)


        # Title
        self.window_title.text_size[0] = (self.window_background.size[0] * 0.7)
        self.window_title.__translate__ = False
        self.window_title.halign = "center"
        self.window_title.shorten = True
        self.window_title.markup = True
        self.window_title.shorten_from = "right"
        self.window_title.text = f"{self.script_object.name}  [color=#3E4691]-[/color]  {self.script_object.author if self.script_object.author else 'Unknown'}"


        # Description
        self.window_content.__translate__ = False
        self.window_content.text = "" if not script_object else self.script_object.description
        if not self.window_content.text.strip():
            self.window_content.text = "description unavailable"
        else:
            self.window_content.halign = "left"
            self.window_content.valign = "top"
            self.window_content.pos_hint = {"center_x": 0.5, "center_y": 0.35 if self.installed else 0.4}

        self.window_content.max_lines = 13 if self.installed else 14 # Cuts off the beginning of content??


        # Modal specific settings
        self.window_sound = None
        self.ok_button = None
        with self.canvas.after:

            # Body Button (Open in browser)
            self.body_button = Button()
            self.body_button.id = "body_button"
            self.body_button.size_hint = (None, None)
            self.body_button.size = (200 if constants.app_config.locale == 'en' else 260, 40)
            self.body_button.border = (0, 0, 0, 0)
            self.body_button.background_color = self.window_text_color
            self.body_button.background_normal = os.path.join(constants.gui_assets, "addon_view_button.png")
            self.body_button.pos = ((self.window_background.size[0] / 2) - (self.body_button.size[0] / 2), 77)
            self.body_button.text = "click to view more"
            self.body_button.color = self.window_color
            self.body_button.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
            self.body_button.font_size = sp(20)



            self.no_button = Button()
            self.no_button.id = "no_button"
            self.no_button.size_hint = (None, None)
            self.no_button.size = (327, 65)
            self.no_button.border = (0, 0, 0, 0)
            self.no_button.background_color = self.window_color
            self.no_button.background_normal = os.path.join(constants.gui_assets, "big_popup_half_button.png")
            self.no_button.pos = (0, -0.3)
            self.no_button.text = "BACK"
            self.no_button.color = self.window_text_color
            self.no_button.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["very-bold"]}.ttf')
            self.no_button.font_size = sp(22)

            self.yes_button = Button()
            self.yes_button.id = "install_button"
            self.yes_button.size_hint = (None, None)
            self.yes_button.size = (-327, 65)
            self.yes_button.border = (0, 0, 0, 0)
            self.yes_button.background_color = self.window_color
            self.yes_button.background_normal = os.path.join(constants.gui_assets, "big_popup_half_button.png")
            self.yes_button.pos = (self.window_background.size[0] + 1, -0.3)
            self.yes_button.text = "INSTALL" if not self.installed else "UNINSTALL"
            self.yes_button.color = self.window_text_color
            self.yes_button.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["very-bold"]}.ttf')
            self.yes_button.font_size = sp(22)

            # Installed banner
            if self.installed:
                self.installed_banner = BannerObject(
                    pos_hint = {"center_x": 0.5, "center_y": 0.877},
                    size = (150, 40),
                    color = (0.553, 0.902, 0.675, 1),
                    text = "installed",
                    icon = "checkmark-circle.png",
                    icon_side = "right"
                )
                self.installed_banner.id = "installed_banner"



        self.window.add_widget(self.no_button)
        self.window.add_widget(self.yes_button)
        self.window.add_widget(self.body_button)
        if self.installed:
            self.window.add_widget(self.installed_banner)

        self.bind(on_touch_down=self.click_event)

        self.canvas.after.clear()

        self.blur_background.opacity = 0
        for widget in self.window.children:
            widget.opacity = 0

# Update popup
class PopupUpdate(BigPopupWindow):
    def body_button_click(self):
        url = f'{constants.project_link}/releases/latest'
        webbrowser.open_new_tab(url)

    def __init__(self, **kwargs):
        self.window_color = (0.42, 0.475, 1, 1)
        self.window_text_color = (0.1, 0.1, 0.2, 1)
        self.window_icon_path = os.path.join(constants.gui_assets, 'icons', 'cloud-download.png')

        # Assign update info to popup
        if constants.update_data:
            self.update_data = constants.update_data
        else:
            self.update_data = None
            del self
            return

        if not self.update_data['version']:
            del self
            return

        super().__init__(**kwargs)


        # Title
        self.window_title.text_size[0] = (self.window_background.size[0] * 0.7)
        self.window_title.halign = "center"
        self.window_title.shorten = True
        self.window_title.markup = True
        self.window_title.shorten_from = "right"
        self.window_title.text = f"Update Available"


        # Description
        self.window_content.__translate__ = False
        self.window_content.text = "" if not self.update_data['desc'] else ("\n\n" + self.update_data['desc'])
        if not self.window_content.text.strip():
            self.window_content.text = "description unavailable"
        else:
            self.window_content.halign = "left"
            self.window_content.valign = "top"
            self.window_content.pos_hint = {"center_x": 0.5, "center_y": 0.4}
        self.window_content.max_lines = 14 # Cuts off the beginning of content??


        # Modal specific settings
        self.window_sound = sa.WaveObject.from_wave_file(os.path.join(constants.gui_assets, 'sounds', 'popup_normal.wav'))
        self.ok_button = None
        with self.canvas.after:

            # Body Button (Open in browser)
            self.body_button = Button()
            self.body_button.id = "body_button"
            self.body_button.size_hint = (None, None)
            self.body_button.size = (200 if constants.app_config.locale == 'en' else 260, 40)
            self.body_button.border = (0, 0, 0, 0)
            self.body_button.background_color = self.window_text_color
            self.body_button.background_normal = os.path.join(constants.gui_assets, "addon_view_button.png")
            self.body_button.pos = ((self.window_background.size[0] / 2) - (self.body_button.size[0] / 2), 77)
            self.body_button.text = "click to view more"
            self.body_button.color = self.window_color
            self.body_button.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
            self.body_button.font_size = sp(20)


            self.no_button = Button()
            self.no_button.id = "no_button"
            self.no_button.size_hint = (None, None)
            self.no_button.size = (327, 65)
            self.no_button.border = (0, 0, 0, 0)
            self.no_button.background_color = self.window_color
            self.no_button.background_normal = os.path.join(constants.gui_assets, "big_popup_half_button.png")
            self.no_button.pos = (0, -0.3)
            self.no_button.text = "BACK"
            self.no_button.color = self.window_text_color
            self.no_button.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["very-bold"]}.ttf')
            self.no_button.font_size = sp(22)

            self.yes_button = Button()
            self.yes_button.id = "install_button"
            self.yes_button.size_hint = (None, None)
            self.yes_button.size = (-327, 65)
            self.yes_button.border = (0, 0, 0, 0)
            self.yes_button.background_color = self.window_color
            self.yes_button.background_normal = os.path.join(constants.gui_assets, "big_popup_half_button.png")
            self.yes_button.pos = (self.window_background.size[0] + 1, -0.3)
            self.yes_button.text = "INSTALL"
            self.yes_button.color = self.window_text_color
            self.yes_button.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["very-bold"]}.ttf')
            self.yes_button.font_size = sp(22)

            self.version_banner = BannerObject(
                pos_hint = {"center_x": 0.5, "center_y": 0.877},
                size = (150, 40),
                color = (0.4, 0.682, 1, 1),
                text = f"v{self.update_data['version']}",
                icon = "information-circle.png"
            )
            self.version_banner.id = "version_banner"


        self.window.add_widget(self.no_button)
        self.window.add_widget(self.yes_button)
        self.window.add_widget(self.body_button)
        self.window.add_widget(self.version_banner)

        self.bind(on_touch_down=self.click_event)

        self.canvas.after.clear()

        self.blur_background.opacity = 0
        for widget in self.window.children:
            widget.opacity = 0



# Global search bar
class PopupSearch(RelativeLayout):
    "play-circle-sharp.png"
    "newspaper.png"
    "terminal.png"
    "exit-sharp.png"

    class ResultButton(RelativeLayout):
        def __init__(self, **kwargs):
            super().__init__(**kwargs)

            self.size_hint_max = (600, 75)
            self.search_obj = None

            self.button = Button()
            self.button.border = (0, 0, 0, 0)
            self.button.background_normal = os.path.join(constants.gui_assets, 'global_search_button.png')
            self.add_widget(self.button)

            self.title = Label()
            self.title.text = 'Hello!'
            self.title.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["bold"]}.ttf')
            self.title.font_size = sp(30)
            self.title.pos_hint = {'center_x': 0.5, 'center_y': 0.75}
            self.title.markup = True
            self.add_widget(self.title)

            self.subtitle = Label()
            self.subtitle.text = "I'm a subtitle"
            self.subtitle.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
            self.subtitle.font_size = sp(22)
            self.subtitle.pos_hint = {'center_x': 0.5, 'center_y': 0.3}
            self.add_widget(self.subtitle)

            self.icon = Image(source=None)
            self.icon.id = "window_icon"
            self.icon.size_hint = (None, None)
            self.icon.allow_stretch = True
            self.icon.color = (1, 1, 1, 1)
            self.icon.size = (36, 36)
            self.icon.pos_hint = {'center_x': 0.05, 'center_y': 0.5}
            self.add_widget(self.icon)

            self.opacity = 0

        @staticmethod
        def fix_lag(t, *a):
            for x in range(t):
                Clock.schedule_once(screen_manager.current_screen.popup_widget.resize_window, x / 100)

        # Contains all button overrides
        def animate_click(self):
            self.fix_lag(50)

            original_color = self.search_obj.color
            bright_color = constants.brighten_color(original_color, 0.15)

            new_original = constants.brighten_color(original_color, 0.25)
            new_bright = constants.brighten_color(bright_color, 0.1)

            self.title.color = new_bright
            self.icon.color = new_bright
            self.subtitle.color = new_original
            self.button.background_color = new_original

            Animation(color=bright_color, duration=0.5).start(self.title)
            Animation(color=bright_color, duration=0.5).start(self.icon)
            Animation(color=original_color, duration=0.5).start(self.subtitle)
            Animation(background_color=original_color, duration=0.5).start(self.button)

            # Process click with directed target
            def process_target(*b):

                # The following are overrides for extra functionality from the search bar
                def override_acl(list_type):
                    screen = screen_manager.get_screen(self.search_obj.target)

                    if screen_manager.current_screen.name == self.search_obj.target:
                        screen_manager.current_screen.update_list(list_type)
                        text = 'OPERATORS' if list_type == 'ops' else 'WHITELIST' if list_type == 'wl' else 'BANS'
                        screen.page_selector.change_text(text)
                    else:
                        if self.search_obj.target.startswith('Server'):
                            screen.acl_object = constants.server_manager.current_server.acl
                            screen._hash = constants.server_manager.current_server._hash
                        else:
                            screen.acl_object = constants.new_server_info['acl_object']
                            screen._hash = constants.new_server_info['_hash']

                        screen.current_list = list_type
                        screen_manager.current = self.search_obj.target

                # Override for launching the server
                if self.search_obj.title.lower() == 'launch server':
                    screen_manager.current = self.search_obj.target
                    Clock.schedule_once(screen_manager.current_screen.console_panel.launch_server, 0)

                elif self.search_obj.title.lower() == 'restart server':
                    constants.server_manager.current_server.restart()

                elif self.search_obj.title.lower() == 'stop server':
                    screen_manager.current_screen.server.silent_command("stop")

                # Update server
                elif self.search_obj.title.lower() == 'update this server':
                    screen_manager.current = self.search_obj.target
                    screen_manager.current_screen.update_button.button.trigger_action()

                # Update auto-mcs
                elif self.search_obj.title.lower() == 'update auto-mcs':
                    screen_manager.current = self.search_obj.target
                    Clock.schedule_once(screen_manager.current_screen.prompt_update, 0)

                # ACL functions
                elif self.search_obj.title.lower() == 'configure bans':
                    override_acl('bans')

                elif self.search_obj.title.lower() == 'configure operators':
                    override_acl('ops')

                elif self.search_obj.title.lower() == 'configure the whitelist':
                    override_acl('wl')

                # Open directory functions
                elif self.search_obj.title.lower() == 'open server directory':
                    constants.open_folder(constants.server_manager.current_server.server_path)

                elif self.search_obj.title.lower() == 'open back-up directory':
                    constants.open_folder(constants.server_manager.current_server.backup.directory)

                elif self.search_obj.title.lower() == 'open script directory':
                    constants.open_folder(constants.scriptDir)

                # Save back-up
                elif self.search_obj.title.lower() == 'save a back-up now':
                    screen_manager.current = self.search_obj.target
                    screen_manager.current_screen.save_backup_button.button.trigger_action()

                # Create a new server
                elif self.search_obj.title.lower() == 'create a new server':
                    constants.new_server_init()
                    screen_manager.current = self.search_obj.target

                # Migrate server
                elif self.search_obj.title.lower() == "change 'server.jar'":
                    server_obj = constants.server_manager.current_server
                    constants.new_server_init()
                    constants.new_server_info['type'] = server_obj.type
                    constants.new_server_info['version'] = server_obj.version
                    screen_manager.current = self.search_obj.target

                # Transilience settings
                elif self.search_obj.title.lower() == 'rename this server':
                    screen_manager.current = self.search_obj.target
                    rename_input = screen_manager.current_screen.rename_input
                    screen_manager.current_screen.scroll_widget.scroll_to(rename_input)
                    Clock.schedule_once(rename_input.grab_focus, 0.2)

                elif self.search_obj.title.lower() == 'delete this server':
                    screen_manager.current = self.search_obj.target
                    delete_button = screen_manager.current_screen.delete_button
                    screen_manager.current_screen.scroll_widget.scroll_to(delete_button, animate=False)
                    Clock.schedule_once(delete_button.button.trigger_action, 0.1)

                # Install proxy
                elif self.search_obj.title.lower() == 'install proxy (playit)':
                    screen_manager.current = self.search_obj.target
                    proxy_button = screen_manager.current_screen.proxy_button
                    screen_manager.current_screen.scroll_widget.scroll_to(proxy_button, animate=False)
                    Clock.schedule_once(proxy_button.button.trigger_action, 0.1)


                # Below is standard functionality for the server actions

                # Open server
                elif self.search_obj.type == 'server':
                    if self.search_obj._telepath_data:
                        open_remote_server(self.search_obj._telepath_data, self.search_obj._telepath_data['name'])
                    else:
                        open_server(self.search_obj.title)

                # Otherwise, launch web URL or go to screen
                elif self.search_obj.target:
                    if self.search_obj.target.startswith('http'):
                        webbrowser.open_new_tab(self.search_obj.target)
                    else:
                        screen_manager.current = self.search_obj.target

            def do_things(*a):
                screen_manager.current_screen.popup_widget.self_destruct(True)
                Clock.schedule_once(process_target, 0.4)
            Clock.schedule_once(do_things, 0.14)

        def refresh_data(self, search_obj, fun_anim=False, *a):

            def fade_out():
                Animation.stop_all(self)
                Animation(opacity=0, duration=0.2, transition='in_out_sine').start(self)

            if not search_obj:
                fade_out()
                return None

            try:
                animate = search_obj.title != self.title.text
            except AttributeError:
                fade_out()
                return None

            if animate:
                self.fix_lag(50)
                def change_data(*a):
                    self.title.__translate__ = not search_obj.type == 'server'

                    self.search_obj = search_obj
                    self.title.text = search_obj.title
                    self.subtitle.text = search_obj.subtitle
                    self.icon.source = search_obj.icon
                    self.title.font_size = sp(30 - (0 if len(self.title.text) < 30 else (len(self.title.text) / 7)))
                    self.title.pos_hint = {'center_x': (0.5 if len(self.title.text) < 30 else 0.51), 'center_y': 0.75}

                    # Change Colors
                    bright_color = constants.brighten_color(search_obj.color, 0.15)
                    self.title.color = bright_color
                    self.icon.color = bright_color
                    self.subtitle.color = search_obj.color
                    self.button.background_color = search_obj.color

                    Animation.stop_all(self)
                    Animation(opacity=1, duration=0.5 if fun_anim else 0.2, transition='in_out_sine').start(self)
                fade_out()
                Clock.schedule_once(change_data, 0.1)


    def generate_blur_background(self, *args):
        image_path = os.path.join(constants.gui_assets, 'live', 'blur_background.png')
        try:
            constants.folder_check(os.path.join(constants.gui_assets, 'live'))
        except:
            self.blur_background.color = constants.background_color
            return

        # Prevent this from running every resize
        def reset_activity(*args):
            self.generating_background = False

        if not self.generating_background:
            self.generating_background = True

            if self.shown:
                for widget in self.window.children:
                    widget.opacity = 0
                self.blur_background.opacity = 0

            screen_manager.current_screen.export_to_png(image_path)
            im = PILImage.open(image_path)
            im = ImageEnhance.Brightness(im)
            im = im.enhance(popup_blur_darkness - 0.09)
            im1 = im.filter(GaussianBlur(popup_blur_amount + 5))
            im1.save(image_path)
            self.blur_background.reload()

            if self.shown:
                for widget in self.window.children:
                    widget.opacity = 1
                self.blur_background.opacity = 1

            self.resize_window()
            Clock.schedule_once(reset_activity, 0.5)


    # Annoying hack to fix canvas lag
    def resize_window(*args):
        Window.on_resize(*Window.size)


    def click_event(self, *args):

        button_pressed = 'ignore'
        try:
            button_pressed = args[1].button
        except:
            pass

        if not self.clicked and button_pressed == 'left':

            if isinstance(args[1], str):
                self.self_destruct(True)
            else:
                rel_coord = (args[1].pos[0] - self.x - self.window.x, args[1].pos[1] - self.y - self.window.y)

            for button in self.results.children:
                if button.opacity == 1:
                    if button.width > rel_coord[0] > button.x and (button.height + button.y) > rel_coord[1] > button.y:
                        button.animate_click()
                        self.dont_hide = True
                    else:
                        Animation(opacity=0, duration=0.13).start(button)


    def resize(self):
        self.window.size = self.window_background.size

        # Shift the popup upward at smaller window heights
        offset_y = 0
        if Window.size[1] < 900:
            offset_y = 75
        if Window.size[1] < 800:
            offset_y = 100

        # Add offset_y to the original y-position
        self.window.pos = (
            Window.size[0] / 2 - self.window_background.width / 2,
            Window.size[1] / 2 - self.window_background.height / 2 + offset_y
        )

        if self.shown:
            Clock.schedule_once(self.generate_blur_background, 0.1)


    def animate(self, show=True, *args):
        window_func = functools.partial(self.resize_window)
        Clock.schedule_interval(window_func, 0.015)

        def is_shown(*args):
            self.shown = True

        if show:
            for widget in self.window.children:
                original_size = (widget.width, widget.height)
                widget.size = (original_size[0] * 0.8, original_size[1] * 0.8)
                anim = Animation(size=original_size, duration=0.05)
                anim &= Animation(opacity=1, duration=0.25)
                anim.start(widget)
            Animation(opacity=1, duration=0.25).start(self.blur_background)
            Clock.schedule_once(functools.partial(is_shown), 0.5)
        else:
            for widget in self.window.children:
                if "button" in widget.id:
                    widget.opacity = 0

            image_path = os.path.join(constants.gui_assets, 'live', 'popup.png')
            self.window.export_to_png(image_path)

            for widget in self.window.children:
                if widget != self.window_background and "button" not in widget.id:
                    widget.opacity = 0
                else:
                    if widget == self.window_background:
                        widget.color = (1,1,1,1)
                        widget.source = image_path
                        widget.reload()
                    original_size = (widget.width, widget.height)
                    new_size = (original_size[0] * 0.85, original_size[1] * 0.85)
                    anim = Animation(size=new_size, duration=0.08)
                    anim &= Animation(opacity=0, duration=0.25)

                    if "ok_button" in widget.id:
                        widget.opacity = 1
                        original_pos = (widget.pos[0], widget.pos[1] + 28)
                        anim &= Animation(font_size=widget.font_size-3.5, pos=original_pos, duration=0.08)

                    elif "button" in widget.id:
                        widget.opacity = 1
                        original_pos = (widget.pos[0] + (-34.25 if "yes" in widget.id else +34.25 if "no" in widget.id else 0), widget.pos[1] + 28)
                        anim &= Animation(font_size=widget.font_size-3.5, pos=original_pos, duration=0.08)

                    anim.start(widget)

            Animation(opacity=0, duration=0.28).start(self.blur_background)

        Clock.schedule_once(functools.partial(Clock.unschedule, window_func), 0.35)


    # Delete popup bind
    def self_destruct(self, animate, *args):

        if not self.shown:
            return

        def delete(*args):

            try:
                for widget in self.parent.children:
                    if "Popup" in widget.__class__.__name__:
                        self.parent.popup_widget = None
                        self.parent.canvas.after.clear()
                        self.parent.remove_widget(widget)
                        self.canvas.after.clear()
            except AttributeError:
                if constants.debug:
                    print("Window Popup Error: Failed to delete popup as the parent window doesn't exist")

        if animate:
            self.animate(False)
            Clock.schedule_once(delete, 0.4)
        else:
            delete()


    # Generate search results when typing
    def on_search(self, force=None, fun_anim=False, *a):

        # Set lock for a timeout
        if not self.search_lock and (self.window_input.text or force):
            self.search_lock = True

            # Update results with query
            if force:
                self.search_text = force
            else:
                self.search_text = self.window_input.text
            try:
                results = constants.search_manager.execute_search(screen_manager.current, self.search_text)

                complete_list = [results['guide']]
                complete_list.extend(results['server'])
                complete_list.extend(results['setting'])
                complete_list.extend(results['screen'])
                complete_list = tuple(sorted(complete_list, key=lambda x: x.score, reverse=True))

                for x, button in enumerate(reversed(self.results.children), 0):
                    if fun_anim:
                        Clock.schedule_once(functools.partial(button.refresh_data, complete_list[x], True), (x*0.1))
                    else:
                        button.refresh_data(complete_list[x])

            except:
                pass

            # print(vars(results['guide']))
            # for item in results['server'][:2]:
            #     print(vars(item))
            # for item in results['setting'][:2]:
            #     print(vars(item))
            # for item in results['screen'][:2]:
            #     print(vars(item))


            # Reset lock for a timeout
            def reset_lock(*a):
                self.search_lock = False
                if self.search_text != self.window_input.text:
                    self.on_search()
            Clock.schedule_once(reset_lock, 0.5)


    def hide_on_unfocus(self, *a):
        if not self.window_input.focused:
            def test_hide(*a):
                if not self.dont_hide:
                    self.self_destruct(True)
            Clock.schedule_once(test_hide, 0.1)


    def on_enter(self, *a):
        top_button = self.results.children[-1]
        Animation(opacity=0, duration=0.13).start(self.results.children[0])
        Animation(opacity=0, duration=0.13).start(self.results.children[1])
        if top_button.opacity > 0:
            top_button.animate_click()
            self.dont_hide = True


    def init_search(self, *a):
        screen_name = screen_manager.current_screen.name

        # Help overrides
        if screen_name == 'MainMenuScreen':
            query = 'getting started'
        elif screen_name == 'ServerViewScreen':
            query = 'help server manager'
        elif 'Acl' in screen_name:
            query = 'help access control'
        else:
            filtered = ''.join(map(lambda x: x if x.islower() else " "+x, screen_name.replace('Screen','').replace('Server',''))).lower().strip()
            query = f'help {filtered}'
        self.on_search(force=query, fun_anim=True)


    def __init__(self, **kwargs):
        self.window_color = (0.42, 0.475, 1, 1)
        self.window_text_color = (0.78, 0.78, 1, 1)
        self.window_icon_path = os.path.join(constants.gui_assets, 'icons', 'information-circle.png')
        super().__init__(**kwargs)

        # Popup window layout
        self.window = RelativeLayout()
        self.callback = None
        self.shown = False
        self.clicked = False
        self.dont_hide = False

        self.max_results = 3
        self.search_lock = False
        self.search_text = ''

        with self.canvas.after:
            # Blurred background
            self.blur_background = Image()
            self.blur_background.opacity = 0
            self.blur_background.id = "blur_background"
            self.blur_background.source = os.path.join(constants.gui_assets, 'live', 'blur_background.png')
            self.blur_background.allow_stretch = True
            self.blur_background.keep_ratio = False
            self.generating_background = False


            # Popup window background
            self.window_background = Image(source=os.path.join(constants.gui_assets, "global_search.png"))
            self.window_background.id = "window_background"
            self.window_background.size_hint = (None, None)
            self.window_background.keep_ratio = False
            self.window_background.size = (600, 800)
            self.window_background.pos_hint = {"center_x": 0.5, "center_y": 0.5}


            # Input to type in
            self.window_input = BaseInput()
            self.window_input.__translate__ = False
            self.window_input.title_text = ""
            self.window_input.id = 'global_search_input'
            self.window_input.multiline = False
            self.window_input.size_hint_max = (600, 100)
            self.window_input.pos_hint = {"center_x": 0.5, "center_y": 0.5}
            self.window_input.padding_y = (30, 29)
            self.window_input.padding_x = (25, 25)
            self.window_input.halign = "left"
            self.window_input.hint_text_color = (0.6, 0.6, 1, 0.4)
            self.window_input.foreground_color = (0.78, 0.78, 1, 0.8)
            self.window_input.background_color = (0, 0, 0, 0)
            self.window_input.cursor_color = (0.78, 0.78, 1, 0.8)
            self.window_input.selection_color = (0.7, 0.7, 1, 0.4)
            self.window_input.cursor_width = 4
            self.window_input.font_size = sp(32)
            self.window_input.on_text_validate = self.on_enter
            self.window_input.bind(text=self.on_search)


            self.window_title = Label()
            self.window_title.id = "window_title"
            self.window_title.text = "search for anything"
            self.window_title.color = self.window_text_color
            self.window_title.font_size = sp(40)
            self.window_title.y = (self.window_background.height / 7.5)
            self.window_title.pos_hint = {"center_x": 0.5}
            self.window_title.font_name = os.path.join(constants.gui_assets,'fonts',f'{constants.fonts["bold"]}.ttf')
            self.window_title.text_size[0] = (self.window_background.size[0] * 0.7)
            self.window_title.halign = "center"
            self.window_title.shorten = True
            self.window_title.markup = True
            self.window_title.shorten_from = "right"


            # Popup window content
            self.window_content = Label()
            self.window_content.__translate__ = False
            self.window_content.id = "window_content"
            self.window_content.color = tuple([px * 1.5 if px < 1 else px for px in self.window_text_color])
            self.window_content.font_size = sp(23)
            self.window_content.line_height = 1.15
            self.window_content.halign = "center"
            self.window_content.valign = "center"
            self.window_content.text_size = (self.window_background.width - 40, self.window_background.height - 25)
            self.window_content.pos_hint = {"center_x": 0.5, "center_y": 1}
            self.window_content.font_name = os.path.join(constants.gui_assets,'fonts',f'{constants.fonts["bold"]}.ttf')


            # Results layout
            self.results = GridLayout(cols=1, spacing=30)
            self.results.id = 'search_results'
            self.results.size_hint_max = (600, 500)
            self.results.pos_hint = {'center_x': 0.5}
            self.results.y = -200

            for x in range(self.max_results):
                self.results.add_widget(self.ResultButton())


        self.add_widget(self.blur_background)
        self.window.add_widget(self.window_input)
        self.window.add_widget(self.results)
        self.window.add_widget(self.window_background)
        self.window.add_widget(self.window_title)
        self.window.add_widget(self.window_content)

        self.bind(on_touch_down=self.click_event)
        self.window_input.bind(focus=self.hide_on_unfocus)

        self.canvas.after.clear()

        self.blur_background.opacity = 0
        for widget in self.window.children:
            widget.opacity = 0

        Clock.schedule_once(self.window_input.grab_focus, 0)
        Clock.schedule_once(self.init_search, 0)



# Screen widgets
def previous_screen(*args):
    try:
        screen_manager.current = constants.screen_tree.pop(-1)
    except IndexError:
        pass
    # print(constants.screen_tree)



# Call function when any button is pressed
def button_action(button_name, button, specific_screen=''):

    # print(button_name)
    # print(button.button_pressed)

    if button.button_pressed == "left":

        if button_name.lower() == "quit":
            if not main_app.exit_check():
                exit_app()
        elif button_name.lower() == "back":
            constants.back_clicked = True
            previous_screen()
            constants.back_clicked = False

        elif "manage" in button_name.lower() and "servers" in button_name.lower():
            screen_manager.current = "ServerManagerScreen"

        # Return to main menu, prompt user if inside of progressive function
        elif "main menu" in button_name.lower():
            def return_to_main(*argies):
                screen_manager.current = 'MainMenuScreen'

            # Warn user if creating server, or updating server etc...
            if ("CreateServer" in str(screen_manager.current_screen) or "ServerImport" in str(screen_manager.current_screen)) and 'Mode' not in str(screen_manager.current_screen):
                screen_manager.current_screen.show_popup(
                    "query",
                    "Main Menu",
                    "Would you like to return to the main menu?\n\nYour progress will not be saved",
                    [None, functools.partial(Clock.schedule_once, return_to_main, 0.25)])
            else:
                return_to_main()

        elif "create a new server" in button_name.lower():
            constants.new_server_init()
            screen_manager.current = 'CreateServerModeScreen'

        elif "import a server" in button_name.lower():
            constants.new_server_init()
            screen_manager.current = 'ServerImportScreen'

        elif "create new world instead" in button_name.lower():
            break_loop = False
            for item in screen_manager.current_screen.children:
                if item.id == 'content':
                    for child_item in item.children:
                        if break_loop:
                            break
                        if child_item.__class__.__name__ == 'CreateServerWorldInput':
                            child_item.selected_world = constants.new_server_info['server_settings']['world'] = 'world'
                            child_item.update_world(force_ignore=True)
                        elif child_item.__class__.__name__ == 'ServerWorldInput':
                            child_item.selected_world = screen_manager.current_screen.new_world = 'world'
                            child_item.update_world(force_ignore=True)

        # Different behavior depending on the page
        elif "next" in button_name.lower() and not button.disabled:

            def change_screen(name, *args, **kwargs):
                screen_manager.current = name

            if screen_manager.current == 'CreateServerVersionScreen':

                def check_version(*args, **kwargs):
                    break_loop = False
                    for item in screen_manager.current_screen.children:
                        if break_loop:
                            break
                        for child_item in item.children:
                            if break_loop:
                                break
                            for child in child_item.children:

                                if child.__class__.__name__ == "NextButton":

                                    child.loading(True)
                                    version_data = constants.search_version(constants.new_server_info)
                                    constants.new_server_info['version'] = version_data[1]['version']
                                    constants.new_server_info['build'] = version_data[1]['build']
                                    constants.new_server_info['jar_link'] = version_data[3]
                                    child.loading(False)
                                    Clock.schedule_once(functools.partial(child.update_next, version_data[0], version_data[2]), 0)

                                    # Continue to next screen if valid input, and back button not pressed
                                    if version_data[0] and not version_data[2] and screen_manager.current == 'CreateServerVersionScreen':
                                        Clock.schedule_once(functools.partial(change_screen, specific_screen), 0)

                                    break_loop = True
                                    break

                timer = threading.Timer(0, function=check_version)
                timer.start()  # Checks for potential crash

            elif screen_manager.current == 'CreateServerOptionsScreen':
                if not constants.new_server_info['acl_object']:
                    while not constants.new_server_info['acl_object']:
                        time.sleep(0.2)
                change_screen(specific_screen)

            else:
                change_screen(specific_screen)

            print(constants.new_server_info)

        # Main menu reconnect button
        elif "no connection" in button_name.lower():
            try:
                constants.check_app_updates()
                constants.find_latest_mc()
            except:
                pass
            screen_manager.current_screen.reload_menu()


        elif "CreateServerNetwork" in str(screen_manager.current_screen):
            if "access control" in button_name.lower():
                if not constants.new_server_info['acl_object']:
                    while not constants.new_server_info['acl_object']:
                        time.sleep(0.2)
                screen_manager.current = 'CreateServerAclScreen'


        elif "add rules" in button_name.lower() and "CreateServerAclScreen" in str(screen_manager.current_screen):
            screen_manager.current = 'CreateServerAclRuleScreen'

        elif "add rules" in button_name.lower() and "ServerAclScreen" in str(screen_manager.current_screen):
            screen_manager.current = 'ServerAclRuleScreen'

        elif "add rules" in button_name.lower() and "ServerAclRuleScreen" in str(screen_manager.current_screen):
            screen_manager.current_screen.apply_rules()


        elif "CreateServerOptions" in str(screen_manager.current_screen) or "CreateServerAddon" in str(screen_manager.current_screen):

            # If creating a new server, use CreateServerAddonScreen
            if "add-on manager" in button_name.lower():
                screen_manager.current = 'CreateServerAddonScreen'

            elif "download" in button_name.lower():
                screen_manager.current = 'CreateServerAddonSearchScreen'

            elif "import" in button_name.lower():
                title = "Select Add-on Files (.jar)"
                selection = file_popup("file", start_dir=constants.userDownloads, ext=["*.jar"], input_name=None, select_multiple=True, title=title)

                if selection:
                    banner_text = ''
                    for addon in selection:
                        if addon.endswith(".jar") and os.path.isfile(addon):
                            addon = addons.get_addon_file(addon, constants.new_server_info)
                            constants.new_server_info['addon_objects'].append(addon)
                            screen_manager.current_screen.gen_search_results(constants.new_server_info['addon_objects'])

                            # Switch pages if page is full
                            if (len(screen_manager.current_screen.scroll_layout.children) == 0) and (len(constants.new_server_info['addon_objects']) > 0):
                                screen_manager.current_screen.switch_page("right")

                            # Show banner
                            if len(selection) == 1:
                                if len(addon.name) < 26:
                                    addon_name = addon.name
                                else:
                                    addon_name = addon.name[:23] + "..."

                                banner_text = f"Added '${addon_name}$' to the queue"
                            else:
                                banner_text = f"Added ${len(selection)}$ add-ons to the queue"

                    if banner_text:
                        Clock.schedule_once(
                            functools.partial(
                                screen_manager.current_screen.show_banner,
                                (0.553, 0.902, 0.675, 1),
                                banner_text,
                                "add-circle-sharp.png",
                                2.5,
                                {"center_x": 0.5, "center_y": 0.965}
                            ), 0
                        )


        elif "ServerAddonScreen" in str(screen_manager.current_screen):
            addon_manager = constants.server_manager.current_server.addon

            if "download" in button_name.lower():
                screen_manager.current = 'ServerAddonSearchScreen'

            elif "import" in button_name.lower():
                title = "Select Add-on Files (.jar)"
                selection = file_popup("file", start_dir=constants.userDownloads, ext=["*.jar"], input_name=None, select_multiple=True, title=title)

                if selection:
                    banner_text = ''
                    for addon in selection:
                        if addon.endswith(".jar") and os.path.isfile(addon):
                            addon = addon_manager.import_addon(addon)
                            addon_list = addon_manager.return_single_list()
                            screen_manager.current_screen.gen_search_results(addon_manager.return_single_list(), fade_in=False, highlight=addon.hash, animate_scroll=True)

                            # Switch pages if page is full
                            if (len(screen_manager.current_screen.scroll_layout.children) == 0) and (len(addon_list) > 0):
                                screen_manager.current_screen.switch_page("right")

                            # Show banner
                            if len(selection) == 1:
                                if len(addon.name) < 26:
                                    addon_name = addon.name
                                else:
                                    addon_name = addon.name[:23] + "..."

                                banner_text = f"Imported '${addon_name}$'"
                            else:
                                banner_text = f"Imported ${len(selection)}$ add-ons"

                    if banner_text:

                        # Show banner if server is running
                        if addon_manager._hash_changed():
                            Clock.schedule_once(
                                functools.partial(
                                    screen_manager.current_screen.show_banner,
                                    (0.937, 0.831, 0.62, 1),
                                    f"A server restart is required to apply changes",
                                    "sync.png",
                                    3,
                                    {"center_x": 0.5, "center_y": 0.965}
                                ), 0
                            )

                        else:
                            Clock.schedule_once(
                                functools.partial(
                                    screen_manager.current_screen.show_banner,
                                    (0.553, 0.902, 0.675, 1),
                                    banner_text,
                                    "add-circle-sharp.png",
                                    2.5,
                                    {"center_x": 0.5, "center_y": 0.965}
                                ), 0
                            )


        elif "ServerAmscriptScreen" in str(screen_manager.current_screen):
            script_manager = constants.server_manager.current_server.script_manager

            if "download" in button_name.lower():
                screen_manager.current = 'ServerAmscriptSearchScreen'

            elif "create new" in button_name.lower():
                screen_manager.current = 'CreateAmscriptScreen'

            elif "import" in button_name.lower():
                title = "Select amscripts (.ams)"
                selection = file_popup("file", start_dir=constants.userDownloads, ext=["*.ams"], input_name=None, select_multiple=True, title=title)

                if selection:
                    banner_text = ''
                    for script in selection:
                        if script.endswith(".ams") and os.path.isfile(script):
                            script = script_manager.import_script(script)
                            if not script:
                                continue

                            script_list = script_manager.return_single_list()
                            screen_manager.current_screen.gen_search_results(script_manager.return_single_list(), fade_in=False, highlight=script.hash, animate_scroll=True)

                            # Switch pages if page is full
                            if (len(screen_manager.current_screen.scroll_layout.children) == 0) and (len(script_list) > 0):
                                screen_manager.current_screen.switch_page("right")

                            # Show banner
                            if len(selection) == 1:
                                if len(script.title) < 26:
                                    script_name = script.title
                                else:
                                    script_name = script.title[:23] + "..."

                                banner_text = f"Imported '${script_name}$'"
                            else:
                                banner_text = f"Imported ${len(selection)}$ scripts"

                    if banner_text:

                        # Show banner if server is running
                        if script_manager._hash_changed():
                            Clock.schedule_once(
                                functools.partial(
                                    screen_manager.current_screen.show_banner,
                                    (0.937, 0.831, 0.62, 1),
                                    "An amscript reload is required to apply changes",
                                    "sync.png",
                                    3,
                                    {"center_x": 0.5, "center_y": 0.965}
                                ), 0
                            )

                        else:
                            Clock.schedule_once(
                                functools.partial(
                                    screen_manager.current_screen.show_banner,
                                    (0.553, 0.902, 0.675, 1),
                                    banner_text,
                                    "add-circle-sharp.png",
                                    2.5,
                                    {"center_x": 0.5, "center_y": 0.965}
                                ), 0
                            )


        elif "ServerBackupScreen" in str(screen_manager.current_screen) and "restore" in button_name.lower():
            screen_manager.current = "ServerBackupRestoreScreen"

        elif "ServerBackupScreen" in str(screen_manager.current_screen) and "download" in button_name.lower():
            screen_manager.current = "ServerBackupDownloadScreen"


        elif "CreateServerReview" in str(screen_manager.current_screen) and "create server" in button_name.lower():
            screen_manager.current = "CreateServerProgressScreen"



# =============================================== Screen Templates =====================================================
# <editor-fold desc="Screen Templates">

# Template for any screen
def save_window_pos(*args):
    if Window.width <= (constants.window_size[0] + 400):
        constants.last_window = {'pos': [Window.left, Window.top], 'size': Window.system_size}
class MenuBackground(Screen):

    reload_page = True

    def on_pre_leave(self, *args):
        super().on_pre_leave()
        if not constants.back_clicked and not self._ignore_tree:
            constants.screen_tree.append(self.__class__.__name__)

        # Close keyboard listener on current screen
        if self._keyboard:
            self._keyboard_closed()

    # Reset page on screen load
    def on_pre_enter(self, *args):

        # Ignore loading anything if server is remote and unavailable
        screen_name = self.__class__.__name__
        if screen_name.startswith('Server') and screen_name not in ['ServerManagerScreen', 'ServerImportScreen']:
            if check_telepath_disconnect():
                return True


        if self.reload_page and constants.app_loaded:
            self.reload_menu()

            # Remove popup
            if self.popup_widget:
                self.popup_widget.self_destruct(self, False)
                self.popup_widget = None
                self.canvas.after.clear()

            # Add global banner object if one exists
            def revive_banner(*args):
                if constants.global_banner:
                    if constants.global_banner.parent:
                        constants.global_banner.parent.remove_widget(constants.global_banner)
                self.banner_widget = constants.global_banner if constants.global_banner else BannerLayout()
                self.add_widget(self.banner_widget)

            Clock.schedule_once(revive_banner, 0.12)

        # Keyboard yumminess
        self._input_focused = False
        self._keyboard = Window.request_keyboard(None, self, 'text')
        self._keyboard.bind(on_key_down=self._on_keyboard_down)
        self._keyboard.bind(on_key_up=self._on_keyboard_up)


    def on_leave(self, *args):
        # Remove popup
        if self.popup_widget:
            self.popup_widget.self_destruct(self, False)
            self.popup_widget = None
            self.canvas.after.clear()

            with self.canvas.after:
                self.canvas.clear()

        if self.resize_bind:
            Window.unbind(on_resize=self.resize_bind)

        # Remove context menu
        if self.context_menu:
            self.context_menu.hide(animate=False)
            self.context_menu = None

        # Causes bug with resizing
        # for widget in self.walk():
        #     self.remove_widget(widget)
        #     del widget

        with self.canvas.after:
            self.canvas.clear()

        with self.canvas.before:
            self.canvas.clear()

        self.canvas.clear()
        self.clear_widgets()



    def reload_menu(self, *args):
        self.clear_widgets()
        self.generate_menu()


    def generate_menu(self, *args):
        pass

    # Fit background color across screen for transitions
    def update_rect(self, *args):

        # Hide context menu when screen is resized
        if self.context_menu:
            self.context_menu.hide(False)

        self.rect.pos = self.pos
        self.rect.size = self.size

        # Resize popup if it exists
        if self.popup_widget:
            self.popup_widget.resize()

        # Repos page switcher
        if self.page_switcher:
            self.page_switcher.resize_self()

        save_window_pos()

    # Ignore touch events when popup is present
    def on_touch_down(self, touch):
        if self.popup_widget:
            if self.popup_widget.window.collide_point(*touch.pos):
                return super().on_touch_down(touch)
            else:
                return
        else:
            return super().on_touch_down(touch)

    # Show popup; popup_type can be "info", "warning", "query"
    def show_popup(self, popup_type, title, content, callback=None, *args):

        # Ignore if a pop-up is already on-screen
        if self.popup_widget:
            return


        # If not, process pop-up
        popup_types = (
            "info", "warning", "query", "warning_query", "controls", "addon",
            "script", "file", "error_log"
        )
        telepath_types = ("pair_request", "pair_result")
        if self.context_menu:
            self.context_menu.hide()

        if ((popup_type == "update") or (title and content and (popup_type in popup_types or popup_type in telepath_types))) and (self == screen_manager.current_screen):

            # self.show_popup("info", "Title", "This is an info popup!", functools.partial(callback_func))
            # self.show_popup("warning", "Title", "This is a warning popup!", functools.partial(callback_func))
            # self.show_popup("query", "Title", "Yes or no?", (functools.partial(callback_func_no), functools.partial(callback_func_yes)))
            # self.show_popup("warning_query", "Title", "Yes or no?", (functools.partial(callback_func_no), functools.partial(callback_func_yes)))
            # self.show_popup("controls", "Title", "Press X to do Y", functools.partial(callback_func))
            # self.show_popup("addon", "Title", "Description", (functools.partial(callback_func_web), functools.partial(callback_func_install)), addon_object)
            # self.show_popup("script", "Title", "Description", (functools.partial(callback_func_web), functools.partial(callback_func_install)), script_object)
            # self.show_popup("update", (None, functools.partial(callback_func_install)))
            # self.show_popup("file", "Title", file_path)


            # Log for crash info
            try:
                interaction = f"PopupWidget ({popup_type}: {title})"
                constants.last_widget = interaction + f" @ {constants.format_now()}"
            except:
                pass


            with self.canvas.after:
                if popup_type == "info":
                    self.popup_widget = PopupInfo()
                elif popup_type == "warning":
                    self.popup_widget = PopupWarning()
                elif popup_type == "query":
                    self.popup_widget = PopupQuery()
                elif popup_type == "warning_query":
                    self.popup_widget = PopupWarningQuery()
                elif popup_type == "controls":
                    self.popup_widget = PopupControls()
                elif popup_type == "addon":
                    self.popup_widget = PopupAddon(addon_object=args[0])
                    try:
                        self.popup_widget.window_content
                    except AttributeError:
                        title = args[0].args[0].name[0:30]
                        content = "There is no data available for this add-on"
                        callback = None
                        self.popup_widget = PopupWarning()
                elif popup_type == "script":
                    self.popup_widget = PopupScript(script_object=args[0])
                    try:
                        self.popup_widget.window_content
                    except AttributeError:
                        title = args[0].args[0].name[0:30]
                        content = "There is no data available for this script"
                        callback = None
                        self.popup_widget = PopupWarning()
                elif popup_type == "update":
                    self.popup_widget = PopupUpdate()
                    title = ""
                    content = ""
                elif popup_type == "file":
                    self.popup_widget = PopupFile()
                    Clock.schedule_once(functools.partial(self.popup_widget.set_text, content), 0)
                elif popup_type == "error_log":
                    self.popup_widget = PopupErrorLog()

                # Telepath pop-ups
                elif popup_type == "pair_request":
                    self.popup_widget = PopupTelepathPair(prompt=True)
                elif popup_type == "pair_result":
                    self.popup_widget = PopupTelepathPair()

            self.popup_widget.generate_blur_background()

            if popup_type not in telepath_types:
                if title.strip():
                    self.popup_widget.window_title.text = title

                if content.strip():
                    self.popup_widget.window_content.text = content

            self.popup_widget.callback = callback

            def show(*argies):
                self.add_widget(self.popup_widget)
                self.popup_widget.resize()
                self.popup_widget.animate(True)

            if self.popup_widget.window_sound:
                # Fix popping sound when sounds are played
                try:
                    self.popup_widget.window_sound.play()
                except:
                    pass
            Clock.schedule_once(show, 0.3)

    # Show global search bar
    def show_search(self):

        if "ProgressScreen" in self.__class__.__name__:
            return

        if "BlurredLoadingScreen" in self.__class__.__name__:
            return

        if self.context_menu:
            self.context_menu.hide()

        # Log for crash info
        try:
            interaction = f"PopupWidget (GlobalSearch)"
            constants.last_widget = interaction + f" @ {constants.format_now()}"
        except:
            pass

        with self.canvas.after:
            self.popup_widget = PopupSearch()

        self.popup_widget.generate_blur_background()

        def show(*argies):
            self.add_widget(self.popup_widget)
            self.popup_widget.resize()
            self.popup_widget.animate(True)

        Clock.schedule_once(show, 0)

    # Show a context menu when clicking on certain elements
    def show_context_menu(self, widget, options_list):
        if not self.popup_widget:

            def show(*a):
                if not self.context_menu:
                    self.context_menu = ContextMenu()
                    self.add_widget(self.context_menu)
                self.context_menu.show(widget, options_list)

            if self.context_menu:
                if self.context_menu.widget != widget:
                    self.context_menu.hide()
                    widget.on_enter()
                    Clock.schedule_once(show, 0.15)
                    return None

            show()




    # Show banner; pass in color, text, icon name, and duration
    @staticmethod
    def show_banner(color, text, icon, duration=5, pos_hint={"center_x": 0.5, "center_y": 0.895}, play_sound=None, *args):

        # Base banner layout
        banner_layout = BannerLayout()
        banner_size = (800, 47)

        # Banner
        banner_object = BannerObject(
            pos_hint = pos_hint,
            size = banner_size,
            color = color,
            text = text,
            icon = icon,
            animate = True
        )

        # Banner drop shadow
        banner_shadow = Image()
        banner_shadow.source = os.path.join(constants.gui_assets, 'banner_shadow.png')
        banner_shadow.keep_ratio = False
        banner_shadow.allow_stretch = True
        banner_shadow.size_hint_max = (banner_size[0] + 150, banner_size[1] * 2)
        banner_shadow.pos_hint = pos_hint
        banner_shadow.opacity = 0
        Animation(opacity=1, duration=0.5).start(banner_shadow)

        # Banner progress bar
        banner_progress_bar = Image()
        banner_progress_bar.source = os.path.join(constants.gui_assets, 'banner_progress_bar.png')
        banner_progress_bar.keep_ratio = False
        banner_progress_bar.allow_stretch = True
        banner_progress_bar.size_hint_max = (banner_size[0] - (banner_object.left_side.width * 2), banner_size[1])
        banner_progress_bar.color = (0, 0, 0, 1)
        banner_progress_bar.pos_hint = pos_hint
        banner_progress_bar.opacity = 0
        Animation(opacity=0.25, duration=0.5).start(banner_progress_bar)
        Animation(size_hint_max=(0, banner_size[1]), duration=duration).start(banner_progress_bar)

        banner_layout.add_widget(banner_shadow)
        banner_layout.add_widget(banner_object)
        banner_layout.add_widget(banner_progress_bar)

        # Remove banner if it already exists
        if constants.global_banner:
            if constants.global_banner.parent:
                constants.hide_widget(constants.global_banner)
                constants.global_banner.parent.remove_widget(constants.global_banner)

        screen_manager.current_screen.banner_widget = banner_layout
        constants.global_banner = banner_layout

        screen_manager.current_screen.add_widget(screen_manager.current_screen.banner_widget)

        # Deletes banner object after duration
        def hide_banner(widget, *args):
            try:
                if constants.global_banner.id == widget.id:

                    if constants.global_banner:
                        if constants.global_banner.parent:
                            constants.global_banner.parent.remove_widget(constants.global_banner)

                    constants.global_banner = None
                    for screen in screen_manager.children:
                        screen.banner_widget = None

            # Ignore crash if screen was rapidly changed
            except AttributeError:
                pass

        def hide_widgets(shadow, progress_bar, *args):
            Animation(opacity=0, duration=0.5).start(shadow)
            Animation(opacity=0, duration=0.1).start(progress_bar)


        Clock.schedule_once(functools.partial(banner_object.show_animation, False), duration)
        Clock.schedule_once(functools.partial(hide_widgets, banner_shadow, banner_progress_bar), duration)
        Clock.schedule_once(functools.partial(hide_banner, banner_layout), duration + 0.32)

        if play_sound:
            try:
                sa.WaveObject.from_wave_file(os.path.join(constants.gui_assets, 'sounds', play_sound)).play()
            except:
                pass


    # Keyboard listeners
    def _keyboard_closed(self):
        # print('Keyboard has been closed')
        self._keyboard.unbind(on_key_down=self._on_keyboard_down)
        self._keyboard = None

    def _reset_shift_counter(self, *args):
        self._shift_press_count = 0
        self._shift_timer = None

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        # print('The key', keycode, 'have been pressed')
        # print(' - text is %r' % text)
        # print(' - modifiers are %r' % modifiers)

        # Ignore key presses when popup is visible
        if self.popup_widget:

            # Override for PopupSearch
            if self.popup_widget.__class__.__name__ == 'PopupSearch':
                if keycode[1] == 'escape':
                    self.popup_widget.self_destruct(True)
                elif keycode[1] == 'backspace' or ('shift' in modifiers and text and not text.isalnum()):
                    self.popup_widget.resize_window()
                elif control not in modifiers and text and self.popup_widget.window_input.keyboard:

                    def insert_text(content):
                        col = self.popup_widget.window_input.cursor_col
                        start = self.popup_widget.window_input.text[:col]
                        end = self.popup_widget.window_input.text[col:]
                        self.popup_widget.window_input.text = start + content + end
                        for x in range(len(content)):
                            Clock.schedule_once(functools.partial(self.popup_widget.window_input.do_cursor_movement, 'cursor_right', True), 0)

                    new_str = self.popup_widget.window_input.keyboard.keycode_to_string(keycode[0])
                    if 'shift' in modifiers:
                        new_str = new_str.upper()
                    if len(new_str) == 1:
                        insert_text(new_str)
                    elif keycode[1] == 'spacebar':
                        insert_text(' ')
                    self.popup_widget.resize_window()
                else:
                    self.popup_widget.resize_window()
                return True

            if keycode[1] in ['escape', 'n']:
                try:
                    self.popup_widget.click_event(self.popup_widget, 'no')
                except AttributeError:
                    self.popup_widget.click_event(self.popup_widget, 'ok')

            elif keycode[1] in ['enter', 'return', 'y']:
                try:
                    self.popup_widget.click_event(self.popup_widget, 'yes')
                except AttributeError:
                    self.popup_widget.click_event(self.popup_widget, 'ok')
            return


        # Trigger for showing search bar
        elif keycode[1] == 'shift':
            if not self._shift_held:
                self._shift_held = True
                self._shift_press_count += 1

                if self._shift_timer:
                    self._shift_timer.cancel()

                # Check for double tap
                if self._shift_press_count == 2:
                    self.show_search()
                    self._shift_press_count = 0

                # Otherwise, reset the timer
                else:
                    self._shift_timer = Clock.schedule_once(self._reset_shift_counter, 0.25)  # Adjust time as needed
            return True


        # Quit on macOS
        elif constants.os_name == 'macos' and (keycode[1] == 'q' and control in modifiers):
            if not main_app.exit_check():
                exit_app()


        # Ignore ESC commands while input focused
        if not self._input_focused and self.name == screen_manager.current_screen.name:

            # Keycode is composed of an integer + a string
            # If we hit escape, release the keyboard
            # On ESC, click on back button if it exists
            if keycode[1] == 'escape' and 'escape' not in self._ignore_keys:

                if self.context_menu:
                    self.context_menu.hide()

                else:
                    for button in self.walk():
                        try:
                            if button.id == "exit_button":
                                button.force_click()
                                break
                        except AttributeError:
                            continue
                keyboard.release()


            # Click next button if it's not disabled
            if keycode[1] == 'enter' and 'enter' not in self._ignore_keys:
                for button in self.walk():
                    try:
                        if button.id == "next_button" and button.disabled is False:
                            button.force_click()
                            break
                    except AttributeError:
                        continue
                keyboard.release()


        # # On TAB/Shift+TAB, cycle through elements
        # if keycode[1] == 'tab' and 'tab' not in self._ignore_keys:
        #     pass
        #     # for widget in self.walk():
        #     #     try:
        #     #         if "button" in widget.id or "input" in widget.id:
        #     #             print(widget)
        #     #             break
        #     #     except AttributeError:
        #     #         continue


        # Crash test
        # if keycode[1] == 'z' and control in modifiers:
        #     crash = float("crash")


        # Return True to accept the key. Otherwise, it will be used by the system.
        return True

    def _on_keyboard_up(self, window, keycode):
        if keycode[1] == 'shift':
            self._shift_held = False  # Mark Shift as released

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # Screen won't get added to screen tree on leave
        self._ignore_tree = False

        self.banner_widget = None
        self.popup_widget = None
        self.page_switcher = None
        self.context_menu = None

        self._input_focused = False
        self._keyboard = None
        self._shift_press_count = 0
        self._shift_timer = None
        self._shift_held = False
        self.background_color = constants.background_color

        # Add keys to override in child windows
        self._ignore_keys = []

        with self.canvas.before:
            self.color = Color(*constants.background_color, mode='rgba')
            self.rect = Rectangle(pos=self.pos, size=self.size)

        with self.canvas.after:
            self.canvas.clear()

        self.bind(pos=self.update_rect)
        self.bind(size=self.update_rect)

        self.resize_bind = None
        self.popup_bind = None


# Template for loading/busy screens
class ProgressWidget(RelativeLayout):

    # Value: 0-100
    def update_progress(self, value, *args):

        value = 0 if value < 0 else 100 if value > 100 else int(round(value))

        if self.value == value:
            return

        self.value = value

        anim_duration = 0.7
        adjusted_value = (self.value*0.01) if self.value != 99 else 0.98

        new_width = (self.size_hint_max[0] * (1 - adjusted_value))
        new_x = (self.size_hint_max[0] - new_width)
        Animation.stop_all(self.cover)
        Animation.stop_all(self.percentage)

        # Funny text animation
        diff = self.value - int(self.percentage.text.replace("%", ""))
        def update_text(*args):
            yummy = int(round(anim_duration*10))
            if diff > 5:
                new_value = int(self.percentage.text.replace("%", "")) + round((diff // yummy))
                for num in range(1, yummy):
                    if new_value > self.value:
                        break
                    new_value = new_value + round((diff // yummy))
                    self.percentage.text = str(new_value) + "%"
                    time.sleep(0.1)
            self.percentage.text = str(self.value) + "%"

        original_text = self.percentage.text
        self.percentage.text = str(self.value) + "%"
        if diff > 5:
            Clock.schedule_once(self.percentage.texture_update, -1)
        self.percentage.size_hint_max = self.percentage.texture_size
        self.percentage.text = original_text

        # Actually animate schennanies LOL fuck kivy holy shit
        def anim(*args):

            thread = threading.Timer(0, update_text)
            thread.start()

            text_x = new_x if self.value == 0 else (new_x - self.percentage.width / 2)
            if text_x < self.rail.x:
                text_x = self.rail.x
            overshoot = (new_x + (self.percentage.width / 1.5)) - self.size_hint_max[0]
            if overshoot > 0:
                text_x -= overshoot

            # print(text_x, self.percentage.text, self.percentage.texture_size)

            Animation(x=text_x, duration=anim_duration, transition='out_sine').start(self.percentage)
            Animation(size_hint_max_x=new_width, x=new_x, duration=anim_duration, transition='out_sine').start(self.cover)

            if value == 100:
                def make_green(*args):
                    green = (0.3, 1, 0.6, 1)
                    new_dur = 0.2
                    for widget in [self.bar, self.rail, self.cover]:
                        Animation(opacity=0, duration=new_dur).start(widget)
                    Animation(opacity=1, duration=new_dur, color=green).start(self.static_bar)
                    Animation(color=green, duration=new_dur).start(self.percentage)
                Clock.schedule_once(make_green, 0 if diff < 3 else anim_duration-0.1)

        Clock.schedule_once(anim, 0)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.size_hint_max = (540, 28)
        self.value = 0

        # Frame of progress bar
        self.rail = Image()
        self.rail.allow_stretch = True
        self.rail.keep_ratio = False
        self.rail.source = os.path.join(constants.gui_assets, 'progress_bar_empty.png')

        # Cover of progress bar (to simulate horizontal movement)
        self.cover = Image()
        self.cover.allow_stretch = True
        self.cover.keep_ratio = False
        self.cover.size_hint_max_x = self.size_hint_max_x
        self.cover.color = constants.background_color
        self.cover.pos_hint = {'center_y': 0.5}

        # Fake shading to change the depth
        self.shadow = Image()
        self.shadow.allow_stretch = True
        self.shadow.keep_ratio = False
        self.shadow.size_hint_max_x = self.size_hint_max_x
        self.shadow.color = constants.background_color
        self.shadow.opacity = 0.1
        self.shadow.size_hint_max_y = self.size_hint_max_y / 2
        self.shadow.y = self.y

        # Progress bar animation
        self.bar = Image()
        self.bar.allow_stretch = True
        self.bar.keep_ratio = False
        self.bar.source = os.path.join(constants.gui_assets, 'animations', 'bar_full.gif')
        self.bar.anim_delay = 0.025

        # Progress bar Static
        self.static_bar = Image()
        self.static_bar.allow_stretch = True
        self.static_bar.keep_ratio = False
        self.static_bar.source = os.path.join(constants.gui_assets, 'progress_bar_full.png')
        self.static_bar.color = (0.58, 0.6, 1, 1)
        self.static_bar.opacity = 0

        # Percentage text
        self.percentage = Label()
        self.percentage.__translate__ = False
        self.percentage.text = "0%"
        self.percentage.font_name = os.path.join(constants.gui_assets, 'fonts', constants.fonts['medium'])
        self.percentage.font_size = sp(19)
        self.percentage.color = (0.58, 0.6, 1, 1)
        self.percentage.opacity = 1
        def align_label(*args):
            self.percentage.texture_update()
            self.percentage.size_hint_max = self.percentage.texture_size
            self.percentage.y = self.rail.y + 31
            self.percentage.texture_update()
        Clock.schedule_once(align_label, -1)


        self.add_widget(self.bar)
        self.add_widget(self.static_bar)
        self.add_widget(self.cover)
        self.add_widget(self.rail)
        self.add_widget(self.percentage)
        self.add_widget(self.shadow)

        self.update_progress(self.value)

class ProgressScreen(MenuBackground):

    # Returns current progress bar value
    def get_progress(self):
        return self.progress_bar.value

    # Only replace this function when making a child screen
    # Set fail message in child functions to trigger an error
    def contents(self):
        def sleep(delay: float or int):
            time.sleep(delay)
            return True

        self.page_contents = {

            # Page name
            'title': "Progress Screen",

            # Header text
            'header': "Sit back and relax, it's automation time",

            # Tuple of tuples for steps (label, function, percent)
            # Percent of all functions must total 100
            # Functions must return True, or default error will be executed
            'default_error': 'There was an issue, please try again later',

            'function_list': (
                ('Step 1', functools.partial(sleep, 3), 30),
                ('Step 2', functools.partial(sleep, 3), 30),
                ('Step 3', functools.partial(sleep, 0.1), 30),
                ('Step 4', functools.partial(sleep, 0.1), 10)
            ),

            # Function to run before steps (like checking for an internet connection)
            'before_function': functools.partial(sleep, 0),

            # Function to run after everything is complete (like cleaning up the screen tree) will only run if no error
            'after_function': functools.partial(sleep, 0),

            # Screen to go to after complete
            'next_screen': 'MainMenuScreen'
        }


    # Check if there's a telepath client or server, and if it's using a blocking action
    def _check_telepath(self):
        server_obj = constants.server_manager.current_server

        try:
            if constants.telepath_busy():
                self.execute_error('A critical operation is currently running through a $Telepath$ session.\n\nPlease try again later', reset_close=False)
                return True

            elif self._telepath_override == '$local':
                self.telepath = None
            elif self._telepath_override:
                self.telepath = self._telepath_override

            elif server_obj and server_obj._telepath_data:
                self.telepath = server_obj._telepath_data

            elif '_telepath_data' in constants.new_server_info and constants.new_server_info['_telepath_data']:
                self.telepath = constants.deepcopy(constants.new_server_info['_telepath_data'])

            if self.telepath:
                self.telepath['server-name'] = server_obj.name
                host = self.telepath['nickname'] if self.telepath['nickname'] else self.telepath['host']
                if not server_obj.progress_available():
                    self.execute_error(f"A critical operation is currently running locally on '${host}$'.\n\nPlease try again later", reset_close=False)
                    return True

        except AttributeError:
            return False

        return False

    def allow_close(self, allow: bool):
        if self.telepath:
            banner = f'$Telepath$ action {"finished" if allow else "started"}: {self.page_contents["title"]}'
            constants.api_manager.request(
                endpoint='/main/allow_close',
                host=self.telepath['host'],
                port=self.telepath['port'],
                args={'allow': allow, 'banner': banner}
            )
        else:
            constants.allow_close(allow)

    def open_server(self, *args, **kwargs):
        if self.telepath:
            open_remote_server(self.telepath, *args, **kwargs)
        else:
            open_server(*args, **kwargs)


    def execute_steps(self):

        # Before doing anything, check telepath data to prevent issues with concurrency
        if self._check_telepath():
            return

        icons = os.path.join(constants.gui_assets, 'fonts', constants.fonts['icons'])

        self.allow_close(False)

        # Execute before function
        if self.page_contents['before_function']:
            self.steps.label_2.text = "Initializing, please wait..."
            self.page_contents['before_function']()
            if self.error:
                return

        # Go over every step in function_list
        for x, step in enumerate(self.page_contents['function_list']):

            # Close thread if error occurred
            if self.error:
                return

            if x != 0:
                if "[font=" not in self.steps.label_2.text:
                    self.steps.label_2.text = self.steps.label_2.text.split('(')[0].strip() + f"   [font={icons}]Ã¥[/font]"
                time.sleep(0.4)
            self.update_steps(step[0], x)

            # Execute function and check for completion
            self.last_progress = self.progress_bar.value
            exception = None
            crash_log = None
            try:
                test = step[1]()

            # On error, log it and prompt user to open it
            except Exception as e:
                exception = e
                error_info = f"'{screen_manager.current_screen.name}' failed on step {x+1}: {step[0]}"

                crash_log = crashmgr.generate_log(traceback.format_exc(), error_info=error_info)
                test = False

                print(error_info)
                traceback.print_exc()

            time.sleep(0.2)

            # If it failed, execute default error
            if not test:
                self.execute_error(self.page_contents['default_error'], exception=exception, log_data=crash_log)
                return

            self.progress_bar.update_progress(self.progress_bar.value + step[2])

        # Execute after_function
        time.sleep(0.5)
        def test(*a):
            if "[font=" not in self.steps.label_2.text:
                self.steps.label_2.text = self.steps.label_2.text.split('(')[0].strip() + f"   [font={icons}]Ã¥[/font]"
        Clock.schedule_once(test, 0)
        # time.sleep(0.19)
        Animation(color=(0.3, 1, 0.6, 1), duration=0.2, transition='out_sine').start(self.steps.label_2)

        # Execute after function on if there was no error
        if self.page_contents['after_function'] and not self.error:
            self.page_contents['after_function']()

        # Switch to next_page after it's done
        self.allow_close(True)
        if not self.error and self.page_contents['next_screen']:
            def next_screen(*args):
                constants.back_clicked = True
                screen_manager.current = self.page_contents['next_screen']
                constants.back_clicked = False
            Clock.schedule_once(next_screen, 0.8)


    def execute_error(self, msg, reset_close=True, exception=None, log_data=None, *args):
        if reset_close:
            self.allow_close(True)
        self.error = True

        if exception:
            msg = f'{msg}\n\n{exception}'

        def close(*args):
            Clock.schedule_once(previous_screen, 0.25)
            self.error = False
            self.timer = None

        def function(*args):
            self.timer.cancel()

            if self._error_callback:
                self._error_callback()

            if log_data:
                print(log_data)
                title = f'Error: {log_data[0]}'
                log_path = log_data[1]
                def open_log():
                    view_file(log_path, title)
                    close()
                self.show_popup('error_log', 'Error', msg, (close, open_log))

            else:
                self.show_popup('warning', 'Error', msg, (close))

        Clock.schedule_once(function, 0)


    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'

        self._ignore_tree = True
        self._error_callback = None
        self._telepath_override = None
        self.telepath = None

        self.title = None
        self.footer = None
        self.progress_bar = None
        self.steps = None
        self.timer = None
        self.error = False
        self.start = False
        self.last_progress = 0

        self.page_contents = None


    def update_steps(self, current, num):

        print(f"Progress {current} {num}")

        icons = os.path.join(constants.gui_assets, 'fonts', constants.fonts['icons'])
        yummy_label = f"   ({num+1}/{len(self.page_contents['function_list'])})"
        end_label = f"{len(self.page_contents['function_list'])})"

        Animation.stop_all(self.steps.label_1)
        Animation.stop_all(self.steps.label_2)
        Animation.stop_all(self.steps.label_3)
        Animation.stop_all(self.steps.label_4)
        self.steps.label_1.y = self.steps.label_1.original_y
        self.steps.label_2.y = self.steps.label_2.original_y
        self.steps.label_3.y = self.steps.label_3.original_y
        self.steps.label_4.y = self.steps.label_4.original_y

        if len(self.page_contents['function_list']) == 1:
            self.steps.label_2.text = current
        else:
            anim_duration = 0.5 if self.start else 0

            if "[font=" not in self.steps.label_2.text and self.steps.label_2.text:
                self.steps.label_2.text = constants.translate(self.steps.label_2.text.split('(')[0].strip()) + f"   [font={icons}]Ã¥[/font]"
            Animation(opacity=0.3, duration=0.2 if self.start else 0, transition='out_sine').start(self.steps.label_1)
            Animation(opacity=0.3, duration=0.2 if self.start else 0, transition='out_sine').start(self.steps.label_2)
            Animation(opacity=0.3, duration=0.2 if self.start else 0, transition='out_sine').start(self.steps.label_3)
            Animation(opacity=0.3, duration=0.2 if self.start else 0, transition='out_sine').start(self.steps.label_4)

            if num != 0:
                if not self.steps.label_3.text.endswith(end_label) and self.steps.label_3.text:
                    self.steps.label_3.text += yummy_label
                Animation(y=self.steps.label_1.y + (self.steps.size_hint_max[1] / 2), duration=anim_duration, transition='out_sine').start(self.steps.label_1)
                Animation(y=self.steps.label_2.y + (self.steps.size_hint_max[1] / 2), duration=anim_duration, transition='out_sine').start(self.steps.label_2)
                Animation(y=self.steps.label_3.y + (self.steps.size_hint_max[1] / 2), opacity=1, duration=anim_duration, transition='out_sine').start(self.steps.label_3)
                Animation(y=self.steps.label_4.y + (self.steps.size_hint_max[1] / 2), duration=anim_duration, transition='out_sine').start(self.steps.label_4)
            else:
                Animation.stop_all(self.steps.label_2)
                self.steps.label_2.opacity = 1

            def delayed_func(*args):
                if num != 0:
                    # Label 1
                    try:
                        self.steps.label_1.text = self.page_contents['function_list'][num-1][0]
                        if "[font=" not in self.steps.label_1.text and self.steps.label_1.text:
                            self.steps.label_1.text += f"   [font={icons}]Ã¥[/font]"
                        self.steps.label_1.opacity = 0.3
                    except IndexError:
                        pass
                    self.steps.label_1.y = self.steps.label_1.original_y


                # Label 2
                try:
                    self.steps.label_2.text = constants.translate(current) + yummy_label
                    self.steps.label_2.opacity = 1
                except IndexError:
                    pass
                self.steps.label_2.y = self.steps.label_2.original_y


                # Label 3
                try:
                    self.steps.label_3.text = self.page_contents['function_list'][num+1][0]
                    self.steps.label_3.opacity = 0.3
                except IndexError:
                    self.steps.label_3.text = ""
                self.steps.label_3.y = self.steps.label_3.original_y


                # Label 4
                try:
                    self.steps.label_4.text = self.page_contents['function_list'][num+2][0]
                    self.steps.label_4.opacity = 0.3
                except IndexError:
                    self.steps.label_4.text = ""
                self.steps.label_4.y = self.steps.label_4.original_y

            Clock.schedule_once(delayed_func, anim_duration+0.2 if self.start else 0)
            self.start = True


    def generate_menu(self, **kwargs):
        # Generate buttons on page load
        self.contents()
        self.start = False
        self.telepath = None
        self.last_progress = 0

        float_layout = FloatLayout()
        float_layout.id = 'content'

        float_layout.add_widget(HeaderText(self.page_contents['header'], '', (0, 0.8)))

        self.progress_bar = ProgressWidget(pos_hint={'center_x': 0.5, 'center_y': 0.6})

        self.title = generate_title(self.page_contents['title'])


        # Yummy animated steps text
        class StepLabel(Label):
            def __init__(self, **kwargs):
                super().__init__(**kwargs)
                self.text = ""
                self.font_name = os.path.join(constants.gui_assets, 'fonts', constants.fonts['medium'])
                self.font_size = sp(25)
                self.markup = True
                self.color = (0.6, 0.6, 1, 1)
                self.opacity = 1
                self.original_y = 0
        self.steps = RelativeLayout()
        self.steps.size_hint_max = (150, 150)
        self.steps.pos_hint = {'center_x': 0.5, 'center_y': 0.25}
        self.steps.label_1 = StepLabel()
        self.steps.label_1.original_y = self.steps.label_1.y = self.steps.size_hint_max[1]
        self.steps.label_2 = StepLabel()
        self.steps.label_2.original_y = self.steps.label_2.y = self.steps.size_hint_max[1] / 2
        self.steps.label_3 = StepLabel()
        self.steps.label_3.original_y = self.steps.label_3.y = 0
        self.steps.label_4 = StepLabel()
        self.steps.label_4.original_y = self.steps.label_4.y = 0 - (self.steps.size_hint_max[1] / 2)
        self.steps.scroll_top = scroll_background(pos_hint={'center_x': 0.5}, pos=(0, self.steps.size_hint_max[1] * 1.7), size=(Window.width // 1.5, 60))
        self.steps.scroll_bottom = scroll_background(pos_hint={'center_x': 0.5}, pos=(0, (self.steps.size_hint_max[1] / 3.5)), size=(Window.width // 1.5, -60))
        self.steps.add_widget(self.steps.label_1)
        self.steps.add_widget(self.steps.label_2)
        self.steps.add_widget(self.steps.label_3)
        self.steps.add_widget(self.steps.label_4)
        self.steps.add_widget(self.steps.scroll_top)
        self.steps.add_widget(self.steps.scroll_bottom)


        # Change footer icon to loading pickaxe, remove home button
        # Also prevent window from being closed during operations
        self.footer = generate_footer(self.page_contents['title'] + '...', progress_screen=True)

        float_layout.add_widget(self.title)
        float_layout.add_widget(self.footer)
        float_layout.add_widget(self.steps)
        float_layout.add_widget(self.progress_bar)

        self.add_widget(float_layout)

        self.timer = threading.Timer(0, self.execute_steps)
        self.timer.start()

# Blurred loading screen for blocking operations
class BlurredLoadingScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self._ignore_tree = True

        self.generating_background = False
        self.blur_background = None
        self.load_icon = None
        self.load_label = None

    def generate_blur_background(self, *args):
        image_path = os.path.join(constants.gui_assets, 'live', 'blur_background.png')
        constants.folder_check(os.path.join(constants.gui_assets, 'live'))

        if not self.generating_background:
            self.generating_background = True
            self.blur_background.opacity = 0

            screen_manager.get_screen(constants.screen_tree[-1]).export_to_png(image_path)
            im = PILImage.open(image_path)
            im = ImageEnhance.Brightness(im)
            im = im.enhance(popup_blur_darkness)
            im1 = im.filter(GaussianBlur(popup_blur_amount))
            im1.save(image_path)
            self.blur_background.reload()

            self.blur_background.opacity = 1

    def on_pre_enter(self, *args):
        super().on_pre_enter()
        constants.ignore_close = True

    def on_leave(self, *args):
        super().on_leave()
        constants.ignore_close = False

    def resize_self(self, *args):
        self.load_label.x = (Window.width / 2) - 75
        self.load_icon.x = (Window.width / 2) - 160


    def generate_menu(self, **kwargs):
        # Generate buttons on page load

        float_layout = FloatLayout()
        float_layout.id = 'content'

        # Blurred background
        self.blur_background = Image()
        self.blur_background.opacity = 0
        self.blur_background.id = "blur_background"
        self.blur_background.source = os.path.join(constants.gui_assets, 'live', 'blur_background.png')
        self.blur_background.allow_stretch = True
        self.blur_background.keep_ratio = False
        self.generating_background = False
        float_layout.add_widget(self.blur_background)
        Clock.schedule_once(self.generate_blur_background, -1)


        # Loading icon to swap button
        self.load_icon = AsyncImage()
        self.load_icon.id = "load_icon"
        self.load_icon.source = os.path.join(constants.gui_assets, 'animations', 'loading_pickaxe.gif')
        self.load_icon.size_hint_max = (65, 65)
        self.load_icon.color = (0.8, 0.8, 1, 1)
        self.load_icon.pos_hint = {"center_y": 0.5}
        self.load_icon.allow_stretch = True
        self.load_icon.anim_delay = constants.anim_speed * 0.02
        float_layout.add_widget(self.load_icon)


        # Loading label
        self.load_label = AlignLabel()
        self.load_label.halign = 'left'
        self.load_label.valign = 'center'
        self.load_label.id = 'label'
        self.load_label.size_hint_max = (300, 50)
        self.load_label.pos_hint = {"center_y": 0.5}
        self.load_label.text = 'please wait...'
        self.load_label.font_size = sp(35)
        self.load_label.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["bold"]}.ttf')
        self.load_label.color = (0.8, 0.8, 1, 1)
        float_layout.add_widget(self.load_label)


        self.blur_background.size_hint_min = Window.size
        float_layout.bind(pos=self.resize_self, size=self.resize_self)

        self.add_widget(float_layout)


# </editor-fold> ///////////////////////////////////////////////////////////////////////////////////////////////////////




# ================================================== Main Menu =========================================================
# <editor-fold desc="Main Menu">
shown_disk_error = False
class MainMenuScreen(MenuBackground):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.loaded = False
        self.settings_bar = None

    # Prompt update/show banner when starting up
    def on_enter(self, *args):
        global shown_disk_error


        # Show warning if running with elevated permissions, and flag is used
        if constants.is_admin() and constants.bypass_admin_warning:
            def admin_error(*_):
                self.show_popup(
                    "warning",
                    "Privilege Warning",
                    f"Running auto-mcs as ${'administrator' if constants.os_name == 'windows' else 'root'}$ can expose your system to security vulnerabilities.\n\nProceed with caution, this configuration is unsupported",
                    None
                )
            Clock.schedule_once(admin_error, 0.5)
            return


        # Close if running with elevated permissions, and flag is not used
        elif constants.is_admin():
            def admin_error(*_):
                self.show_popup(
                    "warning",
                    "Privilege Error",
                    f"Running auto-mcs as ${'administrator' if constants.os_name == 'windows' else 'root'}$ can expose your system to security vulnerabilities.\n\nPlease restart with standard user privileges to continue",
                    Window.close
                )
            Clock.schedule_once(admin_error, 0.5)
            return


        # Close on macOS when it's running in DMG
        elif constants.os_name == 'macos' and (constants.launch_path.startswith('/Volumes/') and constants.app_title in constants.launch_path):
            def dmg_error(*_):
                self.show_popup(
                    "warning",
                    "Permission Error",
                    f"Please move $auto-mcs$ to the Applications folder to continue",
                    Window.close
                )
            Clock.schedule_once(dmg_error, 0.5)
            return


        # Show warning when disk is full
        elif not constants.check_free_space() and not shown_disk_error:
            shown_disk_error = True
            def disk_error(*_):
                self.show_popup(
                    "warning",
                    "Storage Error",
                    "auto-mcs has limited functionality from low disk space. Further changes can lead to corruption in your servers.\n\nPlease free up space on your disk to minimize issues",
                    None
                )
            Clock.schedule_once(disk_error, 0.5)


        if constants.update_data['reboot-msg']:
            message = constants.update_data['reboot-msg']
            fail = message[0] == "banner-failure"
            Clock.schedule_once(
                functools.partial(
                    self.show_banner,
                    (1, 0.5, 0.65, 1) if fail else (0.553, 0.902, 0.675, 1),
                    message[1],
                    "close-circle-sharp.png" if fail else "checkmark-circle-sharp.png",
                    3,
                    {"center_x": 0.5, "center_y": 0.965}
                ), 0.1
            )
            constants.update_data['reboot-msg'] = []
            constants.update_data['auto-show'] = False
        else:
            Clock.schedule_once(functools.partial(self.prompt_update, False), 0.5)

    def prompt_update(self, force=False, *args):

        if (not constants.app_latest) and (constants.update_data['auto-show']) or force:

            # Installs update and restarts
            def install_update(*a):
                def change_screen(*b):
                    screen_manager.current = 'UpdateAppProgressScreen'
                check_running(change_screen)

            if constants.app_online:
                self.show_popup("update", title=None, content=None, callback=(None, install_update))
            constants.update_data['auto-show'] = False

    def open_donate(self, *a):
        if constants.app_online:
            url = "https://www.auto-mcs.com/about-us"
            webbrowser.open_new_tab(url)

    def generate_menu(self, **kwargs):
        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()

        constants.screen_tree = []
        constants.generate_server_list()

        splash = FloatLayout()

        logo = Image(source=os.path.join(constants.gui_assets, 'title.png'), allow_stretch=True, size_hint=(None, None), width=dp(550), pos_hint={"center_x": 0.5, "center_y": 0.77})
        splash.add_widget(logo)

        anim_logo = Image(
            source=os.path.join(constants.gui_assets, 'animations', 'animated_logo.gif'),
            allow_stretch=True,
            size_hint=(None, None),
            width=dp(550),
            pos_hint={"center_x": 0.5, "center_y": 0.77},
            anim_loop=1,
            anim_delay=constants.anim_speed * 0.02
        )
        splash.add_widget(anim_logo)


        version_text = f"{constants.app_version}{' (dev)' if constants.dev_version else ''}"
        color = "#FF8793" if constants.is_admin() else (0.6, 0.6, 1, 0.5)
        version = Label(pos=(330, 200), pos_hint={"center_y": 0.77}, color=color, font_name=os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf'), font_size=sp(23))
        version.__translate__ = False
        version.text = f"v{version_text}{(7 - len(version_text)) * '  '}"
        splash.add_widget(version)

        seperator = Label(pos_hint={"center_y": 0.7}, color=(0.6, 0.6, 1, 0.1), font_name=os.path.join(constants.gui_assets, 'fonts', 'LLBI.otf'), font_size=sp(25))
        seperator.__translate__ = False
        seperator.text = "_" * 50
        splash.add_widget(seperator)

        session_splash = Label(pos_hint={"center_y": 0.65}, color=(0.6, 0.6, 1, 0.5), font_name=os.path.join(constants.gui_assets, 'fonts', 'LLBI.otf'), font_size=sp(25))
        session_splash.__translate__ = False
        session_splash.text = constants.session_splash
        splash.add_widget(session_splash)

        float_layout.add_widget(splash)

        if not constants.server_list and not constants.server_manager.online_telepath_servers:
            top_button = MainButton('Create a new server', (0.5, 0.42), 'duplicate-outline.png')
            def open_telepath_menu(*a):
                screen_manager.current = 'TelepathManagerScreen'
            bottom_button = MainButton('Connect Via $Telepath$', (0.5, 0.32), 'telepath.png', click_func=open_telepath_menu)
        else:
            top_button = MainButton('Manage Auto-MCS servers', (0.5, 0.42), 'settings-outline.png')
            bottom_button = MainButton('Create a new server', (0.5, 0.32), 'duplicate-outline.png')
        quit_button = ExitButton('Quit', (0.5, 0.17))

        buttons.append(top_button)
        buttons.append(bottom_button)

        buttons.append(quit_button)

        for button in buttons:
            float_layout.add_widget(button)

        footer = generate_footer('splash', func_dict={'update': functools.partial(self.prompt_update, True), 'donate': self.open_donate})
        float_layout.add_widget(footer)

        self.add_widget(float_layout)

        # Animate for startup yumminess
        def animate_screen(*a):
            if not self.loaded:
                self.loaded = True

                anim_logo.opacity = logo.opacity = 0
                logo_width = logo.width
                anim_logo.width = logo.width = logo.width * 0.97

                version.opacity = 0
                version_x = version.x
                version.x = version.x - 10

                top_button.opacity = 0
                bottom_button.opacity = 0
                quit_button.opacity = 0

                Animation(opacity=1, duration=0.8, width=logo_width, transition='out_quad').start(logo)
                Animation(opacity=1, duration=0.8, width=logo_width, transition='out_quad').start(anim_logo)
                Animation(opacity=1, duration=1, x=version_x, transition='out_sine').start(version)

                def button_1(*b):
                    Animation(opacity=1, duration=0.8, transition='in_out_sine').start(top_button)
                def button_2(*b):
                    Animation(opacity=1, duration=1.1, transition='in_out_sine').start(bottom_button)
                def button_3(*b):
                    Animation(opacity=1, duration=1.4, transition='in_out_sine').start(quit_button)
                Clock.schedule_once(button_1, 0)
                Clock.schedule_once(button_2, 0.1)
                Clock.schedule_once(button_3, 0.2)

                # Animate footer items
                def wait_anim(c, c_y, *b):
                    Animation(duration=0.65, y=c_y, transition='out_circ').start(c)
                def wait_anim_2(w, *b):
                    Animation(opacity=1, duration=1, transition='out_circ').start(w)
                for x, w in enumerate(reversed(footer.children), 0):
                    w.opacity = 0
                    delay = (x * 0.1) + 0.35
                    for c in w.children:
                        c_y = c.y
                        c.y = c_y - 50
                        Clock.schedule_once(functools.partial(wait_anim, c, c_y), delay)
                    Clock.schedule_once(functools.partial(wait_anim_2, w), delay)


                # Animate sponsor button
                if constants.app_online:

                    # Only show a reminder once per month
                    show_anim = True
                    try:
                        if constants.app_config.sponsor_reminder:
                            if int(dt.now().strftime('%y%m')) == constants.app_config.sponsor_reminder:
                                show_anim = False
                    except:
                        pass

                    if show_anim:
                        constants.app_config.sponsor_reminder = int(dt.now().strftime('%y%m'))
                        def anim(*a):
                            anim_background = Image(
                                source=os.path.join(constants.gui_assets, 'menu_shadow.png'),
                                allow_stretch=True,
                                size_hint=(None, None),
                                width=dp(100),
                                height=dp(100),
                                color=(0.9, 0.65, 1, 0.08)
                            )
                            footer.add_widget(anim_background)
                            anim_background.pos = (88, -18)
                            anim_background.opacity = 0
                            Animation(opacity=1, duration=0.1).start(anim_background)

                            sponsor_anim = Image(
                                source=os.path.join(constants.gui_assets, 'animations', 'sponsor.webp'),
                                allow_stretch=True,
                                size_hint=(None, None),
                                width=dp(50),
                                height=dp(50),
                                anim_loop=1,
                                anim_delay=constants.anim_speed * 0.02,
                                color=(1, 0.85, 1, 1)
                            )
                            footer.add_widget(sponsor_anim)
                            sponsor_anim.pos = (113, 5)
                            def a(*a):
                                Animation(opacity=0, duration=0.5).start(anim_background)
                                Animation(opacity=0, duration=0.5).start(sponsor_anim)
                            Clock.schedule_once(a, 0.6)
                        Clock.schedule_once(anim, 1.2)

        Clock.schedule_once(animate_screen, 0)

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        # print('The key', keycode, 'have been pressed')
        # print(' - text is %r' % text)
        # print(' - modifiers are %r' % modifiers)

        # Ignore key presses when popup is visible
        if self.popup_widget:

            # Override for PopupSearch
            if self.popup_widget.__class__.__name__ == 'PopupSearch':
                if keycode[1] == 'escape':
                    self.popup_widget.self_destruct(True)
                elif keycode[1] == 'backspace' or ('shift' in modifiers and text and not text.isalnum()):
                    self.popup_widget.resize_window()
                elif control not in modifiers and text and self.popup_widget.window_input.keyboard:

                    def insert_text(content):
                        col = self.popup_widget.window_input.cursor_col
                        start = self.popup_widget.window_input.text[:col]
                        end = self.popup_widget.window_input.text[col:]
                        self.popup_widget.window_input.text = start + content + end
                        for x in range(len(content)):
                            Clock.schedule_once(functools.partial(self.popup_widget.window_input.do_cursor_movement, 'cursor_right', True), 0)

                    new_str = self.popup_widget.window_input.keyboard.keycode_to_string(keycode[0])
                    if 'shift' in modifiers:
                        new_str = new_str.upper()
                    if len(new_str) == 1:
                        insert_text(new_str)
                    elif keycode[1] == 'spacebar':
                        insert_text(' ')
                    self.popup_widget.resize_window()
                else:
                    self.popup_widget.resize_window()
                return True

            if keycode[1] in ['escape', 'n']:
                try:
                    self.popup_widget.click_event(self.popup_widget, 'no')
                except AttributeError:
                    self.popup_widget.click_event(self.popup_widget, 'ok')

            elif keycode[1] in ['enter', 'return', 'y']:
                try:
                    self.popup_widget.click_event(self.popup_widget, 'yes')
                except AttributeError:
                    self.popup_widget.click_event(self.popup_widget, 'ok')

            elif keycode[1] == 'spacebar':
                try:
                    self.popup_widget.click_event(self.popup_widget, 'body')
                except AttributeError:
                    pass
            return


        # Force a crash for debugging
        if 'c' in keycode[1] and 'ctrl' in modifiers and 'shift' in modifiers and constants.debug:
            raise Exception('Forced a crash for testing (CTRL-SHIFT-C)')


        # Trigger for showing search bar
        elif keycode[1] == 'shift':
            if not self._shift_held:
                self._shift_held = True
                self._shift_press_count += 1

                if self._shift_timer:
                    self._shift_timer.cancel()

                # Check for double tap
                if self._shift_press_count == 2:
                    self.show_search()
                    self._shift_press_count = 0

                # Otherwise, reset the timer
                else:
                    self._shift_timer = Clock.schedule_once(self._reset_shift_counter, 0.25)  # Adjust time as needed
            return True


        # Quit on macOS
        elif constants.os_name == 'macos' and (keycode[1] == 'q' and control in modifiers):
            if not main_app.exit_check():
                exit_app()


        # Ignore ESC commands while input focused
        if not self._input_focused and self.name == screen_manager.current_screen.name:

            # Force prompt an update/reinstall on main menu
            if keycode[1] == 'u' and 'shift' in modifiers and 'alt' in modifiers and control in modifiers and not self.popup_widget:
                self.prompt_update(force=True)

            # Keycode is composed of an integer + a string
            # If we hit escape, release the keyboard
            # On ESC, click on back button if it exists
            if keycode[1] == 'escape' and 'escape' not in self._ignore_keys:

                if self.context_menu:
                    self.context_menu.hide()

                else:
                    for button in self.walk():
                        try:
                            if button.id == "exit_button":
                                button.force_click()
                                break
                        except AttributeError:
                            continue
                keyboard.release()

            # Click next button if it's not disabled
            if keycode[1] == 'enter' and 'enter' not in self._ignore_keys:
                for button in self.walk():
                    try:
                        if button.id == "next_button" and button.disabled is False:
                            button.force_click()
                            break
                    except AttributeError:
                        continue
                keyboard.release()

        # # On TAB/Shift+TAB, cycle through elements
        # if keycode[1] == 'tab' and 'tab' not in self._ignore_keys:
        #     pass
        #     # for widget in self.walk():
        #     #     try:
        #     #         if "button" in widget.id or "input" in widget.id:
        #     #             print(widget)
        #     #             break
        #     #     except AttributeError:
        #     #         continue

        # Crash test
        # if keycode[1] == 'z' and control in modifiers:
        #     crash = float("crash")

        # Return True to accept the key. Otherwise, it will be used by the system.
        return True


class UpdateAppProgressScreen(ProgressScreen):

    # Only replace this function when making a child screen
    # Set fail message in child functions to trigger an error
    def contents(self):

        def before_func(*args):

            # First, clean out any existing files in temp or downloads
            os.chdir(constants.get_cwd())
            constants.safe_delete(constants.tempDir)
            constants.safe_delete(constants.downDir)

            if not constants.app_online:
                self.execute_error("An internet connection is required to continue\n\nVerify connectivity and try again")

            elif not constants.check_free_space():
                self.execute_error("Your primary disk is almost full\n\nFree up space and try again")


        def after_func(*args):
            icons = os.path.join(constants.gui_assets, 'fonts', constants.fonts['icons'])
            self.steps.label_2.text = "Update complete! Restarting..." + f"   [font={icons}]Ã¥[/font]"
            Clock.schedule_once(constants.restart_update_app, 1)

        # Original is percentage before this function, adjusted is a percent of hooked value
        def adjust_percentage(*args):
            original = self.last_progress
            adjusted = args[0]
            total = args[1] * 0.01
            final = original + round(adjusted * total)
            if final < 0:
                final = original
            self.progress_bar.update_progress(final)

        self.page_contents = {

            # Page name
            'title': f"Updating auto-mcs",

            # Header text
            'header': "Sit back and relax, it's automation time...",

            # Tuple of tuples for steps (label, function, percent)
            # Percent of all functions must total 100
            # Functions must return True, or default error will be executed
            'default_error': 'There was an issue, please try again later',

            'function_list': (),

            # Function to run before steps (like checking for an internet connection)
            'before_function': before_func,

            # Function to run after everything is complete (like cleaning up the screen tree) will only run if no error
            'after_function': after_func,

            # Screen to go to after complete
            'next_screen': None
        }

        # Create function list
        function_list = [
            (f'Downloading auto-mcs v{constants.update_data["version"].strip()}...', functools.partial(constants.download_update, functools.partial(adjust_percentage, 100)), 0)
        ]

        self.page_contents['function_list'] = tuple(function_list)


class ChangeLocaleScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'

    def generate_menu(self, **kwargs):

        # Scroll list
        scroll_widget = ScrollViewWidget()
        scroll_widget.pos_hint = {'center_y': 0.485}
        scroll_anchor = AnchorLayout()
        scroll_layout = GridLayout(cols=1, spacing=10, size_hint_max_x=1050, size_hint_y=None, padding=[0, 10, 0, 100])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 1.7
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        scroll_layout.bind(minimum_height=scroll_layout.setter('height'))
        scroll_layout.id = 'scroll_content'

        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.77}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.21}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60))

        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(HeaderText("Select a language", '', (0, 0.86)))

        class LocaleButton(MainButton):

            def on_press(self, *a):
                constants.app_config.locale = self.code
                size_list()
                constants.back_clicked = True
                previous_screen()
                constants.back_clicked = False
                Clock.schedule_once(
                    functools.partial(
                        screen_manager.current_screen.show_banner,
                        (0.85, 0.65, 1, 1),
                        f"Switched language to ${re.sub(r' +', ' ', self.text.text)}$",
                        "language-sharp.png",
                        2,
                        {"center_x": 0.5, "center_y": 0.965}
                    ), 0
                )

            def on_leave(self, *a):
                def change_background(*a):
                    self.button.background_normal = os.path.join(constants.gui_assets, 'addon_button_installed.png')
                Clock.schedule_once(change_background, 0.08)

            def __init__(self, name, code='en', **args):

                self.code = code
                in_use = self.code == constants.app_config.locale

                icon = 'checkmark-sharp.png' if in_use else 'arrow-forward.png'

                super().__init__(name, position=(0, 0), icon_name=icon, **args)
                self.text.__translate__ = False
                self.text.text = name

                self.button.on_press = self.on_press

                if in_use:
                    self.button.color_id[1] = (0.6, 1, 0.8, 1)
                    self.button.bind(on_leave=self.on_leave)
                    self.text.color = self.icon.color = self.button.color_id[1]
                    self.on_leave()


        # Create a button for each available language
        for k, v in constants.available_locales.items():

            sub_layout = ScrollItem()
            locale_title = f'{v["name"].title()}   ({v["code"].upper()})'
            sub_layout.add_widget(LocaleButton(name=locale_title, pos_hint={"center_x": 1, "center_y": 0.5}, code=v["code"]))
            scroll_layout.add_widget(sub_layout)


        # Append scroll view items
        scroll_anchor.add_widget(scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)


        buttons.append(ExitButton('Back', (0.5, 0.12), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        menu_name = "Language"
        float_layout.add_widget(generate_title(menu_name))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)


# </editor-fold> ///////////////////////////////////////////////////////////////////////////////////////////////////////




#  =============================================== Create Server =======================================================
# <editor-fold desc="Create Server">

class TemplateButton(HoverButton):

    def animate_button(self, image, color, **kwargs):
        image_animate = Animation(duration=0.05)

        def f(w):
            w.background_normal = image

        Animation(color=color, duration=0.06).start(self.title)
        Animation(color=color, duration=0.06).start(self.subtitle)

        Animation(color=color, duration=0.06).start(self.type_image.image)

        if self.type_image.version_label.__class__.__name__ == "AlignLabel":
            Animation(color=color, duration=0.06).start(self.type_image.version_label)
        Animation(color=color, duration=0.06).start(self.type_image.type_label)

        a = Animation(duration=0.0)
        a.on_complete = functools.partial(f)

        image_animate += a

        image_animate.start(self)

    def resize_self(self, *args):

        # Title and description
        padding = 2.17
        self.title.pos = (self.x + (self.title.text_size[0] / padding) - (8.3) + 30, self.y + 31)
        self.subtitle.pos = (self.x + (self.subtitle.text_size[0] / padding) - 78, self.y + 8)


        offset = 9.45 if self.type_image.type_label.text in ["vanilla", "paper", "purpur"]\
            else 9.6 if self.type_image.type_label.text == "forge"\
            else 9.35 if self.type_image.type_label.text == "craftbukkit"\
            else 9.55


        self.type_image.image.x = self.width + self.x - (self.type_image.image.width) - 13
        self.type_image.image.y = self.y + ((self.height / 2) - (self.type_image.image.height / 2))


        self.type_image.type_label.x = self.width + self.x - (self.padding_x * offset) - self.type_image.width - 83
        self.type_image.type_label.y = self.y + (self.height * 0.05)

        # Update label
        if self.type_image.version_label.__class__.__name__ == "AlignLabel":
            self.type_image.version_label.x = self.width + self.x - (self.padding_x * offset) - self.type_image.width - 83
            self.type_image.version_label.y = self.y - (self.height / 3.2)

        # Favorite button
        self.customize_layout.size_hint_max = (self.size_hint_max[0], self.size_hint_max[1])
        self.customize_layout.pos = (self.pos[0] - 6, self.pos[1] + 13)

    def __init__(self, template, fade_in=0.0, **kwargs):
        super().__init__(**kwargs)

        self.template = template
        self.border = (-5, -5, -5, -5)
        self.color_id = [(0.05, 0.05, 0.1, 1), constants.brighten_color((0.65, 0.65, 1, 1), 0.07)]
        self.pos_hint = {"center_x": 0.5, "center_y": 0.6}
        self.size_hint_max = (580, 80)
        self.id = "server_button"

        self.background_normal = os.path.join(constants.gui_assets, f'{self.id}.png')
        self.background_down = os.path.join(constants.gui_assets, f'{self.id}_click.png')


        # Title of Server
        self.title = Label()
        self.title.__translate__ = False
        self.title.id = "title"
        self.title.halign = "left"
        self.title.color = self.color_id[1]
        self.title.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
        self.title.font_size = sp(25)
        self.title.text_size = (self.size_hint_max[0] * 0.58, self.size_hint_max[1])
        self.title.shorten = True
        self.title.markup = True
        self.title.shorten_from = "right"
        self.title.max_lines = 1
        self.title.text = template['template']['name']
        self.add_widget(self.title)


        # Server last modified date formatted
        self.subtitle = Label()
        self.subtitle.__translate__ = False
        self.subtitle.size = (300, 30)
        self.subtitle.id = "subtitle"
        self.subtitle.halign = "left"
        self.subtitle.valign = "center"
        self.subtitle.font_size = sp(21)
        self.subtitle.text_size = (self.size_hint_max[0] * 0.91, self.size_hint_max[1])
        self.subtitle.shorten = True
        self.subtitle.markup = True
        self.subtitle.shorten_from = "right"
        self.subtitle.max_lines = 1
        self.subtitle.text_size[0] = 350
        self.subtitle.color = self.color_id[1]
        self.subtitle.default_opacity = 0.56
        self.subtitle.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["regular"]}.ttf')

        self.subtitle.text = template['template']['description']

        self.subtitle.opacity = self.subtitle.default_opacity

        self.add_widget(self.subtitle)


        # Type icon and info
        self.type_image = RelativeLayout()
        self.type_image.width = 400

        server_icon = os.path.join(constants.gui_assets, 'icons', 'big', f"{template['server']['type']}_small.png")
        self.type_image.image = Image(source=server_icon)

        self.type_image.image.allow_stretch = True
        self.type_image.image.size_hint_max = (65, 65)
        self.type_image.image.color = self.color_id[1]
        self.type_image.add_widget(self.type_image.image)

        def TemplateLabel():
            template_label = AlignLabel()
            template_label.__translate__ = False
            template_label.halign = "right"
            template_label.valign = "middle"
            template_label.text_size = template_label.size
            template_label.font_size = sp(19)
            template_label.color = self.color_id[1]
            template_label.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
            template_label.width = 150
            return template_label

        self.type_image.version_label = TemplateLabel()
        self.type_image.version_label.color = self.color_id[1]
        self.type_image.version_label.text = template['server']['version']
        self.type_image.version_label.opacity = 0.6


        self.type_image.type_label = TemplateLabel()

        type_text = template['server']['type'].lower().replace("craft", "")
        self.type_image.type_label.text = type_text
        self.type_image.type_label.font_size = sp(23)
        self.type_image.add_widget(self.type_image.version_label)
        self.type_image.add_widget(self.type_image.type_label)
        self.add_widget(self.type_image)


        # Favorite button
        self.customize_layout = RelativeLayout()

        def customize_with_template(*a):
            constants.apply_template(self.template)
            screen_manager.current = 'CreateServerNameScreen'

        def create_with_template(*a):
            constants.apply_template(self.template)
            screen_manager.current = 'CreateServerProgressScreen'

        self.customize_button = IconButton('', {}, (0, 0), (None, None), 'settings-sharp.png', clickable=True, anchor='right', click_func=customize_with_template)

        self.customize_layout.add_widget(self.customize_button)
        self.add_widget(self.customize_layout)

        self.bind(pos=self.resize_self)
        self.bind(on_press=create_with_template)

        # Animate opacity
        if fade_in > 0:
            self.opacity = 0
            self.title.opacity = 0

            Animation(opacity=1, duration=fade_in).start(self)
            Animation(opacity=1, duration=fade_in).start(self.title)
            Animation(opacity=self.subtitle.default_opacity, duration=fade_in).start(self.subtitle)

    def on_enter(self, *args):
        if not self.ignore_hover:
            self.animate_button(image=os.path.join(constants.gui_assets, f'{self.id}_hover.png'), color=self.color_id[0], hover_action=True)

    def on_leave(self, *args):
        if not self.ignore_hover:
            self.animate_button(image=os.path.join(constants.gui_assets, f'{self.id}.png'), color=self.color_id[1], hover_action=False)

class CreateServerTemplateScreen(MenuBackground):
    def switch_page(self, direction):

        if self.max_pages == 1:
            return

        if direction == "right":
            if self.current_page == self.max_pages:
                self.current_page = 1
            else:
                self.current_page += 1

        else:
            if self.current_page == 1:
                self.current_page = self.max_pages
            else:
                self.current_page -= 1

        self.page_switcher.update_index(self.current_page, self.max_pages)
        self.gen_search_results(self.last_results)

    def gen_search_results(self, results, new_search=False, fade_in=True, animate_scroll=True, *args):
        default_scroll = 1

        # Update page counter
        self.last_results = results
        self.max_pages = (len(results) / self.page_size).__ceil__()
        self.current_page = 1 if self.current_page == 0 or new_search else self.current_page


        self.page_switcher.update_index(self.current_page, self.max_pages)
        page_list = results[(self.page_size * self.current_page) - self.page_size:self.page_size * self.current_page]

        self.scroll_layout.clear_widgets()


        # Generate header
        header_content = "Select a template to use"

        for child in self.header.children:
            if child.id == "text":
                child.text = header_content
                break


        # Show servers if they exist
        if constants.ist_data:

            # Clear and add all TemplateButtons
            for x, template in enumerate(page_list, 1):

                # Template button click function
                self.scroll_layout.add_widget(
                    ScrollItem(
                        widget = TemplateButton(
                            template = template,
                            fade_in = ((x if x <= 8 else 8) / self.anim_speed) if fade_in else 0,
                        )
                    )
                )

            self.resize_bind()

        # Go back to main menu if they don't
        else:
            screen_manager.current = 'CreateServerModeScreen'
            constants.screen_tree = ['MainMenuScreen']
            return

        # Animate scrolling
        def set_scroll(*args):
            Animation.stop_all(self.scroll_layout.parent.parent)
            if animate_scroll:
                Animation(scroll_y=default_scroll, duration=0.1).start(self.scroll_layout.parent.parent)
            else:
                self.scroll_layout.parent.parent.scroll_y = default_scroll
        Clock.schedule_once(set_scroll, 0)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.header = None
        self.scroll_layout = None
        self.blank_label = None
        self.page_switcher = None

        self.last_results = []
        self.page_size = 10
        self.current_page = 0
        self.max_pages = 0
        self.anim_speed = 10

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        super()._on_keyboard_down(keyboard, keycode, text, modifiers)

        # Press arrow keys to switch pages
        if keycode[1] in ['right', 'left'] and self.name == screen_manager.current_screen.name:
            self.switch_page(keycode[1])

    def generate_menu(self, **kwargs):

        # Return if no free space or telepath is busy
        if disk_popup():
            return
        if telepath_popup():
            return

        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'

        # Prevent server creation if offline
        if not constants.app_online:
            float_layout.add_widget(HeaderText("Server creation requires an internet connection", '', (0, 0.6)))
            buttons.append(ExitButton('Back', (0.5, 0.35)))

        # Regular menus
        else:

            # Reload templates
            if not constants.ist_data:
                constants.get_repo_templates()


            # Scroll list
            scroll_widget = ScrollViewWidget(position=(0.5, 0.52))
            scroll_anchor = AnchorLayout()
            self.scroll_layout = GridLayout(cols=1, spacing=15, size_hint_max_x=1250, size_hint_y=None, padding=[0, 30, 0, 30])


            # Bind / cleanup height on resize
            def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
                call_widget.height = Window.height // 1.82
                grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1
                self.anim_speed = 13 if Window.width > grid_layout.size_hint_max_x else 10

                def update_grid(*args):
                    anchor_layout.size_hint_min_y = grid_layout.height

                Clock.schedule_once(update_grid, 0)


            self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, self.scroll_layout, scroll_anchor), 0)
            self.resize_bind()
            Window.bind(on_resize=self.resize_bind)
            self.scroll_layout.bind(minimum_height=self.scroll_layout.setter('height'))
            self.scroll_layout.id = 'scroll_content'


            # Scroll gradient
            scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.795}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60))
            scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.26}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60))

            # Generate buttons on page load
            header_content = "Select a template to use"
            self.header = HeaderText(header_content, '', (0, 0.89))

            buttons = []
            float_layout = FloatLayout()
            float_layout.id = 'content'
            float_layout.add_widget(self.header)

            self.page_switcher = PageSwitcher(0, 0, (0.5, 0.887), self.switch_page)


            # Append scroll view items
            scroll_anchor.add_widget(self.scroll_layout)
            scroll_widget.add_widget(scroll_anchor)
            float_layout.add_widget(scroll_widget)
            float_layout.add_widget(scroll_top)
            float_layout.add_widget(scroll_bottom)
            float_layout.add_widget(self.page_switcher)

            telepath_data = constants.server_manager.online_telepath_servers
            buttons.append(ExitButton('Back', (0.5, 0.11 if telepath_data else 0.14), cycle=True))

            for button in buttons:
                float_layout.add_widget(button)

            menu_name = "Instant Server"
            float_layout.add_widget(generate_title("Instant Server"))
            float_layout.add_widget(generate_footer(menu_name))

            # Add telepath button if servers are connected
            if telepath_data:
                float_layout.add_widget(TelepathDropButton('create', (0.5, 0.202)))

            self.add_widget(float_layout)

            self.gen_search_results(list(constants.ist_data.values()))

class CreateServerModeScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
    def generate_menu(self, **kwargs):
        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'

        float_layout.add_widget(HeaderText("What type of server do you wish to create?", '', (0, 0.86)))

        # Create UI buttons
        buttons.append(ExitButton('Back', (0.5, 0.14), cycle=True))


        # Create type buttons (Page 1)
        row_top = BoxLayout()
        row_bottom = BoxLayout()
        row_top.pos_hint = {"center_y": 0.64, "center_x": 0.5}
        row_bottom.pos_hint = {"center_y": 0.38, "center_x": 0.5}
        row_bottom.size_hint_max_x = row_top.size_hint_max_x = dp(600)
        row_top.orientation = row_bottom.orientation = "horizontal"

        def screen(name, *a):
            constants.new_server_init()
            screen_manager.current = name

        row_top.add_widget(
            big_mode_button('create a pre-configured server', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None),
                            'instant', clickable=True, click_func=functools.partial(screen, 'CreateServerTemplateScreen'))
        )
        row_top.add_widget(
            big_mode_button('install a modpack', {"center_y": 0.5, "center_x": 0.5}, (0, 0),(None, None),
                            'modpack', clickable=True, click_func=functools.partial(screen, 'ServerImportModpackScreen'))
        )

        row_bottom.add_widget(
            big_mode_button('import an existing server', {"center_y": 0.5, "center_x": 0.5}, (0, 0),(None, None),
                            'import', clickable=True, click_func=functools.partial(screen, 'ServerImportScreen'))
        )
        row_bottom.add_widget(
            big_mode_button('create a server manually', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None),
                            'custom', clickable=True, click_func=functools.partial(screen, 'CreateServerNameScreen'))
        )

        float_layout.add_widget(row_top)
        float_layout.add_widget(row_bottom)


        for button in buttons:
            float_layout.add_widget(button)

        float_layout.add_widget(generate_title('Create New Server'))
        float_layout.add_widget(generate_footer('Create new server'))

        # Async reload Telepath servers
        threading.Timer(0, constants.server_manager.check_telepath_servers).start()

        self.add_widget(float_layout)


# Create Server Step 1:  Server Name -----------------------------------------------------------------------------------

class CreateServerNameScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.name_input = None

    def generate_menu(self, **kwargs):

        # Return if no free space or telepath is busy
        if disk_popup():
            return
        if telepath_popup():
            return

        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'

        # Prevent server creation if offline
        if not constants.app_online:
            float_layout.add_widget(HeaderText("Server creation requires an internet connection", '', (0, 0.6)))
            buttons.append(ExitButton('Back', (0.5, 0.35)))

        # Regular menus
        else:
            float_layout.add_widget(InputLabel(pos_hint={"center_x": 0.5, "center_y": 0.58}))
            float_layout.add_widget(HeaderText("What would you like to name your server?", '', (0, 0.76)))
            self.name_input = ServerNameInput(pos_hint={"center_x": 0.5, "center_y": 0.5}, text=constants.new_server_info['name'])
            float_layout.add_widget(self.name_input)
            buttons.append(next_button('Next', (0.5, 0.24), not constants.new_server_info['name'], next_screen='CreateServerTypeScreen'))
            buttons.append(ExitButton('Back', (0.5, 0.14), cycle=True))
            float_layout.add_widget(page_counter(1, 7, (0, 0.768)))

        for button in buttons:
            float_layout.add_widget(button)


        # Add telepath button if servers are connected
        if constants.server_manager.online_telepath_servers:
            float_layout.add_widget(TelepathDropButton('create', (0.5, 0.4)))


        float_layout.add_widget(generate_title('Create New Server'))
        float_layout.add_widget(generate_footer('Create new server'))

        self.add_widget(float_layout)


        if constants.app_online:
            self.name_input.grab_focus()



# Create Server Step 2:  Server Type -----------------------------------------------------------------------------------

class CreateServerTypeScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.current_selection = 'vanilla'
        self.content_layout_1 = None
        self.content_layout_2 = None

    def generate_menu(self, **kwargs):
        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'

        float_layout.add_widget(HeaderText("What type of server do you wish to create?", '', (0, 0.86)))
        self.current_selection = constants.new_server_info['type']

        # Create UI buttons
        buttons.append(next_button('Next', (0.5, 0.21), False, next_screen='CreateServerVersionScreen'))
        buttons.append(ExitButton('Back', (0.5, 0.12), cycle=True))


        # Create type buttons (Page 1)
        self.content_layout_1 = FloatLayout()
        row_top = BoxLayout()
        row_bottom = BoxLayout()
        row_top.pos_hint = {"center_y": 0.66, "center_x": 0.5}
        row_bottom.pos_hint = {"center_y": 0.405, "center_x": 0.5}
        row_bottom.size_hint_max_x = row_top.size_hint_max_x = dp(1000)
        row_top.orientation = row_bottom.orientation = "horizontal"
        row_top.add_widget(big_icon_button('runs most plug-ins, optimized', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'paper', clickable=True, selected=('paper' == constants.new_server_info['type'])))
        row_top.add_widget(big_icon_button('default, stock experience', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'vanilla', clickable=True, selected=('vanilla' == constants.new_server_info['type'])))
        row_top.add_widget(big_icon_button('modded experience', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'forge', clickable=True, selected=('forge' == constants.new_server_info['type'])))
        row_bottom.add_widget(big_icon_button('performant fork of paper', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'purpur', clickable=True, selected=('purpur' == constants.new_server_info['type'])))
        row_bottom.add_widget(big_icon_button('modern mod platform', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'fabric', clickable=True, selected=('fabric' == constants.new_server_info['type'])))
        row_bottom.add_widget(big_icon_button('view more options', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'more', clickable=True, selected=False))
        self.content_layout_1.add_widget(row_top)
        self.content_layout_1.add_widget(row_bottom)


        # Create type buttons (Page 2)
        self.content_layout_2 = FloatLayout()
        constants.hide_widget(self.content_layout_2)
        row_top = BoxLayout()
        row_bottom = BoxLayout()
        row_top.pos_hint = {"center_y": 0.66, "center_x": 0.5}
        row_bottom.pos_hint = {"center_y": 0.405, "center_x": 0.5}
        row_top.size_hint_max_x = dp(1000)
        row_bottom.size_hint_max_x = dp(650)
        row_top.orientation = row_bottom.orientation = "horizontal"
        row_top.add_widget(big_icon_button('modern $Forge$ implementation', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'neoforge', clickable=True, selected=('neoforge' == constants.new_server_info['type'])))
        row_top.add_widget(big_icon_button('enhanced fork of $Fabric$', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'quilt', clickable=True, selected=('quilt' == constants.new_server_info['type'])))
        row_top.add_widget(big_icon_button('requires tuning, but efficient', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'spigot', clickable=True, selected=('spigot' == constants.new_server_info['type'])))
        row_bottom.add_widget(big_icon_button('legacy, supports plug-ins', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'craftbukkit', clickable=True, selected=('craftbukkit' == constants.new_server_info['type'])))
        row_bottom.add_widget(big_icon_button('view more options', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'more', clickable=True, selected=False))
        self.content_layout_2.add_widget(row_top)
        self.content_layout_2.add_widget(row_bottom)


        for button in buttons:
            float_layout.add_widget(button)

        float_layout.add_widget(self.content_layout_1)
        float_layout.add_widget(self.content_layout_2)
        menu_name = f"Create '{constants.new_server_info['name']}'"

        float_layout.add_widget(page_counter(2, 7, (0, 0.868)))
        float_layout.add_widget(generate_title(menu_name))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)



# Create Server Step 3:  Server Version --------------------------------------------------------------------------------

class CreateServerVersionScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'

    def generate_menu(self, **kwargs):

        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'

        # Prevent server creation if offline
        if not constants.app_online:
            float_layout.add_widget(HeaderText("Server creation requires an internet connection", '', (0, 0.6)))
            buttons.append(ExitButton('Back', (0.5, 0.35)))

        # Regular menus
        else:
            float_layout.add_widget(InputLabel(pos_hint={"center_x": 0.5, "center_y": 0.58}))
            float_layout.add_widget(page_counter(3, 7, (0, 0.768)))
            float_layout.add_widget(HeaderText("What version of Minecraft do you wish to play?", '', (0, 0.76)))
            float_layout.add_widget(ServerVersionInput(pos_hint={"center_x": 0.5, "center_y": 0.5}, text=constants.new_server_info['version']))
            buttons.append(next_button('Next', (0.5, 0.24), False, next_screen='CreateServerWorldScreen', show_load_icon=True))
            buttons.append(ExitButton('Back', (0.5, 0.14), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        menu_name = f"Create '{constants.new_server_info['name']}'"
        float_layout.add_widget(generate_title(menu_name))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)



# Create Server Step 4:  Server Name -----------------------------------------------------------------------------------
# Note:  Also generates ACL object after name/version are decided
class CreateServerWorldScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'

    def generate_menu(self, **kwargs):

        # Generate ACL in new_server_info
        def create_acl():
            if not constants.new_server_info['acl_object']:
                constants.new_server_info['acl_object'] = acl.AclManager(constants.new_server_info['name'])
            else:
                constants.new_server_info['acl_object'].server = acl.dump_config(constants.new_server_info['name'], True)

            # acl.print_acl(constants.new_server_info['acl_object'])

        thread = threading.Timer(0, create_acl)
        thread.start()


        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(InputLabel(pos_hint={"center_x": 0.5, "center_y": 0.62}))
        float_layout.add_widget(HeaderText("What world would you like to use?", '', (0, 0.76)))
        float_layout.add_widget(CreateServerWorldInput(pos_hint={"center_x": 0.5, "center_y": 0.55}))
        float_layout.add_widget(CreateServerSeedInput(pos_hint={"center_x": 0.5, "center_y": 0.442}))
        buttons.append(input_button('Browse...', (0.5, 0.55), ('dir', constants.saveFolder if os.path.isdir(constants.saveFolder) else constants.userDownloads), input_name='CreateServerWorldInput', title='Select a World File'))

        server_version = constants.new_server_info['version']
        if constants.version_check(server_version, '>=', "1.1"):
            options = ['normal', 'superflat']
            if constants.version_check(server_version, '>=', "1.3.1"):
                options.append('large biomes')
            if constants.version_check(server_version, '>=', "1.7.2"):
                options.append('amplified')
            default_name = constants.new_server_info['server_settings']['level_type'].replace("default", "normal").replace("flat", "superflat").replace("large_biomes", "large biomes")
            float_layout.add_widget(DropButton(default_name, (0.5, 0.442), options_list=options, input_name='ServerLevelTypeInput', x_offset=41))

        buttons.append(next_button('Next', (0.5, 0.24), False, next_screen='CreateServerNetworkScreen'))
        buttons.append(ExitButton('Back', (0.5, 0.14), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        menu_name = f"Create '{constants.new_server_info['name']}'"
        float_layout.add_widget(page_counter(4, 7, (0, 0.768)))
        float_layout.add_widget(generate_title(menu_name))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)

    def on_pre_enter(self, *args):
        super().on_pre_enter()
        self.toggle_new(constants.new_server_info['server_settings']['world'] != 'world')

    # Call this when world loaded, and when the 'create new world instead' button is clicked. Fix overlapping when added/removed multiple times
    def toggle_new(self, boolean_value):

        current_input = ''
        server_version = constants.new_server_info['version']

        for child in self.children:
            try:
                if child.id == 'content':
                    for item in child.children:
                        try:
                            if item.__class__.__name__ == 'CreateServerSeedInput':
                                current_input = 'input'
                                if constants.new_server_info['server_settings']['world'] != 'world':
                                    child.remove_widget(item)

                                    try:
                                        if constants.version_check(server_version, '>=', "1.1"):
                                            child.remove_widget([relative for relative in child.children if relative.__class__.__name__ == 'DropButton'][0])
                                    except IndexError:
                                        if constants.debug:
                                            print("Error: 'DropButton' does not exist, can't remove")

                            elif item.id == 'Create new world instead':
                                current_input = 'button'
                                if constants.new_server_info['server_settings']['world'] == 'world':
                                    child.remove_widget(item)
                        except AttributeError:
                            continue

                    # Show button if true
                    if boolean_value and constants.new_server_info['server_settings']['world'] != 'world' and current_input == 'input':
                        child.add_widget(MainButton('Create new world instead', (0.5, 0.442), 'add-circle-outline.png', width=530))

                    # Show seed input, and clear world text
                    elif constants.new_server_info['server_settings']['world'] == 'world' and current_input == 'button':
                        child.add_widget(CreateServerSeedInput(pos_hint={"center_x": 0.5, "center_y": 0.442}))

                        if constants.version_check(server_version, '>=', "1.1"):
                            options = ['normal', 'superflat']
                            if constants.version_check(server_version, '>=', "1.3.1"):
                                options.append('large biomes')
                            if constants.version_check(server_version, '>=', "1.7.2"):
                                options.append('amplified')
                            default_name = constants.new_server_info['server_settings']['level_type'].replace("default", "normal").replace("flat", "superflat").replace("large_biomes", "large biomes")
                            child.add_widget(DropButton(default_name, (0.5, 0.442), options_list=options, input_name='ServerLevelTypeInput', x_offset=41))
                    break

            except AttributeError:
                pass



# Create Server Step 5:  Server Network --------------------------------------------------------------------------------
def process_ip_text(server_obj=None):

    if server_obj:
        start_text = ''
        if not str(server_obj.port) == '25565' or server_obj.ip:
            if server_obj.ip:
                start_text = server_obj.ip
            if str(server_obj.port) != '25565':
                start_text = start_text + ':' + str(server_obj.port) if start_text else str(server_obj.port)

    else:
        start_text = ''
        if not str(constants.new_server_info['port']) == '25565' or constants.new_server_info['ip']:
            if constants.new_server_info['ip']:
                start_text = constants.new_server_info['ip']
            if str(constants.new_server_info['port']) != '25565':
                start_text = start_text + ':' + constants.new_server_info['port'] if start_text else constants.new_server_info['port']

    return start_text

class CreateServerNetworkScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'

    def generate_menu(self, **kwargs):

        # Scroll list
        scroll_widget = ScrollViewWidget()
        scroll_anchor = AnchorLayout()
        scroll_layout = GridLayout(cols=1, spacing=30, size_hint_max_x=1050, size_hint_y=None, padding=[0, 50, 0, 30])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 2
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        scroll_layout.bind(minimum_height=scroll_layout.setter('height'))
        scroll_layout.id = 'scroll_content'

        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.77}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.272}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60))


        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'

        sub_layout = ScrollItem()
        sub_layout.add_widget(InputLabel(pos_hint={"center_x": 0.5, "center_y": 1.1}))
        sub_layout.add_widget(CreateServerPortInput(pos_hint={"center_x": 0.5, "center_y": 0.5}, text=process_ip_text()))
        scroll_layout.add_widget(sub_layout)

        sub_layout = ScrollItem()
        sub_layout.add_widget(CreateServerMOTDInput(pos_hint={"center_x": 0.5, "center_y": 0.5}))
        scroll_layout.add_widget(sub_layout)

        sub_layout = ScrollItem()
        sub_layout.add_widget(MainButton('Access Control', (0.5, 0.5), 'shield-half-small.png', width=450, icon_offset=-185))
        scroll_layout.add_widget(sub_layout)

        sub_layout = ScrollItem()
        def toggle_proxy(boolean):
            constants.new_server_info['server_settings']['enable_proxy'] = boolean
        sub_layout.add_widget(blank_input(pos_hint={"center_x": 0.5, "center_y": 0.5}, hint_text='enable proxy (playit)'))
        sub_layout.add_widget(toggle_button('proxy', (0.5, 0.5), custom_func=toggle_proxy, default_state=constants.new_server_info['server_settings']['enable_proxy']))
        scroll_layout.add_widget(sub_layout)


        # Append scroll view items
        scroll_anchor.add_widget(scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)

        float_layout.add_widget(HeaderText("Do you wish to configure network information?", '', (0, 0.83)))


        buttons.append(next_button('Next', (0.5, 0.24), False, next_screen='CreateServerOptionsScreen'))
        buttons.append(ExitButton('Back', (0.5, 0.14), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        menu_name = f"Create '{constants.new_server_info['name']}'"
        float_layout.add_widget(page_counter(5, 7, (0, 0.838)))
        float_layout.add_widget(generate_title(menu_name))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)



# Create Server Step 5:  ACL Options -----------------------------------------------------------------------------------

class RuleButton(FloatLayout):

    def __setattr__(self, attr, value):

        # Change attributes dynamically based on rule
        if attr == "rule" and value:
            self.text.text = value.rule.replace("!w", "")
            self.change_properties(value)

        super().__setattr__(attr, value)


    # Modifies rule attributes based on rule.list_enabled status
    def change_properties(self, rule):

        # Prevent crash from spamming the back button
        if "Acl" not in screen_manager.current_screen.name:
            return

        Animation.cancel_all(self.button)
        Animation.cancel_all(self.text)
        Animation.cancel_all(self.icon)

        self.button.id = f'rule_button{"_enabled" if rule.list_enabled else ""}'
        self.button.background_normal = os.path.join(constants.gui_assets, f'{self.button.id}.png')
        self.button.background_down = os.path.join(constants.gui_assets, f'{self.button.id}_click.png')

        # Change color attributes
        if screen_manager.current_screen.current_list == "ops":
            self.color_id = self.button.color_id = [(0, 0, 0, 0.85), (0.439, 0.839, 1, 1)] if rule.list_enabled else [(0, 0, 0, 0.85), (0.6, 0.5, 1, 1)]
            self.hover_attr = (icon_path("close-circle.png"), 'DEMOTE', (1, 0.5, 0.65, 1)) if rule.list_enabled else (icon_path("promote.png"), 'PROMOTE', (0.3, 1, 0.6, 1))
        elif screen_manager.current_screen.current_list == "bans":
            if rule.rule_type == "ip":
                self.color_id = self.button.color_id = [(0, 0, 0, 0.85), (1, 0.45, 0.85, 1)] if rule.list_enabled else [(0, 0, 0, 0.85), (0.4, 0.8, 1, 1)]
            else:
                self.color_id = self.button.color_id = [(0, 0, 0, 0.85), (1, 0.5, 0.65, 1)] if rule.list_enabled else [(0, 0, 0, 0.85), (0.3, 1, 0.6, 1)]
            if rule.list_enabled:
                self.hover_attr = (icon_path("lock-open.png"), 'PARDON', (0.3, 1, 0.6, 1))
            else:
                self.hover_attr = (icon_path("close-circle.png"), 'BAN' if rule.rule_type == 'player' else 'REMOVE', (1, 0.5, 0.65, 1))
        elif screen_manager.current_screen.current_list == "wl":
            if screen_manager.current_screen.acl_object._server['whitelist']:
                self.color_id = self.button.color_id = [(0, 0, 0, 0.85), (0.3, 1, 0.6, 1)] if rule.list_enabled else [(0, 0, 0, 0.85), (1, 0.5, 0.65, 1)]
            else:
                self.color_id = self.button.color_id = [(0, 0, 0, 0.85), (0.3, 1, 0.6, 1)] if rule.list_enabled else [(0, 0, 0, 0.85), (0.7, 0.7, 0.7, 1)]
            self.hover_attr = (icon_path("close-circle.png"), 'RESTRICT', (1, 0.5, 0.65, 1)) if rule.list_enabled else (icon_path("checkmark-circle-sharp.png"), 'PERMIT', (0.3, 1, 0.6, 1))

        new_color_id = (self.color_id[1][0], self.color_id[1][1], self.color_id[1][2], 1 if rule.list_enabled else 0.95)
        self.color_id[1] = new_color_id
        self.button.color_id[1] = new_color_id
        self.text.color = constants.brighten_color(new_color_id, 0.2)
        self.icon.color = constants.brighten_color(new_color_id, 0.2)
        self.icon.source = icon_path("earth-sharp.png")
        self.button.background_color = new_color_id


        # Change scope attributes
        if rule.rule_scope == "global":
            self.text.pos_hint["center_x"] = 0.5 + round(len(self.text.text) * 0.01, 2)
            self.icon.opacity = 1
            self.icon.color = self.global_icon_color
            if rule.rule_type == "player" or "/" in rule.rule:
                self.text.font_size = sp(19 - (0 if len(self.text.text) < 11 else (len(self.text.text) // 5)))

        else:
            self.text.pos_hint["center_x"] = 0.5
            self.icon.opacity = 0
            self.icon.color = self.color_id[1]
            if rule.rule_type == "player" or "/" in rule.rule:
                self.text.font_size = sp(19 - (0 if len(self.text.text) < 11 else (len(self.text.text) // 7)))

        if rule.rule_type == "ip" and "/" not in rule.rule:
            self.text.font_size = sp(19)

        self.original_font_size = self.text.font_size


    def highlight(self, original_color, original_text_color, original_hover_color):
        self.button.background_color = constants.brighten_color(original_hover_color, -0.15)
        self.text.color = constants.brighten_color(original_hover_color, -0.15)
        Animation(background_color=original_color, duration=1).start(self.button)
        Animation(color=original_text_color, duration=1).start(self.text)


    def __init__(self, name='', icon_name=None, width=None, icon_offset=None, auto_adjust_icon=False, **kwargs):
        super().__init__(**kwargs)

        position = (0.5, 0.5)
        self.size_hint_max_y = dp(60)
        self.rule = None
        self.id = 'rule_button'
        self.enabled = True
        self.original_font_size = None
        self.action_text = ''


        # Hover button object
        self.button = HoverButton()

        def on_enter(*args):

            Animation.cancel_all(self.button)
            Animation.cancel_all(self.text)

            if not self.button.ignore_hover:
                animate_button(self.button, image=os.path.join(constants.gui_assets, f'{self.button.id}_hover.png'), color=self.button.color_id[0])
                self.text.font_size = sp(18)

                if self.rule.rule_scope == "global":
                    self.icon.source = icon_path("earth-strike.png")
                    self.text.text = constants.translate("LOCALIZE")
                    self.action_text = "LOCALIZE"
                    Animation(background_color=self.global_icon_color, duration=0.05).start(self.button)

                else:
                    self.icon.source = self.hover_attr[0]
                    self.text.text = "   " + constants.translate(self.hover_attr[1])
                    self.action_text = self.hover_attr[1]
                    Animation(background_color=self.hover_attr[2], duration=0.05).start(self.button)
                    Animation(opacity=1, duration=0.05).start(self.icon)

        def on_leave(*args):
            if not self.button.ignore_hover:
                animate_button(self.button, image=os.path.join(constants.gui_assets, f'{self.button.id}.png'), color=constants.brighten_color(self.button.color_id[1], 0.2))
                self.text.font_size = self.original_font_size
                self.text.text = self.rule.rule.replace("!w", "")
                new_color_id = (self.color_id[1][0], self.color_id[1][1], self.color_id[1][2], 1 if self.rule.list_enabled else 0.95)
                Animation(background_color=new_color_id, duration=0.1).start(self.button)

                if self.rule.rule_scope == "global":
                    Animation(color=self.global_icon_color,duration=0.07).start(self.icon)
                    self.icon.source = icon_path("earth-sharp.png")
                else:
                    Animation(opacity=0, duration=0.05).start(self.icon)

        def click_func(button_pressed=None, *args):

            if not button_pressed or not isinstance(button_pressed, str):
                button_pressed = self.button.button_pressed.lower().strip()

            button_text = self.action_text.lower().strip()
            current_list = screen_manager.current_screen.current_list.lower().strip()
            acl_object = screen_manager.current_screen.acl_object
            original_name = self.rule.rule
            filtered_name = self.rule.rule.replace("!w", "").replace("!g", "").strip()
            original_hover_attr = self.hover_attr
            new_scope = self.rule.rule_scope
            banner_text = ""
            reload_page = False
            localize = False


            # Left click on button (Local)
            if button_pressed == "left" and self.rule.rule_scope == "local":

                # Modify 'ops' list
                if current_list == "ops" and button_text in ['promote', 'demote']:
                    acl_object.op_player(self.rule.rule, remove=(button_text == "demote"))
                    banner_text = f"'${filtered_name}$' was {'demoted' if (button_text == 'demote') else 'promoted'}"
                    reload_page = True

                # Modify 'bans' list
                elif current_list == "bans" and button_text in ['ban', 'pardon', 'remove']:
                    acl_object.ban_player(self.rule.rule, remove=(button_text == "pardon") or ("!w" in self.rule.rule))

                    if button_text == "pardon":
                        try:
                            ip_addr = acl.get_uuid(self.rule.rule)['latest-ip'].split(":")[0].strip()
                        except KeyError:
                            ip_addr = ""

                        if ip_addr:
                            # Whitelist IP if it's still in the rule list
                            if ip_addr in acl.gen_iplist(acl_object.rules['subnets']):
                                acl_object.ban_player(f"!w{ip_addr}", remove=False)

                    banner_text = f"'${filtered_name}$' was removed" if button_text == 'remove' else f"'{filtered_name}' is {'pardoned' if (button_text == 'pardon') else 'banned'}"
                    reload_page = True

                # Modify 'wl' list
                elif current_list == "wl" and button_text in ['permit', 'restrict']:
                    acl_object.whitelist_player(self.rule.rule, remove=(button_text == "restrict"))
                    banner_text = f"'${filtered_name}$' is {'restricted' if (button_text == 'restrict') else 'permitted'}"
                    reload_page = True


            # Left click on button (global)
            elif button_pressed == "left" and self.rule.rule_scope == "global" and button_text == "localize":
                acl_object.add_global_rule(self.rule.rule, current_list, remove=True)
                original_hover_attr = (
                    icon_path("earth-strike.png"),
                    original_hover_attr[1],
                    self.color_id[1]
                )
                banner_text = f"'${filtered_name}$' rule is now locally applied"
                localize = True
                new_scope = "local"
                reload_page = True


            # Middle click on button
            elif button_pressed == "middle":
                acl_object.add_global_rule(self.rule.rule, current_list, remove=(button_text == 'localize'))
                original_hover_attr = (
                    icon_path(f"earth-{'strike' if (self.rule.rule_scope == 'global') else 'sharp'}.png"),
                    original_hover_attr[1],
                    self.global_icon_color if (self.rule.rule_scope == 'local') else self.color_id[1]
                )
                banner_text = f"'${filtered_name}$' is now {'local' if (self.rule.rule_scope == 'global') else 'global'}ly applied"
                localize = self.rule.rule_scope == "global"
                new_scope = "local" if localize else "global"
                reload_page = True



            if reload_page:
                # print(button_text, button_pressed, current_list)

                # If rule localized, enable on current list
                if localize:
                    if current_list == "ops":
                        acl_object.op_player(self.rule.rule)
                    elif current_list == "bans":
                        acl_object.ban_player(self.rule.rule)
                    elif current_list == "wl":
                        acl_object.whitelist_player(self.rule.rule)


                self.button.on_leave()
                self.change_properties(self.rule)
                self.button.state = "normal"

                Animation.cancel_all(self.button)
                Animation.cancel_all(self.text)
                Animation.cancel_all(self.icon)

                screen_manager.current_screen.update_list(current_list, reload_children=False)

                Clock.schedule_once(
                    functools.partial(
                        screen_manager.current_screen.show_banner,
                        original_hover_attr[2],
                        banner_text,
                        original_hover_attr[0],
                        2,
                        {"center_x": 0.5, "center_y": 0.965}
                    ), 0
                )

                def trigger_highlight(*args):
                    for rule_button in screen_manager.current_screen.scroll_layout.children:

                        if rule_button.rule.rule == original_name:
                            rule_button.highlight(rule_button.button.background_color, rule_button.text.color, original_hover_attr[2])

                        else:
                            rule_button.button.on_leave()
                            Animation.cancel_all(rule_button.button)
                            Animation.cancel_all(rule_button.text)
                            Animation.cancel_all(rule_button.icon)
                            rule_button.change_properties(rule_button.rule)

                        rule_button.button.ignore_hover = False

                Clock.schedule_once(trigger_highlight, 0)

            # Update display rule regardless of button pressed
            screen_manager.current_screen.update_user_panel(self.rule.rule, new_scope)



        self.button.on_enter = on_enter
        self.button.on_leave = on_leave
        self.button.bind(on_press=click_func)
        self.button.id = 'rule_button'
        self.color_id = self.button.color_id = [(0.03, 0.03, 0.03, 1), (1, 1, 1, 1)] # [(0.05, 0.05, 0.1, 1), (0.6, 0.6, 1, 1)]
        self.hover_attr = (icon_path('close-circle.png'), 'hover text', (1, 1, 1, 1)) # Icon, Text, Hover color
        self.global_icon_color = (0.953, 0.929, 0.38, 1)

        self.button.size_hint = (None, None)
        self.button.size = (dp(190 if not width else width), self.size_hint_max_y)
        self.button.pos_hint = {"center_x": position[0], "center_y": position[1]}
        self.button.border = (-3, -3, -3, -3)
        self.button.background_normal = os.path.join(constants.gui_assets, 'rule_button.png')
        self.button.background_down = os.path.join(constants.gui_assets, 'rule_button_click.png')
        self.button.always_release = True

        self.text = Label()
        self.text.__translate__ = False
        self.text.id = 'text'
        self.text.size_hint = (None, None)
        self.text.pos_hint = {"center_x": position[0], "center_y": position[1]}
        self.text.text = name
        self.text.font_size = sp(19)
        self.text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["bold"]}.ttf')
        self.text.color = self.color_id[1]


        # Button click behavior
        self.button.on_release = functools.partial(button_action, name, self.button)
        self.add_widget(self.button)


        # Icon thingy
        self.icon = Image()
        self.icon.id = 'icon'
        self.icon.source = icon_path("earth-sharp.png") if not icon_name else icon_path(icon_name)
        self.icon.size = (25, 25)
        self.icon.size_hint = (None, None)
        self.icon.opacity = 0
        self.icon.color = self.color_id[1]
        self.icon.pos_hint = {"center_x": -0.2, "center_y": 0.5}


        self.add_widget(self.icon)
        self.add_widget(self.text)

class AclRulePanel(RelativeLayout):

    def __init__(self, **kw):
        super().__init__(**kw)

        class HeaderLabel(Label):
            def __init__(self, **kwargs):
                super().__init__(**kwargs)
                self.size_hint = (None, None)
                self.markup = True
                self.font_size = sp(22)
                self.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
                self.color = (0.6, 0.6, 1, 1)

        class ParagraphLabel(Label, HoverBehavior):

            def on_mouse_pos(self, *args):

                if "AclScreen" in screen_manager.current_screen.name:

                    try:
                        super().on_mouse_pos(*args)
                    except:
                        pass

                    if self.text.count(".") > 3 and "IP" in self.text:
                        rel_y = args[1][1] - screen_manager.current_screen.user_panel.y
                        if self.hovered and rel_y < 190:
                            self.on_leave()
                            self.hovered = False


            # Hover stuffies
            def on_enter(self, *args):

                # Change size of IP text
                if self.text.count(".") > 3 and "IP" in self.text:
                    rel_y = self.border_point[1] - screen_manager.current_screen.user_panel.y
                    if rel_y < 190:
                        self.hovered = False
                        return None

                if self.copyable:
                    self.outline_width = 0
                    self.outline_color = constants.brighten_color(self.color, 0.05)
                    Animation(outline_width=1, duration=0.03).start(self)


            def on_leave(self, *args):

                if self.copyable:
                    Animation.stop_all(self)
                    self.outline_width = 0


            # Normal stuffies
            def on_ref_press(self, *args):
                if not self.disabled:

                    Clock.schedule_once(
                        functools.partial(
                            screen_manager.current_screen.show_banner,
                            (0.85, 0.65, 1, 1),
                            "Copied text to clipboard",
                            "link-sharp.png",
                            2,
                            {"center_x": 0.5, "center_y": 0.965}
                        ), 0
                    )

                    Clipboard.copy(re.sub("\[.*?\]","",self.text))


            def ref_text(self, *args):

                self.copyable = not ((constants.translate("unknown") in self.text.lower()) or (constants.translate("online") in self.text.lower()) or (constants.translate("access") in self.text.lower()))

                if '[ref=' not in self.text and '[/ref]' not in self.text and self.copyable:
                    self.text = f'[ref=none]{self.text}[/ref]'
                elif '[/ref]' in self.text:
                    self.text = self.text.replace("[/ref]","") + "[/ref]"

                self.texture_update()
                self.size = self.texture_size

                if self.text.count(".") > 3 and "IP" in self.text:
                    self.width = self.texture_size[0] / 1.5


            def __init__(self, **kwargs):
                super().__init__(**kwargs)
                self.size_hint = (None, None)
                self.markup = True
                self.font_size = sp(18)
                self.copyable = True
                self.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["regular"]}.ttf')
                self.default_color = (0.6, 0.6, 1, 1)
                self.color = self.default_color
                self.bind(text=self.ref_text)


        self.color_dict = {
            "blue":    "#70E6FF",
            "red":     "#FF8793",
            "green":   "#4CFF99",
            "white":   "#FFFFFF",
            "gray":    "#A0A0A0",
            "yellow":  "#F3ED61",
            "purple":  "#A699FF"
        }


        self.displayed_type = ""
        self.displayed_scope = "local"

        # User panel (I'm sorry in advance)
        # <editor-fold desc="User Panel SUFFERING">
        self.pos_hint = {"center_y": 0.42}
        self.size_hint_max = (500, 600)

        # Background image
        self.background = Image()
        self.background.id = 'background'
        self.background.source = os.path.join(constants.gui_assets, 'user_panel.png')
        self.background.color = (0.65, 0.6, 1, 1)
        self.background.opacity = 0

        # Label when no rule is displayed
        self.blank_label = Label()
        self.blank_label.id = 'blank_label'
        self.blank_label.text = "Right-click a rule to view"
        self.blank_label.text_size[0] = self.size_hint_max[0] * 0.7
        self.blank_label.halign = "center"
        self.blank_label.font_name = os.path.join(constants.gui_assets, 'fonts', constants.fonts['italic'])
        self.blank_label.pos_hint = {"center_x": 0.5, "center_y": 0.5}
        self.blank_label.font_size = sp(26)
        self.blank_label.color = (0.6, 0.6, 1, 0.4)
        self.blank_label.opacity = 0

        # Drop down options button
        self.options = DropButton('OPTIONS', (0.5, 0.192), options_list=['operators', 'bans', 'whitelist'], input_name='ServerAclOptionsInput', x_offset=-33, facing='center', custom_func=self.modify_rule, change_text=False)
        self.add_widget(self.options)


        # Player Layout
        # <editor-fold desc="Player Layout Widgets">
        self.player_layout = RelativeLayout()
        self.player_layout.id = 'player_layout'

        self.player_layout.header_icon = Image()
        self.player_layout.header_icon.source = icon_path('person-circle-sharp.png')
        self.player_layout.header_icon.allow_stretch = True
        self.player_layout.header_icon.size_hint_max = (36, 36)
        self.player_layout.header_icon.pos_hint = {"center_x": 0.5, "center_y": 0.808}
        self.player_layout.add_widget(self.player_layout.header_icon)

        # Make this copyable text
        self.player_layout.name_label = HeaderLabel()
        self.player_layout.name_label.__translate__ = False
        self.player_layout.name_label.pos_hint = {"center_x": 0.54, "center_y": 0.81}
        self.player_layout.name_label.font_size = sp(25)
        self.player_layout.add_widget(self.player_layout.name_label)

        self.player_layout.online_icon = Image()
        self.player_layout.online_icon.source = icon_path('radio-button-off-sharp.png')
        self.player_layout.online_icon.allow_stretch = True
        self.player_layout.online_icon.size_hint_max = (15, 15)
        self.player_layout.online_icon.pos_hint = {"center_x": 0.5, "center_y": 0.752}
        self.player_layout.add_widget(self.player_layout.online_icon)

        self.player_layout.online_label = ParagraphLabel()
        self.player_layout.online_label.font_size = sp(19)
        self.player_layout.online_label.pos_hint = {"center_x": 0.523, "center_y": 0.755}
        self.player_layout.add_widget(self.player_layout.online_label)

        self.player_layout.uuid_header = HeaderLabel()
        self.player_layout.uuid_header.__translate__ = False
        self.player_layout.uuid_header.pos_hint = {"center_x": 0.5, "center_y": 0.66}
        self.player_layout.add_widget(self.player_layout.uuid_header)

        # Make this copyable text
        self.player_layout.uuid_label = ParagraphLabel()
        self.player_layout.uuid_label.__translate__ = False
        self.player_layout.uuid_label.pos_hint = {"center_x": 0.5, "center_y": 0.619}
        self.player_layout.add_widget(self.player_layout.uuid_label)

        self.player_layout.ip_header = HeaderLabel()
        self.player_layout.ip_header.__translate__ = False
        self.player_layout.ip_header.pos_hint = {"center_x": 0.28, "center_y": 0.54}
        self.player_layout.add_widget(self.player_layout.ip_header)

        # Make this copyable text
        self.player_layout.ip_label = ParagraphLabel()
        self.player_layout.ip_label.__translate__ = False
        self.player_layout.ip_label.font_size = sp(20)
        self.player_layout.ip_label.pos_hint = {"center_x": 0.28, "center_y": 0.499}
        self.player_layout.add_widget(self.player_layout.ip_label)

        self.player_layout.geo_header = HeaderLabel()
        self.player_layout.geo_header.__translate__ = False
        self.player_layout.geo_header.pos_hint = {"center_x": 0.7, "center_y": 0.54}
        self.player_layout.add_widget(self.player_layout.geo_header)

        self.player_layout.geo_label = ParagraphLabel()
        self.player_layout.geo_label.__translate__ = False
        self.player_layout.geo_label.halign = "center"
        self.player_layout.geo_label.pos_hint = {"center_x": 0.7, "center_y": 0.499}
        self.player_layout.add_widget(self.player_layout.geo_label)

        self.player_layout.access_header = HeaderLabel()
        self.player_layout.access_header.pos_hint = {"center_x": 0.5, "center_y": 0.4}
        self.player_layout.access_header.font_size = sp(20)
        self.player_layout.add_widget(self.player_layout.access_header)

        self.player_layout.access_label = ParagraphLabel()
        self.player_layout.access_label.halign = "left"
        self.player_layout.access_label.valign = "top"
        self.player_layout.access_label.text_size = (250, 300)
        self.player_layout.access_label.font_size = sp(19)
        self.player_layout.access_label.line_height = sp(1.4)
        self.player_layout.access_label.pos_hint = {"center_x": 0.465, "center_y": 0.11}
        self.player_layout.add_widget(self.player_layout.access_label)

        self.player_layout.access_line_1 = Image()
        self.player_layout.access_line_1.size_hint_max = (35, 35)
        self.player_layout.access_line_1.pos_hint = {"center_x": 0.165, "center_y": 0.29}
        self.player_layout.access_line_1.allow_stretch = True
        self.player_layout.access_line_1.source = os.path.join(constants.gui_assets, "access_active.png")
        self.player_layout.add_widget(self.player_layout.access_line_1)

        self.player_layout.access_line_2 = Image()
        self.player_layout.access_line_2.size_hint_max = (35, 35)
        self.player_layout.access_line_2.pos_hint = {"center_x": 0.165, "center_y": 0.24}
        self.player_layout.access_line_2.allow_stretch = True
        self.player_layout.access_line_2.source = os.path.join(constants.gui_assets, "access_active.png")
        self.player_layout.add_widget(self.player_layout.access_line_2)

        self.player_layout.access_line_3 = Image()
        self.player_layout.access_line_3.size_hint_max = (35, 35)
        self.player_layout.access_line_3.pos_hint = {"center_x": 0.165, "center_y": 0.19}
        self.player_layout.access_line_3.allow_stretch = True
        self.player_layout.access_line_3.source = os.path.join(constants.gui_assets, "access_active.png")
        self.player_layout.add_widget(self.player_layout.access_line_3)

        self.player_layout.access_icon = Image()
        self.player_layout.access_icon.size_hint_max = (30, 30)
        self.player_layout.access_icon.pos_hint = {"center_x": 0.165, "center_y": 0.338}
        self.player_layout.add_widget(self.player_layout.access_icon)
        # </editor-fold>


        # IP Layout
        # <editor-fold desc="IP Layout Widgets">
        self.ip_layout = RelativeLayout()
        self.ip_layout.id = 'ip_layout'

        self.ip_layout.header_icon = Image()
        self.ip_layout.header_icon.source = icon_path('ethernet.png')
        self.ip_layout.header_icon.allow_stretch = True
        self.ip_layout.header_icon.size_hint_max = (36, 36)
        self.ip_layout.header_icon.pos_hint = {"center_x": 0.5, "center_y": 0.808}
        self.ip_layout.add_widget(self.ip_layout.header_icon)

        # Make this copyable text
        self.ip_layout.name_label = HeaderLabel()
        self.ip_layout.name_label.__translate__ = False
        self.ip_layout.name_label.pos_hint = {"center_x": 0.54, "center_y": 0.81}
        self.ip_layout.name_label.font_size = sp(25)
        self.ip_layout.add_widget(self.ip_layout.name_label)

        self.ip_layout.type_header = HeaderLabel()
        self.ip_layout.type_header.pos_hint = {"center_x": 0.28, "center_y": 0.64}
        self.ip_layout.add_widget(self.ip_layout.type_header)

        # Make ip copyable text
        self.ip_layout.type_label = ParagraphLabel()
        self.ip_layout.type_label.__translate__ = False
        self.ip_layout.type_label.font_size = sp(20)
        self.ip_layout.type_label.pos_hint = {"center_x": 0.28, "center_y": 0.598}
        self.ip_layout.add_widget(self.ip_layout.type_label)

        self.ip_layout.affected_header = HeaderLabel()
        self.ip_layout.affected_header = HeaderLabel()
        self.ip_layout.affected_header.pos_hint = {"center_x": 0.7, "center_y": 0.64}
        self.ip_layout.add_widget(self.ip_layout.affected_header)

        # Make ip copyable text
        self.ip_layout.affected_label = ParagraphLabel()
        self.ip_layout.affected_label.__translate__ = False
        self.ip_layout.affected_label.halign = "center"
        self.ip_layout.affected_label.font_size = sp(20)
        self.ip_layout.affected_label.pos_hint = {"center_x": 0.7, "center_y": 0.598}
        self.ip_layout.add_widget(self.ip_layout.affected_label)

        self.ip_layout.network_header = HeaderLabel()
        self.ip_layout.network_header.pos_hint = {"center_x": 0.5, "center_y": 0.458}
        self.ip_layout.add_widget(self.ip_layout.network_header)

        # Make IP copyable text
        self.ip_layout.network_label = ParagraphLabel()
        self.ip_layout.network_label.__translate__ = False
        self.ip_layout.network_label.halign = "center"
        self.ip_layout.network_label.valign = "top"
        self.ip_layout.network_label.text_size = (400, 150)
        self.ip_layout.network_label.font_size = sp(20)
        self.ip_layout.network_label.line_height = sp(1.4)
        self.ip_layout.network_label.pos_hint = {"center_x": 0.5, "center_y": 0.3}
        self.ip_layout.add_widget(self.ip_layout.network_label)
        # </editor-fold>


        for widget in self.player_layout.children:
            constants.hide_widget(widget, True)
        for widget in self.ip_layout.children:
            constants.hide_widget(widget, True)

        self.add_widget(self.background)
        self.add_widget(self.blank_label)
        self.add_widget(self.player_layout)
        self.add_widget(self.ip_layout)
        # </editor-fold>


    # Actually updates data in panel based off of rule
    def update_panel(self, displayed_rule: acl.AclRule, rule_scope: str):

        self.displayed_scope = rule_scope
        filtered_name = displayed_rule.rule.replace("!g", "").replace("!w", "")
        panel_options = []

        # Player layout ------------------------------------------------------------------------------------------------
        if displayed_rule.rule_type == "player":

            # Effective access colors
            if displayed_rule.display_data['effective_access'] == constants.translate("Operator access"):
                widget_color = self.color_dict['blue']
                self.player_layout.access_icon.source = icon_path('promote.png')
            elif displayed_rule.display_data['effective_access'] == constants.translate("No access"):
                widget_color = self.color_dict['red']
                self.player_layout.access_icon.source = icon_path('close-circle-outline.png')
            else:
                widget_color = self.color_dict['purple']
                self.player_layout.access_icon.source = icon_path('chevron-up-circle-sharp.png')


            if self.displayed_type != "player":
                for widget in self.player_layout.children:
                    constants.hide_widget(widget, False)
                for widget in self.ip_layout.children:
                    constants.hide_widget(widget, True)


            # Change panel attributes ----------------------------------------------------------------------------------


            # Change name in header
            self.player_layout.name_label.text = filtered_name
            self.player_layout.name_label.texture_update()
            texture_size = 0.001 * self.player_layout.name_label.texture_size[0]
            self.player_layout.header_icon.pos_hint = {"center_x": 0.485 - texture_size, "center_y": 0.808}

            # Change icon in header
            # self.player_layout.header_icon.source = os.path.join(constants.gui_assets, 'steve.png')
            # def update_source(*a):
            #     source = constants.get_player_head(filtered_name)
            #     def main_thread(*b):
            #         if self.player_layout.name_label.text == filtered_name:
            #             self.player_layout.header_icon.source = source
            #     Clock.schedule_once(main_thread, 0)
            # threading.Timer(0, update_source).start()


            # Online status
            if constants.server_manager.current_server and constants.server_manager.current_server.user_online(displayed_rule.rule):
                self.player_layout.online_label.color = self.color_dict['green']
                self.player_layout.online_icon.color = self.color_dict['green']
                self.player_layout.online_label.text = "Currently online"
                self.player_layout.online_icon.source = icon_path('radio-button-on-sharp.png')

            else:
                self.player_layout.online_label.color = self.color_dict['gray']
                self.player_layout.online_icon.color = self.color_dict['gray']
                try:
                    last_login = (dt.now() - dt.strptime(displayed_rule.extra_data['latest-login'], '%Y-%m-%d %H:%M:%S'))
                    d = {"days": last_login.days}
                    d["years"], rem = divmod(last_login.days, 365)
                    d["months"], rem = divmod(last_login.days, 30)
                    d["hours"], rem = divmod(last_login.seconds, 3600)
                    d["minutes"], d["seconds"] = divmod(rem, 60)

                    if d['years'] > 0:
                        time_formatted = (f"{d['years']} {constants.translate('year' + ('s' if d['years'] > 1 else ''))} " if d['years'] > 0 else "")
                    elif d['months'] > 0:
                        time_formatted = (f"{d['months']} {constants.translate('month' + ('s' if d['months'] > 1 else ''))} " if d['months'] > 0 else "")
                    else:
                        time_formatted = (f"{d['days']}d " if d['days'] > 0 else "") + (f"{d['hours']}h " if d['hours'] > 0 else "") + (f"{d['minutes']}m " if d['minutes'] > 0 and d['days'] == 0 else "")

                    if not time_formatted:
                        time_formatted = 'seconds '

                    self.player_layout.online_label.text = f"Last online ${time_formatted}$ago"

                except ValueError:
                    self.player_layout.online_label.text = "Last online unknown"

                self.player_layout.online_icon.source = icon_path('radio-button-off-sharp.png')

            self.player_layout.online_label.texture_update()
            texture_size = 0.001 * self.player_layout.online_label.texture_size[0]
            self.player_layout.online_icon.pos_hint = {"center_x": 0.492 - texture_size, "center_y": 0.752}


            # Change UUID
            self.player_layout.uuid_label.text = displayed_rule.extra_data['uuid']


            # Change last IP
            if displayed_rule.extra_data['latest-ip'].startswith("127."):
                self.player_layout.ip_label.text = displayed_rule.extra_data['latest-ip']
            else:
                self.player_layout.ip_label.text = displayed_rule.extra_data['latest-ip'].split(":")[0]


            # Change location
            if " - " in displayed_rule.extra_data['ip-geo']:
                self.player_layout.geo_label.text = displayed_rule.extra_data['ip-geo'].replace(" - ", "\n")
                self.player_layout.geo_label.pos_hint = {"center_x": 0.7, "center_y": 0.48}
            else:
                self.player_layout.geo_label.text = displayed_rule.extra_data['ip-geo']
                self.player_layout.geo_label.pos_hint = {"center_x": 0.7, "center_y": 0.499}
            self.player_layout.geo_label.font_size = sp(20) if len(displayed_rule.extra_data['ip-geo']) < 15 else sp(18)


            # Change effective access
            very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["bold"])
            final_text = f"[color={widget_color}][font={very_bold_font}][size={round(sp(21))}]{displayed_rule.display_data['effective_access']}[/size][/font][/color]"
            banned = False

            # Display ban data
            if displayed_rule.display_data['ip_ban'] and displayed_rule.display_data['ban']:
                final_text += f"\n[color={self.color_dict['red']}]{constants.translate('Banned IP & user')}[/color]"
                banned = True
            elif displayed_rule.display_data['ip_ban']:
                final_text += f"\n[color={self.color_dict['red']}]{constants.translate('Banned IP')}[/color]"
                banned = True
            elif displayed_rule.display_data['ban']:
                final_text += f"\n[color={self.color_dict['red']}]{constants.translate('Banned user')}[/color]"
                banned = True
            else:
                final_text += "\n"

            # Display OP data
            final_text += (f"\n[color={self.color_dict['blue']}]{constants.translate('Operator')}[/color]" if displayed_rule.display_data['op'] else "\n")

            # Whitelist data
            if screen_manager.current_screen.acl_object._server['whitelist']:
                self.player_layout.access_line_3.opacity = 1
                if constants.app_config.locale == 'en':
                    final_text += ("\n[color=" + (f"{self.color_dict['green']}]Whitelisted" if displayed_rule.display_data['wl'] else f"{self.color_dict['red']}]Not whitelisted") + "[/color]")
                else:
                    final_text += ("\n[color=" + (f"{self.color_dict['green']}]{constants.translate('Allowed')}" if displayed_rule.display_data['wl'] else f"{self.color_dict['red']}]{constants.translate('Denied')}") + "[/color]")
            else:
                self.player_layout.access_line_3.opacity = 0
                self.player_layout.access_line_1.source = os.path.join(constants.gui_assets, "access_active.png")
                self.player_layout.access_line_2.source = os.path.join(constants.gui_assets, "access_active.png")
                self.player_layout.access_line_3.source = os.path.join(constants.gui_assets, "access_active.png")

            self.player_layout.access_label.text = final_text


            # Adjust graphic data for access
            if screen_manager.current_screen.acl_object._server['whitelist']:
                if displayed_rule.display_data['wl']:
                    self.player_layout.access_line_1.source = os.path.join(constants.gui_assets, "access_active.png")
                    self.player_layout.access_line_2.source = os.path.join(constants.gui_assets, "access_active.png")
                    self.player_layout.access_line_3.source = os.path.join(constants.gui_assets, "access_active.png")
                else:
                    self.player_layout.access_line_1.source = os.path.join(constants.gui_assets, "access_inactive.png")
                    self.player_layout.access_line_2.source = os.path.join(constants.gui_assets, "access_inactive.png")
                    self.player_layout.access_line_3.source = os.path.join(constants.gui_assets, "access_inactive.png")

                    if displayed_rule.display_data['op']:
                        self.player_layout.access_line_1.source = os.path.join(constants.gui_assets, "access_active.png")
                        self.player_layout.access_line_2.source = os.path.join(constants.gui_assets, "access_active.png")

            if banned:
                self.player_layout.access_line_1.source = os.path.join(constants.gui_assets, "access_inactive.png")
            elif displayed_rule.display_data['wl']:
                self.player_layout.access_line_1.source = os.path.join(constants.gui_assets, "access_active.png")


            # Set header names
            self.player_layout.uuid_header.text = "UUID"
            self.player_layout.ip_header.text = "IP"
            self.player_layout.geo_header.text = "Location"
            self.player_layout.access_header.text = f"Access to '${screen_manager.current_screen.acl_object._server['name']}$':"



            # Change colors based on rule access attributes ------------------------------------------------------------
            self.background.color = widget_color
            for widget in self.player_layout.children:

                if widget is self.player_layout.online_label or widget is self.player_layout.online_icon:
                    continue

                if widget.__class__.__name__ in ['Image', 'HeaderLabel']:
                    if widget in [self.player_layout.header_icon, self.player_layout.name_label]:
                        widget.color = constants.brighten_color(widget_color, 0.12)
                    elif widget in [self.player_layout.access_icon, self.player_layout.access_line_1, self.player_layout.access_line_2, self.player_layout.access_line_3]:
                        widget.color = constants.brighten_color(widget_color, 0.2)
                    else:
                        widget.color = constants.brighten_color(widget_color, 0.34)

                elif widget.__class__.__name__ == "ParagraphLabel":
                    widget.color = self.color_dict['gray'] if constants.translate("unknown") in widget.text.lower() else widget.default_color



            # Generate panel options -----------------------------------------------------------------------------------
            if screen_manager.current_screen.current_list == "ops":
                panel_options.append("demote" if displayed_rule.display_data['op'] else "promote")

            elif screen_manager.current_screen.current_list == "bans":
                if displayed_rule.display_data['ip_ban'] and displayed_rule.display_data['ban']:
                    panel_options.append("pardon IP & user")
                elif displayed_rule.display_data['ip_ban']:
                    if not displayed_rule.display_data['ban']:
                        panel_options.append("ban user")
                    panel_options.append("pardon IP")
                elif displayed_rule.display_data['ban']:
                    panel_options.append("pardon user")
                else:
                    panel_options.append("ban user")

                if displayed_rule.extra_data['latest-ip'] != "Unknown" and not displayed_rule.display_data['ip_ban']:
                    panel_options.append("ban IP")

            elif screen_manager.current_screen.current_list == "wl":
                panel_options.append("restrict" if displayed_rule.display_data['wl'] else "permit")

            panel_options.append("localize rule" if rule_scope == "global" else "globalize rule")


        # IP Layout ----------------------------------------------------------------------------------------------------
        else:

            # Effective access colors
            if "whitelist" in displayed_rule.display_data['rule_info'].lower():
                widget_color = self.color_dict['blue']
            else:
                widget_color = self.color_dict['red']

            if not screen_manager.current_screen.acl_object.rule_in_acl(displayed_rule.rule, 'subnets'):
                displayed_rule.display_data['rule_info'] = "Unaffected " + displayed_rule.display_data['rule_info'].split(" ")[0]
                displayed_rule.rule = displayed_rule.rule.replace("!w", "").replace("!g", "").strip()
                screen_manager.current_screen.displayed_rule = displayed_rule
                widget_color = self.color_dict['purple']

            if self.displayed_type != "ip":
                for widget in self.player_layout.children:
                    constants.hide_widget(widget, True)
                for widget in self.ip_layout.children:
                    constants.hide_widget(widget, False)



            # Change panel attributes ----------------------------------------------------------------------------------


            # Change IP address in header
            self.ip_layout.name_label.text = filtered_name
            self.ip_layout.name_label.texture_update()
            texture_size = 0.001 * self.ip_layout.name_label.texture_size[0]
            self.ip_layout.header_icon.pos_hint = {"center_x": 0.485 - texture_size, "center_y": 0.808}


            # Change rule type
            self.ip_layout.type_label.text = displayed_rule.display_data['rule_info']


            # Change affected users
            users = displayed_rule.display_data['affected_users']
            if users == 0:
                self.ip_layout.affected_label.text = f"0 {constants.translate('users')}"
                self.ip_layout.affected_label.color = self.color_dict['gray']
            else:
                self.ip_layout.affected_label.text = f"{users:,} {constants.translate('user' + 's' if users > 1 else '')}"
                self.ip_layout.affected_label.color = self.color_dict['green'] if "whitelist" in displayed_rule.display_data['rule_info'].lower() else self.color_dict['red']


            # Change network info
            ip_count = acl.count_subnet(displayed_rule.rule.replace("!w", "").replace("!g", "").strip())
            ips = displayed_rule.display_data['ip_range'].split(" - ")
            self.ip_layout.network_label.text = f"{ips[0]} [color=#696997]-[/color] {ips[1]}"
            self.ip_layout.network_label.text += f"\n[color={self.color_dict['gray']}]{displayed_rule.display_data['subnet_mask']}"
            self.ip_layout.network_label.text += f"  ({ip_count:,} IP{'s' if ip_count > 1 else ''})[/color]"



            # Set header names
            self.ip_layout.type_header.text = "Rule Type"
            self.ip_layout.affected_header.text = "Affected"
            self.ip_layout.network_header.text = "Network"


            # Change colors based on rule access attributes ------------------------------------------------------------
            self.background.color = widget_color
            for widget in self.ip_layout.children:
                if widget.__class__.__name__ in ['Image', 'HeaderLabel']:
                    if widget in [self.ip_layout.header_icon, self.ip_layout.name_label]:
                        widget.color = constants.brighten_color(widget_color, 0.12)
                    else:
                        widget.color = constants.brighten_color(widget_color, 0.34)


            # Generate panel options -----------------------------------------------------------------------------------
            if screen_manager.current_screen.current_list == "bans":
                after_text = 'subnet' if 'subnet' in displayed_rule.display_data['rule_info'].lower() else 'IP'
                if "unaffected" in displayed_rule.display_data['rule_info'].lower():
                    panel_options.append(f"ban {after_text}")
                    panel_options.append(f"whitelist {after_text}")

                else:
                    if "whitelist" in displayed_rule.display_data['rule_info'].lower():
                        panel_options.append("remove rule")
                        panel_options.append(f"ban {after_text}")
                    else:
                        panel_options.append(f"pardon {after_text}")
                        panel_options.append(f"whitelist {after_text}")

                    panel_options.append("localize rule" if rule_scope == "global" else "globalize rule")

        panel_options = panel_options if panel_options else ['no options']
        self.options.change_options(panel_options)
        self.displayed_type = displayed_rule.rule_type


    # Changes rule attributes from options drop-down
    def modify_rule(self, option: str):

        current_list = screen_manager.current_screen.current_list.lower().strip()
        acl_object = screen_manager.current_screen.acl_object
        original_name = acl_object.displayed_rule.rule
        filtered_name = acl_object.displayed_rule.rule.replace("!w", "").replace("!g", "").strip()
        new_name = original_name
        new_scope = self.displayed_scope
        banner_text = ""
        hover_attr = None
        reload_page = False
        localize = False

        try:
            ip_addr = acl_object.displayed_rule.extra_data['latest-ip'].split(":")[0].strip()
        except KeyError:
            ip_addr = ""


        # Global options
        if "local" in option or "global" in option:
            if "localize" in option:
                acl_object.add_global_rule(original_name, current_list, remove=True)

                # If rule localized, enable on current list
                if current_list == "ops":
                    acl_object.op_player(acl_object.displayed_rule.rule)
                elif current_list == "bans":
                    acl_object.ban_player(acl_object.displayed_rule.rule)
                elif current_list == "wl":
                    acl_object.whitelist_player(acl_object.displayed_rule.rule)

                hover_attr = (
                    icon_path("earth-strike.png"), 'LOCALIZE',
                    (0.439, 0.839, 1, 1) if current_list == "ops" else
                    (1, 0.5, 0.65, 1) if current_list == "bans" else
                    (0.3, 1, 0.6, 1)
                )
                banner_text = f"'${filtered_name}$' is now locally applied"
                new_scope = "local"
                reload_page = True

            elif "globalize" in option:
                acl_object.add_global_rule(original_name, current_list, remove=False)
                hover_attr = (icon_path("earth-sharp.png"), 'GLOBALIZE', (0.953, 0.929, 0.38, 1))
                banner_text = f"'${filtered_name}$' is now globally applied"
                new_scope = "global"
                reload_page = True


        # Operator options
        elif current_list == "ops":
            if "demote" in option:
                if self.displayed_scope == "global":
                    acl_object.add_global_rule(original_name, current_list, remove=True)
                else:
                    acl_object.op_player(original_name, remove=True)

                hover_attr = (icon_path("close-circle.png"), 'DEMOTE', (1, 0.5, 0.65, 1))
                banner_text = f"'${filtered_name}$' was demoted"
                new_scope = "local"
                reload_page = True

            elif "promote" in option:
                acl_object.op_player(original_name, remove=False)
                hover_attr = (icon_path("promote.png"), 'PROMOTE', (0.3, 1, 0.6, 1))
                banner_text = f"'${filtered_name}$' was promoted"
                reload_page = True


        # Ban options Player/IP
        elif current_list == "bans":
            if acl_object.displayed_rule.rule_type == "player":
                if "ban user" in option:
                    acl_object.ban_player(original_name, remove=False)
                    hover_attr = (icon_path("close-circle.png"), 'BAN', (1, 0.5, 0.65, 1))
                    banner_text = f"'${filtered_name}$' is banned"
                    reload_page = True

                elif "ban IP" in option:
                    acl_object.ban_player(ip_addr, remove=False)

                    if self.displayed_scope == "global":
                        acl_object.add_global_rule(original_name, current_list, remove=True)

                    acl_object.ban_player(f"!w{ip_addr}", remove=True)
                    hover_attr = (icon_path("close-circle.png"), 'BAN', (1, 0.5, 0.65, 1))
                    banner_text = f"'${filtered_name}$' is banned"
                    reload_page = True

                if "pardon IP" in option and "user" in option:
                    acl_object.ban_player([original_name, ip_addr], remove=True)

                    if self.displayed_scope == "global":
                        acl_object.add_global_rule(original_name, current_list, remove=True)

                    # Whitelist IP if it's still in the rule list
                    if ip_addr in acl.gen_iplist(acl_object.rules['subnets']):
                        acl_object.ban_player(f"!w{ip_addr}", remove=False)

                    hover_attr = (icon_path("lock-open.png"), 'PARDON', (0.3, 1, 0.6, 1))
                    banner_text = f"'${filtered_name}$' is pardoned"
                    new_scope = "local"
                    reload_page = True

                elif "pardon user" in option:
                    if self.displayed_scope == "global":
                        acl_object.add_global_rule(original_name, current_list, remove=True)
                    else:
                        acl_object.ban_player(original_name, remove=True)

                    hover_attr = (icon_path("lock-open.png"), 'PARDON', (0.3, 1, 0.6, 1))
                    banner_text = f"'${filtered_name}$' is pardoned"
                    new_scope = "local"
                    reload_page = True

                elif "pardon IP" in option:
                    acl_object.ban_player(ip_addr, remove=True)

                    # Whitelist IP if it's still in the rule list
                    if ip_addr in acl.gen_iplist(acl_object.rules['subnets']):
                        acl_object.ban_player(f"!w{ip_addr}", remove=False)

                    hover_attr = (icon_path("lock-open.png"), 'PARDON', (0.3, 1, 0.6, 1))
                    banner_text = f"'${filtered_name}$' is pardoned"
                    new_scope = "local"
                    reload_page = True


            # IP rules
            else:
                if "ban" in option:
                    # If rule is global and ban is added, switch scope to local
                    if "whitelist" in acl_object.displayed_rule.display_data['rule_info'] and self.displayed_scope == "global":
                        new_scope = "local"

                    if "!w" in original_name:
                        acl_object.ban_player(original_name, remove=True)
                        acl_object.ban_player(filtered_name, remove=False)
                    else:
                        acl_object.ban_player(original_name, remove=False)
                    hover_attr = (icon_path("close-circle.png"), 'BAN', (1, 0.5, 0.65, 1))
                    banner_text = f"'${filtered_name}$' is banned"
                    new_name = filtered_name
                    reload_page = True

                elif "pardon" in option:
                    if self.displayed_scope == "global":
                        acl_object.add_global_rule(original_name, current_list, remove=True)
                    else:
                        acl_object.ban_player(original_name, remove=True)

                    hover_attr = (icon_path("lock-open.png"), 'PARDON', (0.3, 1, 0.6, 1))
                    banner_text = f"'${filtered_name}$' is pardoned"
                    new_scope = "local"
                    reload_page = True

                elif "remove" in option:
                    if self.displayed_scope == "global":
                        acl_object.add_global_rule(original_name, current_list, remove=True)
                    else:
                        acl_object.ban_player(original_name, remove=True)

                    hover_attr = (icon_path("shield-disabled-outline.png"), 'REMOVE', (0.7, 0.7, 1, 1))
                    banner_text = f"'${filtered_name}$' was removed"
                    new_scope = "local"
                    reload_page = True

                elif "whitelist" in option:
                    # If rule is global and whitelist is added, switch scope to local
                    if "ban" in acl_object.displayed_rule.display_data['rule_info'] and self.displayed_scope == "global":
                        new_scope = "local"

                    acl_object.ban_player(original_name, remove=True)
                    acl_object.ban_player(f"!w{filtered_name}", remove=False)
                    hover_attr = (icon_path("shield-checkmark-outline.png"), 'WHITELIST', (0.439, 0.839, 1, 1))
                    banner_text = f"'${filtered_name}$' is whitelisted"
                    new_name = f"!w{filtered_name}"
                    reload_page = True


        # Whitelist options
        elif current_list == "wl":
            if "restrict" in option:
                if self.displayed_scope == "global":
                    acl_object.add_global_rule(original_name, current_list, remove=True)
                else:
                    acl_object.whitelist_player(original_name, remove=True)

                hover_attr = (icon_path("close-circle.png"), 'RESTRICT', (1, 0.5, 0.65, 1))
                banner_text = f"'{filtered_name}' is restricted"
                new_scope = "local"
                reload_page = True

            elif "permit" in option:
                acl_object.whitelist_player(original_name, remove=False)
                hover_attr = (icon_path("checkmark-circle-sharp.png"), 'PERMIT', (0.3, 1, 0.6, 1))
                banner_text = f"'{filtered_name}' is permitted"
                reload_page = True


        if reload_page:

            screen_manager.current_screen.update_list(current_list, reload_children=False)

            Clock.schedule_once(
                functools.partial(
                    screen_manager.current_screen.show_banner,
                    hover_attr[2],
                    banner_text,
                    hover_attr[0],
                    2,
                    {"center_x": 0.5, "center_y": 0.965}
                ), 0
            )

            def trigger_highlight(*args):
                for rule_button in screen_manager.current_screen.scroll_layout.children:

                    if rule_button.rule.rule == original_name:
                        rule_button.highlight(rule_button.button.background_color, rule_button.text.color, hover_attr[2])

                    else:
                        rule_button.button.on_leave()
                        Animation.cancel_all(rule_button.button)
                        Animation.cancel_all(rule_button.text)
                        Animation.cancel_all(rule_button.icon)
                        rule_button.change_properties(rule_button.rule)

                    rule_button.button.ignore_hover = False

            Clock.schedule_once(trigger_highlight, 0)

        # Update display rule regardless of button pressed
        screen_manager.current_screen.update_user_panel(new_name, new_scope)

        # print(option)

class CreateServerAclScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self._ignore_keys = ['tab']
        self.header = None
        self.search_bar = None
        self.whitelist_toggle = None
        self.scroll_widget = None
        self.scroll_layout = None
        self.blank_label = None
        self.search_label = None
        self.list_header = None
        self.controls_button = None
        self.user_panel = None
        self.show_panel = False

        self.acl_object = None
        self._hash = None
        self.current_list = None

        self.filter_text = ""
        self.currently_filtering = False


    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        super()._on_keyboard_down(keyboard, keycode, text, modifiers)

        if ((keycode[1] == 'h' and control in modifiers and constants.os_name != 'macos') or (keycode[1] == 'h' and control in modifiers and 'shift' in modifiers and constants.os_name == 'macos')) and not self.popup_widget:
            self.controls_button.button.trigger_action()

        # Press
        if keycode[1] == 'tab' and not self._input_focused and self.name == screen_manager.current_screen.name:
            for button in self.walk():
                try:
                    if button.id == "input_button":
                        button.force_click()
                        break
                except AttributeError:
                    continue


    def update_user_panel(self, rule_name: str, rule_scope: str):

        # Generate rule list count
        rule_count = len(self.scroll_widget.data)
        panel_check = rule_count > 0


        # Hide user panel if there are no items
        if panel_check != self.show_panel:

            for child in self.user_panel.children:

                # Figure out how to make this not bug out when transitioning between rules, specifically with blank_text
                if child.__class__.__name__ == "Label":
                    child.opacity = (1 if panel_check else 0)
                else:
                    Animation(opacity=(1 if panel_check else 0), duration=0.3).start(child)

                # Make sure self.options shows and hides properly
                for widget in self.user_panel.options.children:
                    constants.hide_widget(widget, panel_check)

            self.show_panel = panel_check


        # Update displayed data on user panel
        if rule_name:
            self.acl_object.get_rule(rule_name)
            self.user_panel.update_panel(self.acl_object.displayed_rule, rule_scope)


        # If rule is displayed
        if self.acl_object.displayed_rule:

            if self.user_panel.blank_label.opacity > 0:
                Animation.stop_all(self.user_panel.blank_label)
                constants.hide_widget(self.user_panel.blank_label, True)
                for child in self.user_panel.options.children:
                    constants.hide_widget(child, False)

        # If rule is not displayed
        else:

            if self.user_panel.blank_label.opacity == 0:
                constants.hide_widget(self.user_panel.blank_label, False)
                for child in self.user_panel.options.children:
                    constants.hide_widget(child, True)


        if not panel_check:
            for widget in self.user_panel.options.children:
                constants.hide_widget(widget, True)


        if self.acl_object.displayed_rule:
            Animation.stop_all(self.user_panel.blank_label)
            constants.hide_widget(self.user_panel.blank_label, True)
            self.user_panel.blank_label.opacity = 0


    # Filter data from search bar
    def search_filter(self, query):

        def lock(*args):
            self.currently_filtering = False
            if self.filter_text != self.search_bar.text:
                self.search_filter(self.search_bar.text)

        # Prevent refreshes shorter than 0.5s
        if not self.currently_filtering:
            self.currently_filtering = True
            self.filter_text = query

            # Filter data

            # Reset scroll
            self.scroll_widget.scroll_y = 1

            total_list = [{'rule': rule} for rule in self.acl_object.list_items[self.current_list]['enabled']]
            total_list.extend([{'rule': rule} for rule in self.acl_object.list_items[self.current_list]['disabled']])

            original_len = len(total_list)

            if query:
                filtered_list = []
                for rule in total_list:
                    rule_obj = rule['rule']

                    # Name matches query
                    if query.lower().replace("!w", "").replace("!g", "") in rule_obj.rule.lower():
                        filtered_list.append(rule)

                    # Scope matches query
                    elif query.lower() == rule_obj.rule_scope:
                        filtered_list.append(rule)

                    # Rule type matches query
                    elif query.lower() == rule_obj.rule_type:
                        filtered_list.append(rule)

                    # Location matches query
                    else:
                        try:
                            location = acl.get_uuid(rule_obj.rule)['ip-geo']
                            if query.lower() in location.lower().replace(" - ", " ") and location != "Unknown":
                                filtered_list.append(rule)
                        except KeyError:
                            pass


                total_list = filtered_list
                del filtered_list

            # Show hint text if there are no rules

            self.set_data(total_list)


            # Show search label if it exists
            Animation.stop_all(self.search_label)
            if self.filter_text and len(self.scroll_widget.data) == 0 and original_len > 0:
                self.search_label.text = f"No results for '{self.filter_text}'"
                Animation(opacity=1, duration=0.2).start(self.search_label)
            else:
                Animation(opacity=0, duration=0.05).start(self.search_label)


            # Unlock the lock
            timer = threading.Timer(0.5, function=lock)
            timer.start()


    # ops, bans, wl
    def update_list(self, list_type: str, reload_children=True, reload_panel=False):

        if "op" in list_type:
            list_type = "ops"
        elif "ban" in list_type:
            list_type = "bans"
        else:
            list_type = "wl"

        # Reset scroll
        list_changed = False
        if self.current_list != list_type:
            list_changed = True
            self.scroll_widget.scroll_y = 1

        # Create list data with list type
        self.current_list = list_type

        # Check if there's an active filter
        if self.filter_text:
            self.search_filter(self.filter_text)
        else:
            total_list = [{'rule': rule} for rule in self.acl_object.list_items[list_type]['enabled']]
            total_list.extend([{'rule': rule} for rule in self.acl_object.list_items[list_type]['disabled']])

            self.set_data(total_list)

        rule_count = len(self.acl_object.rules[list_type])
        if list_type == "bans":
            rule_count += len(self.acl_object.rules['subnets'])


        # Modify header content
        very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["very-bold"])
        header_content = (f'[color=#6A6ABA]{constants.translate("No rules")}[/color]' if rule_count == 0 else f'[font={very_bold_font}]1[/font] {constants.translate("rule")}' if rule_count == 1 else f'[font={very_bold_font}]{rule_count:,}[/font] {constants.translate("rules")}')
        if list_type == "wl" and not self.acl_object._server['whitelist']:
            header_content += f" ({constants.translate('inactive')})"

        # header_content = (" "*(len(header_content) - (55 if 'inactive' not in header_content else 50))) + header_content

        for child in self.header.children:
            if child.id == "text":
                child.text = header_content
                child.halign = "left"
                child.text_size[0] = 500
                child.x = Window.width / 2 + 240
                break


        display_count = len(self.acl_object.list_items[list_type]['enabled']) + len(self.acl_object.list_items[list_type]['disabled'])

        # If there are no rules, say as much with a label
        constants.hide_widget(self.list_header.global_rule, display_count == 0)
        constants.hide_widget(self.list_header.enabled_rule, display_count == 0)
        constants.hide_widget(self.list_header.disabled_rule, display_count == 0)


        if display_count == 0:
            if self.blank_label.opacity < 1:
                self.blank_label.text = "No rules available, add them above"
                constants.hide_widget(self.blank_label, False)
                self.blank_label.opacity = 0
                Animation(opacity=1, duration=0.2).start(self.blank_label)
                Animation(opacity=0, duration=0.2).start(self.search_label)

        # If there are rules, display them here
        else:
            # Show search label if it exists
            Animation.stop_all(self.search_label)
            # print(len(self.scroll_widget.data))
            if self.filter_text and len(self.scroll_widget.data) == 0:
                self.search_label.text = f"{constants.translate('No results for')} '{self.filter_text}'"
                Animation(opacity=1, duration=0.2).start(self.search_label)
            else:
                Animation(opacity=0, duration=0.2).start(self.search_label)

            self.list_header.remove_widget(self.list_header.enabled_rule)
            self.list_header.enabled_rule = RelativeLayout()
            self.list_header.enabled_rule.add_widget(
                BannerObject(
                    size=(120, 32),
                    color=(0.439, 0.839, 1, 1) if list_type == 'ops'
                    else (1, 0.5, 0.65, 1) if list_type == 'bans'
                    else (0.3, 1, 0.6, 1),

                    text="operator" if list_type == 'ops'
                    else "banned" if list_type == 'bans'
                    else "allowed",

                    icon="settings-sharp.png" if list_type == 'ops'
                    else "close-circle-sharp.png" if list_type == 'bans'
                    else "checkmark-circle-sharp.png"
                )
            )
            self.list_header.add_widget(self.list_header.enabled_rule)


            self.list_header.remove_widget(self.list_header.disabled_rule)
            self.list_header.disabled_rule = RelativeLayout()
            self.list_header.disabled_rule.add_widget(
                BannerObject(
                    size=(125, 32),
                    color=(0.6, 0.5, 1, 1) if list_type == 'ops'
                    else (0.3, 1, 0.6, 1) if list_type == 'bans'
                    else (1, 0.5, 0.65, 1) if self.acl_object._server['whitelist'] else(0.7, 0.7, 0.7, 1),

                    text="standard" if list_type == 'ops'
                    else "allowed" if list_type == 'bans'
                    else "restricted",

                    icon="person-circle-sharp.png" if list_type == 'ops'
                    else "checkmark-circle-sharp.png" if list_type == 'bans'
                    else "close-circle-sharp.png"
                )
            )
            self.list_header.add_widget(self.list_header.disabled_rule)

            constants.hide_widget(self.blank_label, True)

        # Change whitelist toggle visibility based on list_type
        constants.hide_widget(self.whitelist_toggle, list_type != 'wl')

        # Refresh all buttons
        if reload_children:
            for rule_button in self.scroll_layout.children:
                rule_button.change_properties(rule_button.rule)


            # Dirty fix to hide grid resize that fixes RuleButton text.pos_hint x
            if list_changed:
                self.scroll_widget.opacity = 0
                self.scroll_layout.cols = 1
                self.resize_bind()
                def animate_grid(*args):
                    Animation.stop_all(self.scroll_widget)
                    Animation(opacity=1, duration=0.3).start(self.scroll_widget)
                Clock.schedule_once(animate_grid, 0)


        # Update displayed rule options
        if (self.acl_object.displayed_rule and list_changed) or (reload_panel and self.acl_object.displayed_rule):
            global_rules = acl.load_global_acl()
            self.acl_object.displayed_rule.acl_group = list_type
            rule_scope = acl.check_global_acl(global_rules, self.acl_object.displayed_rule).rule_scope
            self.update_user_panel(self.acl_object.displayed_rule.rule, rule_scope)


    def set_data(self, data):

        if self.scroll_layout:
            self.scroll_layout.rows = None

        self.scroll_widget.data = data

        if self.resize_bind:
            self.resize_bind()


    def generate_menu(self, **kwargs):

        if not constants.new_server_info['acl_object']:
            constants.new_server_name()
            constants.new_server_info['acl_object'] = acl.AclManager(constants.new_server_info['name'])
            self.acl_object = constants.new_server_info['acl_object']

        # If self._hash doesn't match, set list to ops by default
        if self._hash != constants.new_server_info['_hash']:
            self.acl_object = constants.new_server_info['acl_object']
            self._hash = constants.new_server_info['_hash']
            self.current_list = 'ops'

        self.show_panel = False

        self.filter_text = ""
        self.currently_filtering = False


        # Scroll list
        self.scroll_widget = RecycleViewWidget(position=(0.5, 0.43), view_class=RuleButton)
        self.scroll_layout = RecycleGridLayout(spacing=[110, -15], size_hint_y=None, padding=[60, 20, 0, 30])
        test_rule = RuleButton()

        # Bind / cleanup height on resize
        def resize_scroll(*args):
            self.scroll_widget.height = Window.height // 1.65
            rule_width = test_rule.width + self.scroll_layout.spacing[0] + 2
            rule_width = int(((Window.width // rule_width) // 1) - 2)

            self.scroll_layout.cols = rule_width
            self.scroll_layout.rows = 2 if len(self.scroll_widget.data) <= rule_width else None

            self.user_panel.x = Window.width - (self.user_panel.size_hint_max[0] * 0.93)

            # Reposition header
            for child in self.header.children:
                if child.id == "text":
                    child.halign = "left"
                    child.text_size[0] = 500
                    child.x = Window.width / 2 + 240
                    break

            self.search_label.pos_hint = {"center_x": (0.28 if Window.width < 1300 else 0.5), "center_y": 0.42}
            self.search_label.text_size = (Window.width / 3, 500)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        self.scroll_layout.bind(minimum_height=self.scroll_layout.setter('height'))
        self.scroll_layout.id = 'scroll_content'


        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.735}, pos=self.scroll_widget.pos, size=(self.scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.14}, pos=self.scroll_widget.pos, size=(self.scroll_widget.width // 1.5, -60))

        # Generate buttons on page load
        very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["very-bold"])
        selector_text = "operators" if self.current_list == "ops" else "bans" if self.current_list == "bans" else "whitelist"
        self.page_selector = DropButton(selector_text, (0.5, 0.89), options_list=['operators', 'bans', 'whitelist'], input_name='ServerAclTypeInput', x_offset=-210, facing='center', custom_func=self.update_list)
        header_content = ""
        self.header = HeaderText(header_content, '', (0, 0.89), fixed_x=True, no_line=True, __translate__ = (False, True))


        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(self.header)


        # Search bar
        self.search_bar = AclInput(pos_hint={"center_x": 0.5, "center_y": 0.815})
        buttons.append(input_button('Add Rules...', (0.5, 0.815), input_name='AclInput'))


        # Whitelist toggle button
        def toggle_whitelist(boolean):
            self.acl_object.enable_whitelist(boolean)

            Clock.schedule_once(
                functools.partial(
                    self.show_banner,
                    (0.553, 0.902, 0.675, 1) if boolean else (0.937, 0.831, 0.62, 1),
                    f"Server whitelist {'en' if boolean else 'dis'}abled",
                    "shield-checkmark-outline.png" if boolean else "shield-disabled-outline.png",
                    2,
                    {"center_x": 0.5, "center_y": 0.965}
                ), 0
            )

            # Update list
            self.update_list('wl', reload_children=True, reload_panel=True)

        self.whitelist_toggle = toggle_button('whitelist', (0.5, 0.89), default_state=self.acl_object._server['whitelist'], x_offset=-395, custom_func=toggle_whitelist)


        # Legend for rule types
        self.list_header = BoxLayout(orientation="horizontal", pos_hint={"center_x": 0.5, "center_y": 0.749}, size_hint_max=(400, 100))
        self.list_header.global_rule = RelativeLayout()
        self.list_header.global_rule.add_widget(BannerObject(size=(120, 32), color=test_rule.global_icon_color, text="global", icon="earth-sharp.png", icon_side="left"))
        self.list_header.add_widget(self.list_header.global_rule)

        self.list_header.enabled_rule = RelativeLayout()
        self.list_header.enabled_rule.add_widget(BannerObject(size=(120, 32), color=(1,1,1,1), text=" ", icon="add.png"))
        self.list_header.add_widget(self.list_header.enabled_rule)

        self.list_header.disabled_rule = RelativeLayout()
        self.list_header.disabled_rule.add_widget(BannerObject(size=(120, 32), color=(1,1,1,1), text=" ", icon="add.png"))
        self.list_header.add_widget(self.list_header.disabled_rule)


        # Add blank label to the center, then load self.gen_search_results()
        self.blank_label = Label()
        self.blank_label.text = ""
        self.blank_label.font_name = os.path.join(constants.gui_assets, 'fonts', constants.fonts['italic'])
        self.blank_label.pos_hint = {"center_x": 0.5, "center_y": 0.48}
        self.blank_label.font_size = sp(23)
        self.blank_label.opacity = 0
        self.blank_label.color = (0.6, 0.6, 1, 0.35)
        float_layout.add_widget(self.blank_label)


        # Lol search label idek
        self.search_label = Label()
        self.search_label.__translate__ = False
        self.search_label.text = ""
        self.search_label.halign = "center"
        self.search_label.valign = "center"
        self.search_label.font_name = os.path.join(constants.gui_assets, 'fonts', constants.fonts['italic'])
        self.search_label.pos_hint = {"center_x": 0.28, "center_y": 0.42}
        self.search_label.font_size = sp(25)
        self.search_label.color = (0.6, 0.6, 1, 0.35)
        float_layout.add_widget(self.search_label)


        # Controls button
        def show_controls():

            controls_text = """This menu shows enabled rules from files like 'ops.json', and disabled rules as others who have joined. Global rules are applied to every server. Rules can be modified in a few different ways:

â€¢ Right-click a rule to view, and see more options

â€¢ Left-click a rule to toggle permission

â€¢ Press middle-mouse to toggle globally

Rules can be filtered with the search bar, and can be added with the 'Add Rules' button or by pressing 'TAB'. The visible list can be switched between operators, bans, and the whitelist from the drop-down at the top."""

            Clock.schedule_once(
                functools.partial(
                    self.show_popup,
                    "controls",
                    "Controls",
                    controls_text,
                    (None)
                ),
                0
            )
        self.controls_button = IconButton('controls', {}, (70, 110), (None, None), 'question.png', clickable=True, anchor='right', click_func=show_controls)
        float_layout.add_widget(self.controls_button)


        # User panel
        self.user_panel = AclRulePanel()


        # Append scroll view items
        self.scroll_widget.add_widget(self.scroll_layout)
        float_layout.add_widget(self.scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)
        float_layout.add_widget(self.page_selector)
        float_layout.add_widget(self.list_header)
        float_layout.add_widget(self.search_bar)
        float_layout.add_widget(self.whitelist_toggle)
        float_layout.add_widget(self.user_panel)

        buttons.append(ExitButton('Back', (0.5, 0.099), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        menu_name = f"Create '{constants.new_server_info['name']}', Access Control"
        float_layout.add_widget(generate_title(f"Access Control Manager: '{constants.new_server_info['name']}'"))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)

        # Generate page content
        self.update_list(self.current_list, reload_children=True)


        # Generate user panel info
        current_list = acl.deepcopy(self.acl_object.rules[self.current_list])
        if self.current_list == "bans":
            current_list.extend(acl.deepcopy(self.acl_object.rules['subnets']))

        if self.acl_object.displayed_rule and current_list:
            global_rules = acl.load_global_acl()
            self.acl_object.displayed_rule.acl_group = self.current_list
            rule_scope = acl.check_global_acl(global_rules, self.acl_object.displayed_rule).rule_scope
            self.update_user_panel(self.acl_object.displayed_rule.rule, rule_scope)
        else:
            self.update_user_panel(None, None)

class CreateServerAclRuleScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'

        self._ignore_tree = True

        self.acl_input = None
        self.current_list = None
        self.acl_object = None


    def apply_rules(self):

        # Actually apply rules
        original_list = self.acl_object._process_query(self.acl_input.text, self.current_list)

        applied_list = []
        applied_list.extend(original_list['global'])
        applied_list.extend(original_list['local'])


        # Generate banner
        banner_text = "Added "
        "Added '$$'"

        if len(applied_list) == 1:
            banner_text += f"'${acl.get_uuid(applied_list[0])['name'] if applied_list[0].count('.') < 3 else applied_list[0]}$'"
        elif len(applied_list) < 3:
            banner_text += f"'${', '.join([(acl.get_uuid(x)['name'] if x.count('.') < 3 else x) for x in applied_list[0:2]])}$'"
        else:
            banner_text += f"'${acl.get_uuid(applied_list[0])['name'] if applied_list[0].count('.') < 3 else applied_list[0]}$' and {len(applied_list) - 1:,} more"


        Clock.schedule_once(
            functools.partial(
                screen_manager.current_screen.show_banner,
                (0.553, 0.902, 0.675, 1),
                banner_text,
                "add-circle-sharp.png",
                2.5,
                {"center_x": 0.5, "center_y": 0.965}
            ), 0
        )

        # Return to previous screen
        self.acl_object.get_rule(applied_list[0])
        previous_screen()

        def update_panel(*args):
            screen_manager.current_screen.update_user_panel(applied_list[0], applied_list[0] in original_list['global'])

        Clock.schedule_once(update_panel, 0)

        # Prevent back button from going back to this screen
        for screen in constants.screen_tree:
            if screen == self.name:
                constants.screen_tree.remove(self.name)


    def generate_menu(self, **kwargs):
        # Generate buttons on page load

        class HintLabel(RelativeLayout):

            def icon_pos(self, *args):
                self.text.texture_update()
                self.icon.pos_hint = {"center_x": 0.57 - (0.005 * self.text.texture_size[0]), "center_y": 0.95}

            def __init__(self, pos, label, **kwargs):
                super().__init__(**kwargs)

                self.pos_hint = {"center_x": 0.5, "center_y": pos}
                self.size_hint_max = (100, 50)

                self.text = Label()
                self.text.id = 'text'
                self.text.size_hint = (None, None)
                self.text.markup = True
                self.text.halign = "center"
                self.text.valign = "center"
                self.text.text = "        " + label
                self.text.font_size = sp(22)
                self.text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
                self.text.color = (0.6, 0.6, 1, 0.55)

                self.icon = Image()
                self.icon.id = 'icon'
                self.icon.source = os.path.join(constants.gui_assets, 'icons', 'information-circle-outline.png')
                self.icon.pos_hint = {"center_y": 0.95}
                self.icon.color = (0.6, 0.6, 1, 1)

                self.add_widget(self.text)
                self.add_widget(self.icon)

                self.bind(size=self.icon_pos)
                self.bind(pos=self.icon_pos)


        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'

        self.current_list = screen_manager.get_screen("CreateServerAclScreen").current_list
        self.acl_object = screen_manager.get_screen("CreateServerAclScreen").acl_object

        if self.current_list == "bans":
            header_message = "Enter usernames/IPs delimited, by, commas"
            float_layout.add_widget(HintLabel(0.464, "Use   [color=#FFFF33]!g <rule>[/color]   to apply globally on all servers"))
            float_layout.add_widget(HintLabel(0.374, "You can ban IP ranges/whitelist:   [color=#FF6666]192.168.0.0-150[/color], [color=#66FF88]!w 192.168.1.1[/color]"))
        else:
            header_message = "Enter usernames delimited, by, commas"
            float_layout.add_widget(HintLabel(0.425, "Use   [color=#FFFF33]!g <rule>[/color]   to apply globally on all servers"))

        float_layout.add_widget(InputLabel(pos_hint={"center_x": 0.5, "center_y": 0.72}))
        float_layout.add_widget(HeaderText(header_message, '', (0, 0.8)))
        self.acl_input = AclRuleInput(pos_hint={"center_x": 0.5, "center_y": 0.64}, text="")
        float_layout.add_widget(self.acl_input)

        buttons.append(next_button('Add Rules', (0.5, 0.24), True, next_screen='CreateServerAclScreen'))
        buttons.append(ExitButton('Back', (0.5, 0.14), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        menu_name = f"Create '{constants.new_server_info['name']}', Access Control"
        list_name = "Operators" if self.current_list == "ops" else "Bans" if self.current_list == "bans" else "Whitelist"
        float_layout.add_widget(generate_title(f"Access Control Manager: Add {list_name}"))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)
        self.acl_input.grab_focus()



# Create Server Step 6:  Server Options --------------------------------------------------------------------------------

# Create ACL options, and Addon Options
class CreateServerOptionsScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'

    def generate_menu(self, **kwargs):

        # Scroll list
        scroll_widget = ScrollViewWidget()
        scroll_anchor = AnchorLayout()
        scroll_layout = GridLayout(cols=1, spacing=10, size_hint_max_x=1050, size_hint_y=None, padding=[0, 16, 0, 30])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 2
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        scroll_layout.bind(minimum_height=scroll_layout.setter('height'))
        scroll_layout.id = 'scroll_content'

        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.77}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.272}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60))

        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(HeaderText(f"Optionally, configure additional properties", '', (0, 0.86)))

        # If server type != vanilla, append addon manger button and extend float_layout widget
        if constants.new_server_info['type'] != 'vanilla':
            sub_layout = ScrollItem()
            sub_layout.add_widget(MainButton('Add-on Manager', (0.5, 0.5), 'extension-puzzle-sharp.png'))
            scroll_layout.add_widget(sub_layout)

        # Gamemode dropdown
        sub_layout = ScrollItem()
        sub_layout.add_widget(blank_input(pos_hint={"center_x": 0.5, "center_y": 0.5}, hint_text="gamemode"))
        sub_layout.add_widget(DropButton(constants.new_server_info['server_settings']['gamemode'], (0.5, 0.5), options_list=['survival', 'adventure', 'creative'], input_name='ServerModeInput'))
        scroll_layout.add_widget(sub_layout)

        # Difficulty dropdown
        sub_layout = ScrollItem()
        sub_layout.add_widget(blank_input(pos_hint={"center_x": 0.5, "center_y": 0.5}, hint_text="difficulty"))
        sub_layout.add_widget(DropButton(constants.new_server_info['server_settings']['difficulty'], (0.5, 0.5), options_list=['peaceful', 'easy', 'normal', 'hard', 'hardcore'], input_name='ServerDiffInput'))
        scroll_layout.add_widget(sub_layout)

        # Geyser switch for bedrock support
        if constants.version_check(constants.new_server_info['version'], ">=", "1.13.2")\
        and constants.new_server_info['type'].lower() in ['spigot', 'paper', 'purpur', 'fabric', 'quilt', 'neoforge']:
            sub_layout = ScrollItem()
            sub_layout.add_widget(blank_input(pos_hint={"center_x": 0.5, "center_y": 0.5}, hint_text="bedrock support (geyser)"))
            sub_layout.add_widget(toggle_button('geyser_support', (0.5, 0.5), default_state=constants.new_server_info['server_settings']['geyser_support']))
            scroll_layout.add_widget(sub_layout)

        # Disable chat reporting by default
        if constants.version_check(constants.new_server_info['version'], ">=", "1.19")\
        and constants.new_server_info['type'].lower() != "vanilla":
            sub_layout = ScrollItem()
            sub_layout.add_widget(blank_input(pos_hint={"center_x": 0.5, "center_y": 0.5}, hint_text="disable chat reporting"))
            sub_layout.add_widget(toggle_button('chat_report', (0.5, 0.5), default_state=constants.new_server_info['server_settings']['disable_chat_reporting']))
            scroll_layout.add_widget(sub_layout)

        # PVP switch button
        sub_layout = ScrollItem()
        sub_layout.add_widget(blank_input(pos_hint={"center_x": 0.5, "center_y": 0.5}, hint_text="enable PVP"))
        sub_layout.add_widget(toggle_button('pvp', (0.5, 0.5), default_state=constants.new_server_info['server_settings']['pvp']))
        scroll_layout.add_widget(sub_layout)

        # Enable keep inventory
        if constants.version_check(constants.new_server_info['version'], ">=", "1.4.2"):
            sub_layout = ScrollItem()
            sub_layout.add_widget(blank_input(pos_hint={"center_x": 0.5, "center_y": 0.5}, hint_text="keep inventory"))
            sub_layout.add_widget(toggle_button('keep_inventory', (0.5, 0.5), default_state=constants.new_server_info['server_settings']['keep_inventory']))
            scroll_layout.add_widget(sub_layout)

        # Spawn protection switch button
        sub_layout = ScrollItem()
        sub_layout.add_widget(blank_input(pos_hint={"center_x": 0.5, "center_y": 0.5}, hint_text="enable spawn protection"))
        sub_layout.add_widget(toggle_button('spawn_protection', (0.5, 0.5), default_state=constants.new_server_info['server_settings']['spawn_protection']))
        scroll_layout.add_widget(sub_layout)

        # Enable daylight cycle
        if constants.version_check(constants.new_server_info['version'], ">=", "1.4.2"):
            label = "daylight & weather cycle" if constants.version_check(constants.new_server_info['version'], ">=", "1.11") else "daylight cycle"
            sub_layout = ScrollItem()
            sub_layout.add_widget(blank_input(pos_hint={"center_x": 0.5, "center_y": 0.5}, hint_text=label))
            sub_layout.add_widget(toggle_button('daylight_weather_cycle', (0.5, 0.5), default_state=constants.new_server_info['server_settings']['daylight_weather_cycle']))
            scroll_layout.add_widget(sub_layout)

        # Spawn creatures switch button
        sub_layout = ScrollItem()
        sub_layout.add_widget(blank_input(pos_hint={"center_x": 0.5, "center_y": 0.5}, hint_text="spawn creatures"))
        sub_layout.add_widget(toggle_button('spawn_creatures', (0.5, 0.5), default_state=constants.new_server_info['server_settings']['spawn_creatures']))
        scroll_layout.add_widget(sub_layout)

        # Enable command blocks switch button
        if constants.version_check(constants.new_server_info['version'], ">=", "1.4.2"):
            sub_layout = ScrollItem()
            sub_layout.add_widget(blank_input(pos_hint={"center_x": 0.5, "center_y": 0.5}, hint_text="enable command blocks"))
            sub_layout.add_widget(toggle_button('command_blocks', (0.5, 0.5), default_state=constants.new_server_info['server_settings']['command_blocks']))
            scroll_layout.add_widget(sub_layout)

        # Random tick speed input
        if constants.version_check(constants.new_server_info['version'], ">=", "1.4.2"):
            sub_layout = ScrollItem()
            sub_layout.add_widget(ServerTickSpeedInput(pos_hint={"center_x": 0.5, "center_y": 0.5}, text=constants.new_server_info['server_settings']['random_tick_speed']))
            scroll_layout.add_widget(sub_layout)

        # Max player input
        sub_layout = ScrollItem()
        sub_layout.add_widget(ServerPlayerInput(pos_hint={"center_x": 0.5, "center_y": 0.5}, text=constants.new_server_info['server_settings']['max_players']))
        scroll_layout.add_widget(sub_layout)

        # Append scroll view items
        scroll_anchor.add_widget(scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)

        buttons.append(next_button('Next', (0.5, 0.21), False, next_screen='CreateServerReviewScreen'))
        buttons.append(ExitButton('Back', (0.5, 0.12), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        menu_name = f"Create '{constants.new_server_info['name']}'"
        float_layout.add_widget(page_counter(6, 7, (0, 0.868)))
        float_layout.add_widget(generate_title(menu_name))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)



# Create Server Step 6:  Add-on Options --------------------------------------------------------------------------------

class AddonButton(HoverButton):

    def toggle_installed(self, installed, *args):
        self.installed = installed
        self.install_image.opacity = 1 if installed and not self.show_type else 0
        self.install_label.opacity = 1 if installed and not self.show_type else 0
        self.title.text_size = (self.size_hint_max[0] * (0.7 if installed else 0.94), self.size_hint_max[1])
        self.background_normal = os.path.join(constants.gui_assets, f'{self.id}{"_installed" if self.installed and not self.show_type else ""}.png')
        self.resize_self()

    def animate_addon(self, image, color, **kwargs):
        image_animate = Animation(duration=0.05)

        def f(w):
            w.background_normal = image

        Animation(color=color, duration=0.06).start(self.title)
        Animation(color=color, duration=0.06).start(self.subtitle)

        a = Animation(duration=0.0)
        a.on_complete = functools.partial(f)

        image_animate += a

        image_animate.start(self)

    def resize_self(self, *args):

        # Title and description
        padding = 2.17
        self.title.pos = (self.x + (self.title.text_size[0] / padding) - (6 if self.installed else 0), self.y + 31)
        self.subtitle.pos = (self.x + (self.subtitle.text_size[0] / padding) - 1, self.y)

        # Install label
        self.install_image.pos = (self.width + self.x - self.install_label.width - 28, self.y + 38.5)
        self.install_label.pos = (self.width + self.x - self.install_label.width - 30, self.y + 5)

        # Type Banner
        if self.show_type:
            self.type_banner.pos_hint = {"center_x": None, "center_y": None}
            self.type_banner.pos = (self.width + self.x - self.type_banner.width - 18, self.y + 38.5)

        # self.version_label.x = self.width+self.x-(self.padding_x[0]*offset)
        # self.version_label.y = self.y-(self.padding_y[0]*0.85)

    def __init__(self, properties, click_function=None, installed=False, show_type=False, fade_in=0.0, **kwargs):
        super().__init__(**kwargs)

        self.installed = False
        self.show_type = show_type
        self.properties = properties
        self.border = (-5, -5, -5, -5)
        self.color_id = [(0.05, 0.05, 0.1, 1), (0.65, 0.65, 1, 1)]
        self.pos_hint = {"center_x": 0.5, "center_y": 0.6}
        self.size_hint_max = (580, 80)
        self.id = "addon_button"
        self.background_normal = os.path.join(constants.gui_assets, f'{self.id}.png')
        self.background_down = os.path.join(constants.gui_assets, f'{self.id}_click.png')


        # Loading stuffs
        self.original_subtitle = self.properties.subtitle if self.properties.subtitle else "Description unavailable"
        self.original_font = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["regular"]}.ttf')


        # Title of Addon
        self.title = Label()
        self.title.id = "title"
        self.title.halign = "left"
        self.title.color = self.color_id[1]
        self.title.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
        self.title.font_size = sp(25)
        self.title.text_size = (self.size_hint_max[0] * 0.94, self.size_hint_max[1])
        self.title.shorten = True
        self.title.markup = True
        self.title.shorten_from = "right"
        self.title.max_lines = 1
        self.title.__translate__ = False
        self.title.text = f"{self.properties.name}  [color=#434368]-[/color]  {self.properties.author if self.properties.author else 'Unknown'}"
        self.add_widget(self.title)


        # Description of Addon
        self.subtitle = Label()
        self.subtitle.__translate__ = False
        self.subtitle.id = "subtitle"
        self.subtitle.halign = "left"
        self.subtitle.color = self.color_id[1]
        self.subtitle.font_name = self.original_font
        self.subtitle.font_size = sp(21)
        self.subtitle.opacity = 0.56
        self.subtitle.text_size = (self.size_hint_max[0] * 0.91, self.size_hint_max[1])
        self.subtitle.shorten = True
        self.subtitle.shorten_from = "right"
        self.subtitle.max_lines = 1
        self.subtitle.text = self.original_subtitle
        self.add_widget(self.subtitle)


        # Installed layout
        self.install_image = Image()
        self.install_image.size = (110, 30)
        self.install_image.keep_ratio = False
        self.install_image.allow_stretch = True
        self.install_image.source = os.path.join(constants.gui_assets, 'installed.png')
        self.install_image.opacity = 0
        self.add_widget(self.install_image)

        self.install_label = AlignLabel()
        self.install_label.halign = "right"
        self.install_label.valign = "middle"
        self.install_label.font_size = sp(18)
        self.install_label.color = self.color_id[1]
        self.install_label.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
        self.install_label.width = 100
        self.install_label.color = (0.05, 0.08, 0.07, 1)
        self.install_label.text = 'installed'
        self.install_label.opacity = 0
        self.add_widget(self.install_label)


        # Type Banner
        if show_type:
            self.type_banner = show_type
            self.add_widget(self.type_banner)


        # If self.installed is false, and self.properties.version, display version where "installed" logo is
        self.bind(pos=self.resize_self)
        if installed:
            self.toggle_installed(installed)

        # If click_function
        if click_function:
            self.bind(on_press=click_function)

        # Animate opacity
        if fade_in > 0:
            self.opacity = 0
            self.install_label.opacity = 0
            self.install_image.opacity = 0
            self.title.opacity = 0

            Animation(opacity=1, duration=fade_in).start(self)
            Animation(opacity=1, duration=fade_in).start(self.title)
            Animation(opacity=0.56, duration=fade_in).start(self.subtitle)

            if installed and not self.show_type:
                Animation(opacity=1, duration=fade_in).start(self.install_label)
                Animation(opacity=1, duration=fade_in).start(self.install_image)

    def on_enter(self, *args):
        if not self.ignore_hover:
            self.animate_addon(image=os.path.join(constants.gui_assets, f'{self.id}_hover.png'), color=self.color_id[0], hover_action=True)

    def on_leave(self, *args):
        if not self.ignore_hover:
            self.animate_addon(image=os.path.join(constants.gui_assets, f'{self.id}{"_installed" if self.installed and not self.show_type else ""}.png'), color=self.color_id[1], hover_action=False)

    def loading(self, load_state, *args):
        if load_state:
            self.subtitle.text = "Loading add-on info..."
            self.subtitle.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
        else:
            self.subtitle.text = self.original_subtitle
            self.subtitle.font_name = self.original_font

class CreateServerAddonScreen(MenuBackground):

    def switch_page(self, direction):

        if self.max_pages == 1:
            return

        if direction == "right":
            if self.current_page == self.max_pages:
                self.current_page = 1
            else:
                self.current_page += 1

        else:
            if self.current_page == 1:
                self.current_page = self.max_pages
            else:
                self.current_page -= 1

        self.page_switcher.update_index(self.current_page, self.max_pages)
        self.gen_search_results(self.last_results)

    def gen_search_results(self, results, new_search=False, *args):

        # Update page counter
        results = list(sorted(results, key=lambda d: d.name.lower()))
        self.last_results = results
        self.max_pages = (len(results) / self.page_size).__ceil__()
        self.current_page = 1 if self.current_page == 0 or new_search else self.current_page

        self.page_switcher.update_index(self.current_page, self.max_pages)
        page_list = results[(self.page_size * self.current_page) - self.page_size:self.page_size * self.current_page]

        self.scroll_layout.clear_widgets()

        # Generate header
        addon_count = len(results)
        very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["very-bold"])
        header_content = f"{constants.translate('Add-on Queue')}  [color=#494977]-[/color]  " + (f'[color=#6A6ABA]{constants.translate("No items")}[/color]' if addon_count == 0 else f'[font={very_bold_font}]1[/font] {constants.translate("item")}' if addon_count == 1 else f'[font={very_bold_font}]{addon_count:,}[/font] {constants.translate("items")}')

        for child in self.header.children:
            if child.id == "text":
                child.text = header_content
                break


        # If there are no addons, say as much with a label
        if addon_count == 0:
            self.blank_label.text = "Import or Download add-ons below"
            constants.hide_widget(self.blank_label, False)
            self.blank_label.opacity = 0
            Animation(opacity=1, duration=0.2).start(self.blank_label)
            self.max_pages = 0
            self.current_page = 0

        # If there are addons, display them here
        else:
            constants.hide_widget(self.blank_label, True)

            # Clear and add all addons
            for x, addon_object in enumerate(page_list, 1):

                # Function to remove addon
                def remove_addon(index):
                    selected_button = [item for item in self.scroll_layout.walk() if item.__class__.__name__ == "AddonButton"][index-1]
                    addon = selected_button.properties

                    if len(addon.name) < 26:
                        addon_name = addon.name
                    else:
                        addon_name = addon.name[:23] + "..."

                    Clock.schedule_once(
                        functools.partial(
                            self.show_banner,
                            (0.937, 0.831, 0.62, 1),
                            f"Removed '${addon_name}$' from the queue",
                            "remove-circle-sharp.png",
                            2.5,
                            {"center_x": 0.5, "center_y": 0.965}
                        ), 0.25
                    )

                    if addon in constants.new_server_info['addon_objects']:
                        constants.new_server_info['addon_objects'].remove(addon)
                        self.gen_search_results(constants.new_server_info['addon_objects'])

                        # Switch pages if page is empty
                        if (len(self.scroll_layout.children) == 0) and (len(constants.new_server_info['addon_objects']) > 0):
                            self.switch_page("left")

                    return addon, selected_button.installed


                # Activated when addon is clicked
                def view_addon(addon, index, *args):
                    selected_button = [item for item in self.scroll_layout.walk() if item.__class__.__name__ == "AddonButton"][index - 1]

                    # Possibly make custom popup that shows differently for Web and File addons
                    Clock.schedule_once(
                        functools.partial(
                            self.show_popup,
                            "query",
                            addon.name,
                            "Do you want to remove this add-on from the queue?",
                            (None, functools.partial(remove_addon, index))
                        ),
                        0
                    )


                # Add-on button click function
                self.scroll_layout.add_widget(
                    ScrollItem(
                        widget = AddonButton(
                            properties = addon_object,
                            installed = True,
                            fade_in = ((x if x <= 8 else 8) / self.anim_speed),

                            show_type = BannerObject(
                                pos_hint = {"center_x": 0.5, "center_y": 0.5},
                                size = (125 if addon_object.addon_object_type == "web" else 100, 32),
                                color = (0.647, 0.839, 0.969, 1) if addon_object.addon_object_type == "web" else (0.6, 0.6, 1, 1),
                                text = "download" if addon_object.addon_object_type == "web" else "import",
                                icon = "cloud-download-sharp.png" if addon_object.addon_object_type == "web" else "download.png",
                                icon_side = "right"
                            ),

                            click_function = functools.partial(
                                view_addon,
                                addon_object,
                                x
                            )
                        )
                    )
                )

            self.resize_bind()
            self.scroll_layout.parent.parent.scroll_y = 1

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.header = None
        self.scroll_layout = None
        self.blank_label = None
        self.page_switcher = None

        self.last_results = []
        self.page_size = 20
        self.current_page = 0
        self.max_pages = 0
        self.anim_speed = 10

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        super()._on_keyboard_down(keyboard, keycode, text, modifiers)

        # Press arrow keys to switch pages
        if keycode[1] in ['right', 'left'] and self.name == screen_manager.current_screen.name:
            self.switch_page(keycode[1])

    def generate_menu(self, **kwargs):

        # Scroll list
        scroll_widget = ScrollViewWidget(position=(0.5, 0.52))
        scroll_anchor = AnchorLayout()
        self.scroll_layout = GridLayout(cols=1, spacing=15, size_hint_max_x=1250, size_hint_y=None, padding=[0, 30, 0, 30])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 1.85
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1
            self.anim_speed = 13 if Window.width > grid_layout.size_hint_max_x else 10

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, self.scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        self.scroll_layout.bind(minimum_height=self.scroll_layout.setter('height'))
        self.scroll_layout.id = 'scroll_content'


        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.795}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.27}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60))

        # Generate buttons on page load
        addon_count = len(constants.new_server_info['addon_objects'])
        very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["very-bold"])
        header_content = f"{constants.translate('Add-on Queue')}  [color=#494977]-[/color]  " + (f'[color=#6A6ABA]{constants.translate("No items")}[/color]' if addon_count == 0 else f'[font={very_bold_font}]1[/font] {constants.translate("item")}' if addon_count == 1 else f'[font={very_bold_font}]{addon_count}[/font] {constants.translate("items")}')
        self.header = HeaderText(header_content, '', (0, 0.89), __translate__ = (False, True))

        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(self.header)


        # Add blank label to the center, then load self.gen_search_results()
        self.blank_label = Label()
        self.blank_label.text = "Import or Download add-ons below"
        self.blank_label.font_name = os.path.join(constants.gui_assets, 'fonts', constants.fonts['italic'])
        self.blank_label.pos_hint = {"center_x": 0.5, "center_y": 0.55}
        self.blank_label.font_size = sp(24)
        self.blank_label.color = (0.6, 0.6, 1, 0.35)
        float_layout.add_widget(self.blank_label)

        self.page_switcher = PageSwitcher(0, 0, (0.5, 0.887), self.switch_page)


        # Append scroll view items
        scroll_anchor.add_widget(self.scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)
        float_layout.add_widget(self.page_switcher)

        bottom_buttons = RelativeLayout()
        bottom_buttons.size_hint_max_x = 312
        bottom_buttons.pos_hint = {"center_x": 0.5, "center_y": 0.5}
        bottom_buttons.add_widget(MainButton('Import', (0, 0.202), 'download-outline.png', width=300, icon_offset=-115, auto_adjust_icon=True))
        bottom_buttons.add_widget(MainButton('Download', (1, 0.202), 'cloud-download-outline.png', width=300, icon_offset=-115, auto_adjust_icon=True))
        buttons.append(ExitButton('Back', (0.5, 0.11), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)
        float_layout.add_widget(bottom_buttons)

        menu_name = f"Create '{constants.new_server_info['name']}', Add-ons"
        float_layout.add_widget(generate_title(f"Add-on Manager: '{constants.new_server_info['name']}'"))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)

        # Automatically generate results (installed add-ons) on page load
        self.gen_search_results(constants.new_server_info['addon_objects'])

class CreateServerAddonSearchScreen(MenuBackground):

    def switch_page(self, direction):

        if self.max_pages == 1:
            return

        if direction == "right":
            if self.current_page == self.max_pages:
                self.current_page = 1
            else:
                self.current_page += 1

        else:
            if self.current_page == 1:
                self.current_page = self.max_pages
            else:
                self.current_page -= 1

        self.page_switcher.update_index(self.current_page, self.max_pages)
        self.gen_search_results(self.last_results)

    def gen_search_results(self, results, new_search=False, *args):

        # Error on failure
        if not results and isinstance(results, bool):
            self.show_popup(
                "warning",
                "Server Error",
                "There was an issue reaching the add-on repository\n\nPlease try again later",
                None
            )
            self.max_pages = 0
            self.current_page = 0

        # On success, rebuild results
        else:

            # Update page counter
            self.last_results = results
            self.max_pages = (len(results) / self.page_size).__ceil__()
            self.current_page = 1 if self.current_page == 0 or new_search else self.current_page

            self.page_switcher.update_index(self.current_page, self.max_pages)
            page_list = results[(self.page_size * self.current_page) - self.page_size:self.page_size * self.current_page]

            self.scroll_layout.clear_widgets()


            # Generate header
            addon_count = len(results)
            very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["very-bold"])
            search_text = self.search_bar.previous_search if (len(self.search_bar.previous_search) <= 25) else self.search_bar.previous_search[:22] + "..."
            header_content = f"{constants.translate('Search for')} '{search_text}'  [color=#494977]-[/color]  " + (f'[color=#6A6ABA]{constants.translate("No results")}[/color]' if addon_count == 0 else f'[font={very_bold_font}]1[/font] {constants.translate("item")}' if addon_count == 1 else f'[font={very_bold_font}]{addon_count:,}[/font] {constants.translate("items")}')

            for child in self.header.children:
                if child.id == "text":
                    child.text = header_content
                    break


            # If there are no addons, say as much with a label
            if addon_count == 0:
                self.blank_label.text = "there are no items to display"
                constants.hide_widget(self.blank_label, False)
                self.blank_label.opacity = 0
                Animation(opacity=1, duration=0.2).start(self.blank_label)
                self.max_pages = 0
                self.current_page = 0

            # If there are addons, display them here
            else:
                constants.hide_widget(self.blank_label, True)

                # Create list of addon names
                installed_addon_names = [addon.name for addon in constants.new_server_info["addon_objects"]]

                # Clear and add all addons
                for x, addon_object in enumerate(page_list, 1):


                    # Function to download addon info
                    def load_addon(addon, index):
                        try:
                            selected_button = [item for item in self.scroll_layout.walk() if item.__class__.__name__ == "AddonButton"][index-1]

                            # Cache updated addon info into button, or skip if it's already cached
                            if selected_button.properties:
                                if not selected_button.properties.versions or not selected_button.properties.description:
                                    new_addon_info = addons.get_addon_info(addon, constants.new_server_info)
                                    selected_button.properties = new_addon_info

                            Clock.schedule_once(functools.partial(selected_button.loading, False), 1)

                            return selected_button.properties, selected_button.installed

                        # Don't crash if add-on failed to load
                        except:
                            Clock.schedule_once(
                                functools.partial(
                                    screen_manager.current_screen.show_banner,
                                    (1, 0.5, 0.65, 1),
                                    f"Failed to load add-on",
                                    "close-circle-sharp.png",
                                    2.5,
                                    {"center_x": 0.5, "center_y": 0.965}
                                ), 0
                            )


                    # Function to install addon
                    def install_addon(index):
                        selected_button = [item for item in self.scroll_layout.walk() if item.__class__.__name__ == "AddonButton"][index-1]
                        addon = selected_button.properties
                        selected_button.toggle_installed(not selected_button.installed)

                        if len(addon.name) < 26:
                            addon_name = addon.name
                        else:
                            addon_name = addon.name[:23] + "..."

                        # Install
                        if selected_button.installed:
                            constants.new_server_info["addon_objects"].append(addons.get_addon_url(addon, constants.new_server_info))

                            Clock.schedule_once(
                                functools.partial(
                                    self.show_banner,
                                    (0.553, 0.902, 0.675, 1),
                                    f"Added '${addon_name}$' to the queue",
                                    "add-circle-sharp.png",
                                    2.5,
                                    {"center_x": 0.5, "center_y": 0.965}
                                ), 0.25
                            )

                        # Uninstall
                        else:
                            for installed_addon_object in constants.new_server_info["addon_objects"]:
                                if installed_addon_object.name == addon.name:
                                    constants.new_server_info["addon_objects"].remove(installed_addon_object)

                                    Clock.schedule_once(
                                        functools.partial(
                                            self.show_banner,
                                            (0.937, 0.831, 0.62, 1),
                                            f"Removed '${addon_name}$' from the queue",
                                            "remove-circle-sharp.png",
                                            2.5,
                                            {"center_x": 0.5, "center_y": 0.965}
                                        ), 0.25
                                    )

                                    break

                        return addon, selected_button.installed


                    # Activated when addon is clicked
                    def view_addon(addon, index, *args):
                        selected_button = [item for item in self.scroll_layout.walk() if item.__class__.__name__ == "AddonButton"][index - 1]

                        selected_button.loading(True)

                        Clock.schedule_once(
                            functools.partial(
                                self.show_popup,
                                "addon",
                                " ",
                                " ",
                                (None, functools.partial(install_addon, index)),
                                functools.partial(load_addon, addon, index)
                            ),
                            0
                        )


                    # Add-on button click function
                    self.scroll_layout.add_widget(
                        ScrollItem(
                            widget = AddonButton(
                                properties = addon_object,
                                installed = addon_object.name in installed_addon_names,
                                fade_in = ((x if x <= 8 else 8) / self.anim_speed),
                                click_function = functools.partial(
                                    view_addon,
                                    addon_object,
                                    x
                                )
                            )
                        )
                    )

                self.resize_bind()
                self.scroll_layout.parent.parent.scroll_y = 1

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.header = None
        self.scroll_layout = None
        self.blank_label = None
        self.search_bar = None
        self.page_switcher = None

        self.last_results = []
        self.page_size = 20
        self.current_page = 0
        self.max_pages = 0
        self.anim_speed = 10

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        super()._on_keyboard_down(keyboard, keycode, text, modifiers)

        # Press arrow keys to switch pages
        if keycode[1] in ['right', 'left'] and self.name == screen_manager.current_screen.name:
            self.switch_page(keycode[1])
        elif keycode[1] == "tab" and self.name == screen_manager.current_screen.name:
            for widget in self.search_bar.children:
                try:
                    if widget.id == "search_input":
                        widget.grab_focus()
                        break
                except AttributeError:
                    pass


    def generate_menu(self, **kwargs):

        # Scroll list
        scroll_widget = ScrollViewWidget(position=(0.5, 0.437))
        scroll_anchor = AnchorLayout()
        self.scroll_layout = GridLayout(cols=1, spacing=15, size_hint_max_x=1250, size_hint_y=None, padding=[0, 30, 0, 30])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 1.79
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1
            self.anim_speed = 13 if Window.width > grid_layout.size_hint_max_x else 10

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, self.scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        self.scroll_layout.bind(minimum_height=self.scroll_layout.setter('height'))
        self.scroll_layout.id = 'scroll_content'

        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.715}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.17}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60))

        # Generate buttons on page load
        addon_count = 0
        very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["very-bold"])
        header_content = constants.translate("Add-on Search")
        self.header = HeaderText(header_content, '', (0, 0.89), __translate__ = (False, True))

        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(self.header)

        # Add blank label to the center
        self.blank_label = Label()
        self.blank_label.text = "search for add-ons above"
        self.blank_label.font_name = os.path.join(constants.gui_assets, 'fonts', constants.fonts['italic'])
        self.blank_label.pos_hint = {"center_x": 0.5, "center_y": 0.48}
        self.blank_label.font_size = sp(24)
        self.blank_label.color = (0.6, 0.6, 1, 0.35)
        float_layout.add_widget(self.blank_label)


        search_function = addons.search_addons
        self.search_bar = search_input(return_function=search_function, server_info=constants.new_server_info, pos_hint={"center_x": 0.5, "center_y": 0.795})
        self.page_switcher = PageSwitcher(0, 0, (0.5, 0.805), self.switch_page)


        # Append scroll view items
        scroll_anchor.add_widget(self.scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)
        float_layout.add_widget(self.search_bar)
        float_layout.add_widget(self.page_switcher)

        buttons.append(ExitButton('Back', (0.5, 0.12), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        menu_name = f"Create '{constants.new_server_info['name']}', Add-ons, Download"
        float_layout.add_widget(generate_title(f"Add-on Manager: '{constants.new_server_info['name']}'"))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)

        # Autofocus search bar
        for widget in self.search_bar.children:
            try:
                if widget.id == "search_input":
                    widget.grab_focus()
                    break
            except AttributeError:
                pass



# Create Server Step 7 (end):  Server Review ---------------------------------------------------------------------------

# Create demo of how the server will appear in the Server Manager:
class ServerDemoInput(BaseInput):

    def resize_self(self, *args):
        offset = 9.45 if self.type_image.type_label.text in ["vanilla", "paper", "purpur"]\
            else 9.6 if self.type_image.type_label.text == "forge"\
            else 9.35 if self.type_image.type_label.text == "craftbukkit"\
            else 9.55

        self.type_image.image.x = self.width+self.x-self.type_image.image.width-self.padding_x[0]+10
        self.type_image.image.y = self.y+(self.padding_y[0]/2.7)

        self.title_t.pos = (self.x + 185, self.y - 7)

        # Telepath icon
        if self.type_image.tp_shadow:
            self.type_image.tp_shadow.pos = (self.type_image.image.x - 2, self.type_image.image.y)
            self.type_image.tp_icon.pos = (self.type_image.image.x - 2, self.type_image.image.y)

        self.type_image.type_label.x = (self.width+self.x-(self.padding_x[0]*offset)) - 3
        self.type_image.type_label.y = self.y+(self.padding_y[0]/6.9)

        self.type_image.version_label.x = (self.width+self.x-(self.padding_x[0]*offset)) - 3
        self.type_image.version_label.y = self.y-(self.padding_y[0]*0.85)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        self.halign = "left"
        self.properties = {"type": "", "version": "", "name": ""}
        self.padding_x = 30
        self.padding_y = 24.5
        self.font_size = sp(25)
        self.size_hint_max = (580, 80)
        self.hint_text_color = (0.65, 0.65, 1, 1)
        self.background_normal = os.path.join(constants.gui_assets, 'server_preview.png')
        self.title_text = ""
        self.hint_text = ""
        self.markup = True


        # Type icon and info
        with self.canvas.after:
            self.type_image = RelativeLayout()
            self.type_image.image = Image(source=None)
            self.type_image.image.allow_stretch = True
            self.type_image.image.size = (62, 62)
            self.type_image.image.color = (0.65, 0.65, 1, 1)

            def TemplateLabel():
                template_label = AlignLabel()
                template_label.halign = "right"
                template_label.valign = "middle"
                template_label.text_size = template_label.size
                template_label.font_size = sp(18)
                template_label.color = self.foreground_color
                template_label.font_name = self.font_name
                template_label.width = 200
                return template_label

            self.type_image.version_label = TemplateLabel()
            self.type_image.version_label.color = (0.6, 0.6, 1, 0.6)
            self.type_image.type_label = TemplateLabel()
            self.type_image.type_label.font_size = sp(22)
            self.type_image.tp_shadow = None

            self.bind(pos=self.resize_self)

            self.title_t = AlignLabel(halign='left', valign='center')
            self.title_t.font_size = sp(25)
            self.title_t.size_hint_max = (400, 80)
            self.title_t.text_size = self.title_t.size_hint_max
            self.title_t.color = (0.65, 0.65, 1, 1)
            self.title_t.markup = True
            self.title_t.font_name = self.font_name
            self.add_widget(self.title_t)

    # Make the text box non-interactive
    def on_enter(self, value):
        return

    def on_touch_down(self, touch):
        self.focus = False

    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        return

    def insert_text(self, substring, from_undo=False):
        return
def server_demo_input(pos_hint, properties):
    demo_input = ServerDemoInput()
    demo_input.properties = properties
    demo_input.pos_hint = pos_hint
    demo_input.__translate__ = False
    demo_input.title_t.text = properties['name']
    demo_input.type_image.version_label.__translate__ = False
    demo_input.type_image.version_label.text = properties['version']
    demo_input.type_image.type_label.__translate__ = False
    demo_input.type_image.type_label.text = properties['type'].lower().replace("craft", "")
    demo_input.type_image.image.source = os.path.join(constants.gui_assets, 'icons', 'big', f'{properties["type"].lower()}_small.png')

    print(properties)
    if properties['_telepath_data']:
        if properties['_telepath_data']['nickname']:
            head = properties['_telepath_data']['nickname']
        else:
            properties['_telepath_data']['host']

        demo_input.title_t.text = f"[color=#7373A2]{head}/[/color]{properties['name']}"

        with demo_input.canvas.after:
            demo_input.type_image.tp_shadow = Image(source=icon_path('shadow.png'))
            demo_input.type_image.tp_shadow.allow_stretch = True
            demo_input.type_image.tp_shadow.size_hint_max = (33, 33)
            demo_input.type_image.tp_shadow.color = constants.background_color
            demo_input.type_image.add_widget(demo_input.type_image.tp_shadow)

            demo_input.type_image.tp_icon = Image(source=icon_path('telepath.png'))
            demo_input.type_image.tp_icon.allow_stretch = True
            demo_input.type_image.tp_icon.size_hint_max = (33, 33)
            demo_input.type_image.tp_icon.color = demo_input.type_image.image.color
            demo_input.type_image.add_widget(demo_input.type_image.tp_icon)
    
    return demo_input

class CreateServerReviewScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'

    def generate_menu(self, **kwargs):

        # Fulfill prerequisites if skipped somehow
        constants.new_server_name()

        if not constants.new_server_info['version']:
            server_type = constants.new_server_info['type']
            constants.new_server_info['version'] = constants.latestMC[server_type]
            if server_type in ['forge', 'paper']:
                constants.new_server_info['build'] = constants.latestMC['builds'][server_type]

        if not constants.new_server_info['acl_object']:
            constants.new_server_info['acl_object'] = acl.AclManager(constants.new_server_info['name'])


        # Scroll list
        scroll_widget = ScrollViewWidget()
        scroll_anchor = AnchorLayout()
        scroll_layout = GridLayout(cols=1, spacing=10, size_hint_max_x=(1050 if constants.app_config.locale == 'en' else 1130), size_hint_y=None, padding=[0, -10, 0, 60])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 2.05
            call_widget.pos_hint = {"center_y": 0.51}
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        scroll_layout.bind(minimum_height=scroll_layout.setter('height'))
        scroll_layout.id = 'scroll_content'

        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.735}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.272}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60))

        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(HeaderText(f"Please verify your configuration", '', (0, 0.89), no_line=True))

        pgh_font = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["mono-medium"]}.otf')


        # Create and add paragraphs to GridLayout
        def create_paragraph(name, text, cid):

            # Dirty fix to anchor paragraphs to the top
            def repos(p, s, *args):
                if scroll_layout.cols == 2:
                    if s.height != scroll_layout._rows[cid]:
                        p.y = scroll_layout._rows[cid] - s.height

                    if cid == 0:
                        for child in scroll_layout.children:
                            if child != s and child.x == s.x:
                                p2 = child.children[0]
                                p2.y = p.y
                                break
                else:
                    p.y = 0


            # Format spacing appropriately for content
            if constants.app_config.locale == 'en':
                paragraph_width = 485
                for line in text.splitlines():
                    if '||' in line:
                        new_line = line.replace(' ||', ' ', 1)
                        text = text.replace(line, new_line)

            else:
                # Find the longest key in a paragraph to dynamically generate spacing
                paragraph_width = 530
                longest = 0
                for line in text.splitlines():
                    if '||' in line:
                        key = line.split('||', 1)[0].strip()
                        if len(key) > longest:
                            longest = len(key)

                longest += 3

                # Replace text with proper spacing
                for line in text.splitlines():
                    if '||' in line:
                        key, value = line.split('||', 1)
                        text = text.replace(line, f'{key.strip()}{(longest - len(key.strip())) * " "}{value}')

            sub_layout = ScrollItem()
            content_size = sp(22)
            content_height = len(text.splitlines()) * (content_size + sp(9))
            paragraph = paragraph_object(size=(paragraph_width, content_height), name=name, content=text, font_size=content_size, font=pgh_font)
            sub_layout.height = paragraph.height + 60

            sub_layout.bind(pos=functools.partial(repos, paragraph, sub_layout, cid))
            sub_layout.bind(size=functools.partial(repos, paragraph, sub_layout, cid))

            sub_layout.add_widget(paragraph)
            scroll_layout.add_widget(sub_layout)



        # ----------------------------------------------- General ------------------------------------------------------
        content = ""
        content += f"[color=6666AA]{constants.translate('Name')}:      ||[/color]{constants.new_server_info['name']}\n"
        content += f"[color=6666AA]{constants.translate('Type')}:      ||[/color]{constants.new_server_info['type'].title()}\n"
        content += f"[color=6666AA]{constants.translate('Version')}:   ||[/color]{constants.new_server_info['version']}"
        if constants.new_server_info['build']:
            content += f" ({constants.new_server_info['build']})"
        content += "\n\n"
        if constants.new_server_info['server_settings']['world'] == "world":
            content += f"[color=6666AA]{constants.translate('World')}:     ||[/color]{constants.translate('Create a new world')}\n"
            if constants.new_server_info['server_settings']['level_type']:
                content += f"[color=6666AA]{constants.translate('Type')}:      ||[/color]{constants.translate(constants.new_server_info['server_settings']['level_type'].title())}\n"
            if constants.new_server_info['server_settings']['seed']:
                content += f"[color=6666AA]{constants.translate('Seed')}:      ||[/color]{constants.new_server_info['server_settings']['seed']}\n"
        else:
            box_text = os.path.join(*Path(os.path.abspath(constants.new_server_info['server_settings']['world'])).parts[-2:])
            box_text = box_text[:27] + "..." if len(box_text) > 27 else box_text
            content += f"[color=6666AA]{constants.translate('World')}:     [/color]{box_text}\n"

        def check_enabled(var):
            if var:
                return '[/color]' + constants.translate('Enabled')
            else:
                return constants.translate('Disabled') + '[/color]'
        create_paragraph('general', content, 0)
        # --------------------------------------------------------------------------------------------------------------



        # ----------------------------------------------- Options ------------------------------------------------------
        content = ""
        content += f"[color=6666AA]{constants.translate('Gamemode')}:             ||[/color]{constants.translate(constants.new_server_info['server_settings']['gamemode'].title())}\n"
        content += f"[color=6666AA]{constants.translate('Difficulty')}:           ||[/color]{constants.translate(constants.new_server_info['server_settings']['difficulty'].title())}\n"
        content += f"[color=6666AA]PVP:                  ||{check_enabled(constants.new_server_info['server_settings']['pvp'])}\n"
        content += f"[color=6666AA]{constants.translate('Spawn protection')}:     ||{check_enabled(constants.new_server_info['server_settings']['spawn_protection'])}"

        content += "\n\n"

        if constants.version_check(constants.new_server_info['version'], ">=", "1.4.2"):
            content += f"[color=6666AA]{constants.translate('Keep inventory')}:       ||{check_enabled(constants.new_server_info['server_settings']['keep_inventory'])}\n"

        content += f"[color=6666AA]{constants.translate('Spawn creatures')}:      ||{check_enabled(constants.new_server_info['server_settings']['spawn_creatures'])}\n"

        if constants.version_check(constants.new_server_info['version'], ">=", "1.4.2"):
            if constants.version_check(constants.new_server_info['version'], ">=", "1.11"):
                content += f"[color=6666AA]{constants.translate('Daylight/weather')}:     ||{check_enabled(constants.new_server_info['server_settings']['daylight_weather_cycle'])}\n"
            else:
                content += f"[color=6666AA]{constants.translate('Daylight cycle')}:       ||{check_enabled(constants.new_server_info['server_settings']['daylight_weather_cycle'] )}\n"

        content += f"[color=6666AA]{constants.translate('Command blocks')}:       ||{check_enabled(constants.new_server_info['server_settings']['command_blocks'])}\n"

        if constants.version_check(constants.new_server_info['version'], ">=", "1.19") and constants.new_server_info['type'].lower() != "vanilla":
            content += f"[color=6666AA]{constants.translate('Chat reporting')}:       ||{check_enabled(not constants.new_server_info['server_settings']['disable_chat_reporting'])}\n"

        if constants.version_check(constants.new_server_info['version'], ">=", "1.4.2"):
            content += f"[color=6666AA]{constants.translate('Random tick speed')}:    ||[/color]{constants.new_server_info['server_settings']['random_tick_speed']} {constants.translate('ticks')}"

        create_paragraph('options', content, 0)
        # --------------------------------------------------------------------------------------------------------------



        # ----------------------------------------------- Network ------------------------------------------------------
        formatted_ip = ("localhost" if not constants.new_server_info['ip'] else constants.new_server_info['ip']) + f":{constants.new_server_info['port']}"
        max_plr = constants.new_server_info['server_settings']['max_players']
        formatted_players = (max_plr + constants.translate(' players' if int(max_plr) != 1 else ' player'))
        content = ""
        content += f"[color=6666AA]{constants.translate('Server IP')}:      ||[/color]{formatted_ip}\n"
        content += f"[color=6666AA]{constants.translate('Max players')}:    ||[/color]{formatted_players}\n"
        if constants.new_server_info['server_settings']['geyser_support']:
            content += f"[color=6666AA]Geyser:         ||[/color]{constants.translate('Enabled')}"

        content += "\n\n"

        if constants.new_server_info['server_settings']['motd'].lower() == 'a minecraft server':
            content += f"[color=6666AA]MOTD:\n[/color]{constants.translate('A Minecraft Server')}"
        else:
            content += f"[color=6666AA]MOTD:\n[/color]{constants.new_server_info['server_settings']['motd']}"

        content += "\n\n\n"

        rule_count = constants.new_server_info['acl_object'].count_rules()
        if rule_count['total'] > 0:
            content += f"[color=6666AA]          {constants.translate('Access Control Rules')}[/color]"

            if rule_count['ops'] > 0:
                content += "\n\n"
                content += f"[color=6666AA]{constants.translate('Operators')} ({rule_count['ops']:,}):[/color]\n"
                content += '    ' + '\n    '.join([rule.rule for rule in constants.new_server_info['acl_object'].rules['ops']])

            if rule_count['bans'] > 0:
                content += "\n\n"
                content += f"[color=6666AA]{constants.translate('Bans')} ({rule_count['bans']:,}):[/color]\n"
                bans = acl.deepcopy(constants.new_server_info['acl_object'].rules['bans'])
                bans.extend(acl.deepcopy(constants.new_server_info['acl_object'].rules['subnets']))
                content += '    ' + '\n    '.join([rule.rule if '!w' not in rule.rule else rule.rule.replace('!w','').strip()+f' ({constants.translate("whitelist")})' for rule in bans])

            if rule_count['wl'] > 0:
                content += "\n\n"
                content += f"[color=6666AA]{constants.translate('Whitelist')} ({rule_count['wl']:,}):[/color]\n"
                content += '    ' + '\n    '.join([rule.rule for rule in constants.new_server_info['acl_object'].rules['wl']])

        create_paragraph('network', content, 1)
        # --------------------------------------------------------------------------------------------------------------



        # ------------------------------------------------ Addons ------------------------------------------------------
        if len(constants.new_server_info['addon_objects']) > 0:
            content = ""
            addons_sorted = {'import': [], 'download': []}
            [addons_sorted['import' if addon.addon_object_type == 'file' else 'download'].append(addon.name) for addon in constants.new_server_info['addon_objects']]

            if len(addons_sorted['download']) > 0:
                content += f"[color=6666AA]{constants.translate('Add-ons to download')} ({len(addons_sorted['download']):,}):[/color]\n"
                content += '    ' + '\n    '.join([(item[:32]+'...' if len(item) > 35 else item) for item in addons_sorted['download']])

                if len(addons_sorted['import']) > 0:
                    content += "\n\n"

            if len(addons_sorted['import']) > 0:
                content += f"[color=6666AA]{constants.translate('Add-ons to import')} ({len(addons_sorted['import']):,}):[/color]\n"
                content += '    ' + '\n    '.join([(item[:32]+'...' if len(item) > 35 else item) for item in addons_sorted['import']])

            create_paragraph('add-ons', content, 1)
        # --------------------------------------------------------------------------------------------------------------



        # Append scroll view items
        scroll_anchor.add_widget(scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)


        # Server Preview Box
        float_layout.add_widget(server_demo_input(pos_hint={"center_x": 0.5, "center_y": 0.81}, properties=constants.new_server_info))


        buttons.append(MainButton('Create Server', (0.5, 0.22), 'checkmark-circle-outline.png'))
        buttons.append(ExitButton('Back', (0.5, 0.12), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        menu_name = f"Create '{constants.new_server_info['name']}'"
        float_layout.add_widget(page_counter(7, 7, (0, 0.815)))
        float_layout.add_widget(generate_title(menu_name))
        float_layout.add_widget(generate_footer(f"{menu_name}, Verify"))

        self.add_widget(float_layout)


# Create Server Progress Screen ----------------------------------------------------------------------------------------
class CreateServerProgressScreen(ProgressScreen):

    # Only replace this function when making a child screen
    # Set fail message in child functions to trigger an error
    def contents(self):
        open_after = functools.partial(self.open_server, constants.new_server_info['name'], True, f"'${constants.new_server_info['name']}$' was created successfully")

        def before_func(*args):

            if not constants.app_online:
                self.execute_error("An internet connection is required to continue\n\nVerify connectivity and try again")

            elif not constants.check_free_space(telepath_data=constants.new_server_info['_telepath_data']):
                self.execute_error("Your primary disk is almost full\n\nFree up space and try again")

            else:
                constants.pre_server_create()

        def after_func(*args):
            constants.post_server_create()
            open_after()

        # Original is percentage before this function, adjusted is a percent of hooked value
        def adjust_percentage(*args):
            original = self.last_progress
            adjusted = args[0]
            total = args[1] * 0.01
            final = original + round(adjusted * total)
            if final < 0:
                final = original
            self.progress_bar.update_progress(final)


        self.page_contents = {

            # Page name
            'title': f"Creating '${constants.new_server_info['name']}$'",

            # Header text
            'header': "Sit back and relax, it's automation time...",

            # Tuple of tuples for steps (label, function, percent)
            # Percent of all functions must total 100
            # Functions must return True, or default error will be executed
            'default_error': 'There was an issue, please try again later',

            'function_list': (),

            # Function to run before steps (like checking for an internet connection)
            'before_function': before_func,

            # Function to run after everything is complete (like cleaning up the screen tree) will only run if no error
            'after_function': after_func,

            # Screen to go to after complete
            'next_screen': None
        }

        # Create function list
        java_text = 'Verifying Java Installation' if os.path.exists(constants.javaDir) else 'Installing Java'
        function_list = [
            (java_text, functools.partial(constants.java_check, functools.partial(adjust_percentage, 30)), 0),
            ("Downloading 'server.jar'", functools.partial(constants.download_jar, functools.partial(adjust_percentage, 30)), 0)
        ]

        download_addons = False
        needs_installed = False

        if constants.new_server_info['type'] != 'vanilla':
            download_addons = constants.new_server_info['addon_objects'] or constants.new_server_info['server_settings']['disable_chat_reporting'] or constants.new_server_info['server_settings']['geyser_support'] or (constants.new_server_info['type'] in ['fabric', 'quilt'])
            needs_installed = constants.new_server_info['type'] in ['forge', 'neoforge', 'fabric', 'quilt']

        if needs_installed:
            function_list.append((f'Installing ${constants.new_server_info["type"].title().replace("forge","Forge")}$', functools.partial(constants.install_server), 10 if download_addons else 20))

        if download_addons:
            function_list.append(('Add-oning add-ons', functools.partial(constants.iter_addons, functools.partial(adjust_percentage, 10 if needs_installed else 20)), 0))

        function_list.append(('Applying server configuration', functools.partial(constants.generate_server_files), 10 if (download_addons or needs_installed) else 20))


        function_list.append(('Creating initial back-up', functools.partial(constants.create_backup), 10 if (download_addons or needs_installed) else 20))


        self.page_contents['function_list'] = tuple(function_list)

# </editor-fold> ///////////////////////////////////////////////////////////////////////////////////////////////////////




# =============================================== Server Manager =======================================================
# <editor-fold desc="Server Manager">

# Import Server --------------------------------------------------------------------------------------------------------

class ServerImportScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'

        self.layout = None
        self.button_layout = None
        self.page_counter = None
        self.input_type = None
        self.input = None
        self.next_button = None
        self.name_input = None


    def load_input(self, input_type, *args):
        self.input_type = input_type
        self.button_layout.clear_widgets()
        self.page_counter.clear_widgets()
        self.layout.remove_widget(self.page_counter)

        # Change the input based on input_type
        self.page_counter = page_counter(2, 2, (0, 0.818))
        self.button_layout.opacity = 0
        self.add_widget(self.page_counter)


        # Add telepath button if servers are connected
        offset = 0
        telepath_data = constants.server_manager.online_telepath_servers
        if telepath_data:
            offset = 0.05
            self.add_widget(TelepathDropButton('import', (0.5, 0.45)))


        if input_type == "external":
            self.name_input = ServerImportPathInput(pos_hint={"center_x": 0.5, "center_y": 0.5 + offset})
            self.button_layout.add_widget(self.name_input)
            self.button_layout.add_widget(input_button('Browse...', (0.5, 0.5 + offset), ('dir', constants.userDownloads if os.path.isdir(constants.userDownloads) else constants.home), input_name='ServerImportPathInput', title='Select a Server Folder'))

        elif input_type == "backup":
            self.name_input = ServerImportBackupInput(pos_hint={"center_x": 0.5, "center_y": 0.5 + offset})
            self.button_layout.add_widget(self.name_input)
            start_path = constants.backupFolder if os.path.isdir(constants.backupFolder) else constants.userDownloads if os.path.isdir(constants.userDownloads) else constants.home
            self.button_layout.add_widget(input_button('Browse...', (0.5, 0.5 + offset), ('file', start_path), input_name='ServerImportBackupInput', title='Select an auto-mcs back-up file', ext_list=['*.amb', '*.tgz']))


        # Auto-launch popup
        try:
            for item in self.button_layout.children[0].children:
                if item.id == "input_button" and not telepath_data:
                    Clock.schedule_once(item.force_click, 0)
                    Clock.schedule_once(item.on_leave, 0.01)
                    break
        except AttributeError:
            pass


        # def set_import_path(*args):
        #     for item in self.button_layout.children:
        #         if "ServerImport" in item.__class__.__name__:
        #             constants.import_data['path'] = item.selected_server


        self.button_layout.add_widget(InputLabel(pos_hint={"center_x": 0.5, "center_y": 0.58 + offset}))
        self.next_button = next_button('Next', (0.5, 0.24), True, next_screen='ServerImportProgressScreen')
        # self.next_button.children[2].bind(on_press=set_import_path)
        self.button_layout.add_widget(self.next_button)
        Animation(opacity=1, duration=0.5).start(self.button_layout)


    def generate_menu(self, **kwargs):

        # Return if no free space or telepath is busy
        if disk_popup():
            return
        if telepath_popup():
            return

        # Reset import path
        constants.import_data = {'name': None, 'path': None}
        os.chdir(constants.get_cwd())
        constants.safe_delete(constants.tempDir)

        # Generate buttons on page load
        buttons = []
        self.layout = FloatLayout()
        self.layout.id = 'content'

        # Prevent server creation if offline
        if not constants.app_online:
            self.layout.add_widget(HeaderText("Importing a server requires an internet connection", '', (0, 0.6)))
            buttons.append(ExitButton('Back', (0.5, 0.35)))

        # Regular menus
        else:
            def go_to_modpack(*a):
                screen_manager.current = 'ServerImportModpackScreen'

            self.layout.add_widget(HeaderText("What do you wish to import?", '', (0, 0.81)))
            buttons.append(MainButton('Import external server', (0.5, 0.55), 'folder-outline.png', click_func=functools.partial(self.load_input, 'external')))
            buttons.append(MainButton('Import Auto-MCS back-up', (0.5, 0.4), 'backup-icon.png', click_func=functools.partial(self.load_input, 'backup')))
            self.layout.add_widget(ExitButton('Back', (0.5, 0.14), cycle=True))
            self.page_counter = page_counter(1, 2, (0, 0.818))
            self.add_widget(self.page_counter)

        self.button_layout = FloatLayout()
        for button in buttons:
            self.button_layout.add_widget(button)

        self.layout.add_widget(self.button_layout)
        self.layout.add_widget(generate_title('Import Server'))
        self.layout.add_widget(generate_footer('Import server'))

        self.add_widget(self.layout)

class ServerImportProgressScreen(ProgressScreen):

    # Only replace this function when making a child screen
    # Set fail message in child functions to trigger an error
    def contents(self):
        import_name = constants.import_data['name']
        open_after = functools.partial(self.open_server, import_name, True, f"'${import_name}$' was imported successfully")

        def before_func(*args):

            if not constants.app_online:
                self.execute_error("An internet connection is required to continue\n\nVerify connectivity and try again")

            elif not constants.check_free_space(telepath_data=constants.new_server_info['_telepath_data']):
                self.execute_error("Your primary disk is almost full\n\nFree up space and try again")

            else:
                constants.pre_server_create()

        def after_func(*args):
            constants.post_server_create()
            open_after()


        # Original is percentage before this function, adjusted is a percent of hooked value
        def adjust_percentage(*args):
            original = self.last_progress
            adjusted = args[0]
            total = args[1] * 0.01
            final = original + round(adjusted * total)
            if final < 0:
                final = original
            self.progress_bar.update_progress(final)

        self.page_contents = {

            # Page name
            'title': f"Importing '{import_name}'",

            # Header text
            'header': "Sit back and relax, it's automation time...",

            # Tuple of tuples for steps (label, function, percent)
            # Percent of all functions must total 100
            # Functions must return True, or default error will be executed
            'default_error': 'There was an issue, please try again later',

            'function_list': (),

            # Function to run before steps (like checking for an internet connection)
            'before_function': before_func,

            # Function to run after everything is complete (like cleaning up the screen tree) will only run if no error
            'after_function': after_func,

            # Screen to go to after complete
            'next_screen': None
        }

        is_backup_file = ((constants.import_data['path'].endswith(".tgz") or constants.import_data['path'].endswith(".amb")) and os.path.isfile(constants.import_data['path']))

        # Create function list
        java_text = 'Verifying Java Installation' if os.path.exists(constants.javaDir) else 'Installing Java'
        function_list = [
            (java_text, functools.partial(constants.java_check, functools.partial(adjust_percentage, 30)), 0),
            ('Importing server', functools.partial(constants.scan_import, is_backup_file, functools.partial(adjust_percentage, 30)), 0),
            ('Validating configuration', functools.partial(constants.finalize_import, functools.partial(adjust_percentage, 20)), 0),
            ('Creating initial back-up', functools.partial(constants.create_backup, True), 20)
        ]

        self.page_contents['function_list'] = tuple(function_list)

class ServerImportModpackScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'

        self.layout = None
        self.button_layout = None
        self.page_counter = None
        self.input_type = None
        self.input = None
        self.next_button = None


    def generate_menu(self, **kwargs):

        # Reset import path
        constants.import_data = {'name': None, 'path': None}
        os.chdir(constants.get_cwd())
        constants.safe_delete(constants.tempDir)

        # Generate buttons on page load
        buttons = []
        self.layout = FloatLayout()
        self.layout.id = 'content'

        # Add telepath button if servers are connected
        offset = 0
        if constants.server_manager.online_telepath_servers:
            offset = 0.05
            self.add_widget(TelepathDropButton('install', (0.5, 0.37)))


        # Regular menus
        self.layout.add_widget(HeaderText("Which modpack do you wish to install?", '', (0, 0.81)))
        def download_modpack(*a):
            screen_manager.current = 'ServerImportModpackSearchScreen'
        buttons.append(MainButton('Download a Modpack', (0.5, 0.576 + offset), 'download-outline.png', width=528, click_func=download_modpack))

        start_path = constants.userDownloads if os.path.isdir(constants.userDownloads) else constants.home
        buttons.append(InputLabel(pos_hint={"center_x": 0.5, "center_y": 0.505 + offset}))
        buttons.append(ServerImportModpackInput(pos_hint={"center_x": 0.5, "center_y": 0.44 + offset}))
        buttons.append(input_button('Browse...', (0.5, 0.44 + offset), ('file', start_path), input_name='ServerImportModpackInput', title='Select a modpack', ext_list=['*.zip', '*.mrpack']))

        self.layout.add_widget(ExitButton('Back', (0.5, 0.14), cycle=True))
        def remove_page(*a):
            if 'ServerImportScreen' in constants.screen_tree:
                constants.screen_tree.remove('ServerImportScreen')
        Clock.schedule_once(remove_page, 0.1)
        self.page_counter = page_counter(2, 2, (0, 0.818))
        self.add_widget(self.page_counter)

        self.button_layout = FloatLayout()
        for button in buttons:
            self.button_layout.add_widget(button)

        self.layout.add_widget(self.button_layout)
        self.next_button = next_button('Next', (0.5, 0.24), True, next_screen='ServerImportModpackProgressScreen')
        self.button_layout.add_widget(self.next_button)
        self.layout.add_widget(generate_title('Install a Modpack'))
        self.layout.add_widget(generate_footer('Install a modpack'))

        self.add_widget(self.layout)

class ServerImportModpackProgressScreen(ProgressScreen):

    # Only replace this function when making a child screen
    # Set fail message in child functions to trigger an error
    def contents(self):
        import_name = constants.import_data['name']

        def before_func(*args):
            if not constants.app_online:
                self.execute_error("An internet connection is required to continue\n\nVerify connectivity and try again")

            elif not constants.check_free_space(telepath_data=constants.new_server_info['_telepath_data']):
                self.execute_error("Your primary disk is almost full\n\nFree up space and try again")

            else:
                constants.pre_server_create()

        def after_func(*args):
            import_data = constants.post_server_create(modpack=True)

            if self.telepath and import_data['readme']:
                import_data['readme'] = constants.telepath_download(self.telepath, import_data['readme'])['path']

            self.open_server(
                import_data['name'],
                True,
                f"'${import_data['name']}$' was imported successfully",
                show_readme=import_data['readme']
            )

        # Original is percentage before this function, adjusted is a percent of hooked value
        def adjust_percentage(*args):
            original = self.last_progress
            adjusted = args[0]
            total = args[1] * 0.01
            final = original + round(adjusted * total)
            if final < 0:
                final = original
            self.progress_bar.update_progress(final)


        self.page_contents = {

            # Page name
            'title': f"Installing Modpack",

            # Header text
            'header': "Sit back and relax, it's automation time...",

            # Tuple of tuples for steps (label, function, percent)
            # Percent of all functions must total 100
            # Functions must return True, or default error will be executed
            'default_error': "There was an issue importing this modpack.\n\nThe required resources were unobtainable and will require manual installation.",

            'function_list': (),

            # Function to run before steps (like checking for an internet connection)
            'before_function': before_func,

            # Function to run after everything is complete (like cleaning up the screen tree) will only run if no error
            'after_function': after_func,

            # Screen to go to after complete
            'next_screen': None
        }

        # Create function list
        java_text = 'Verifying Java Installation' if os.path.exists(constants.javaDir) else 'Installing Java'
        function_list = [
            (java_text, functools.partial(constants.java_check, functools.partial(adjust_percentage, 30)), 0),
            ('Validating modpack', functools.partial(constants.scan_modpack, False, functools.partial(adjust_percentage, 20)), 0),
            ("Downloading 'server.jar'", functools.partial(constants.download_jar, functools.partial(adjust_percentage, 15), True), 0),
            ('Installing modpack',functools.partial(constants.install_server, None, True), 15),
            ('Validating configuration', functools.partial(constants.finalize_modpack, False, functools.partial(adjust_percentage, 10)), 0),
            ('Creating initial back-up', functools.partial(constants.create_backup, True), 10)
        ]

        self.page_contents['function_list'] = tuple(function_list)

class ServerImportModpackSearchScreen(MenuBackground):

    def switch_page(self, direction):

        if self.max_pages == 1:
            return

        if direction == "right":
            if self.current_page == self.max_pages:
                self.current_page = 1
            else:
                self.current_page += 1

        else:
            if self.current_page == 1:
                self.current_page = self.max_pages
            else:
                self.current_page -= 1

        self.page_switcher.update_index(self.current_page, self.max_pages)
        self.gen_search_results(self.last_results)

    def gen_search_results(self, results, new_search=False, *args):

        # Error on failure
        if not results and isinstance(results, bool):
            self.show_popup(
                "warning",
                "Server Error",
                "There was an issue reaching the add-on repository\n\nPlease try again later",
                None
            )
            self.max_pages = 0
            self.current_page = 0

        # On success, rebuild results
        else:

            # Update page counter
            self.last_results = results
            self.max_pages = (len(results) / self.page_size).__ceil__()
            self.current_page = 1 if self.current_page == 0 or new_search else self.current_page

            self.page_switcher.update_index(self.current_page, self.max_pages)
            page_list = results[(self.page_size * self.current_page) - self.page_size:self.page_size * self.current_page]

            self.scroll_layout.clear_widgets()


            # Generate header
            addon_count = len(results)
            very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["very-bold"])
            search_text = self.search_bar.previous_search if (len(self.search_bar.previous_search) <= 25) else self.search_bar.previous_search[:22] + "..."
            header_content = f"{constants.translate('Search for')} '{search_text}'  [color=#494977]-[/color]  " + (f'[color=#6A6ABA]{constants.translate("No results")}[/color]' if addon_count == 0 else f'[font={very_bold_font}]1[/font] {constants.translate("item")}' if addon_count == 1 else f'[font={very_bold_font}]{addon_count:,}[/font] {constants.translate("items")}')

            for child in self.header.children:
                if child.id == "text":
                    child.text = header_content
                    break


            # If there are no addons, say as much with a label
            if addon_count == 0:
                self.blank_label.text = "there are no items to display"
                constants.hide_widget(self.blank_label, False)
                self.blank_label.opacity = 0
                Animation(opacity=1, duration=0.2).start(self.blank_label)
                self.max_pages = 0
                self.current_page = 0

            # If there are addons, display them here
            else:
                constants.hide_widget(self.blank_label, True)

                # Clear and add all addons
                for x, addon_object in enumerate(page_list, 1):


                    # Function to download addon info
                    def load_addon(addon, index):
                        try:
                            selected_button = [item for item in self.scroll_layout.walk() if item.__class__.__name__ == "AddonButton"][index-1]

                            # Cache updated addon info into button, or skip if it's already cached
                            if selected_button.properties:
                                if not selected_button.properties.description:
                                    new_addon_info = addons.get_modpack_info(addon)
                                    selected_button.properties = new_addon_info

                            Clock.schedule_once(functools.partial(selected_button.loading, False), 1)

                            return selected_button.properties, selected_button.installed

                        # Don't crash if add-on failed to load
                        except:
                            Clock.schedule_once(
                                functools.partial(
                                    screen_manager.current_screen.show_banner,
                                    (1, 0.5, 0.65, 1),
                                    f"Failed to load modpack",
                                    "close-circle-sharp.png",
                                    2.5,
                                    {"center_x": 0.5, "center_y": 0.965}
                                ), 0
                            )


                    # Function to install addon
                    def install_addon(index):

                        def move_to_next_page(addon, *a):
                            addon = addons.get_modpack_url(addon)
                            constants.import_data = {
                                'name': addon.name,
                                'url': addon.download_url
                            }
                            def progress(*a):
                                screen_manager.current = "ServerImportModpackProgressScreen"
                            Clock.schedule_once(progress, 0.4)

                        selected_button = [item for item in self.scroll_layout.walk() if item.__class__.__name__ == "AddonButton"][index-1]
                        threading.Timer(0, functools.partial(move_to_next_page, selected_button.properties)).start()


                    # Activated when addon is clicked
                    def view_addon(addon, index, *args):
                        selected_button = [item for item in self.scroll_layout.walk() if item.__class__.__name__ == "AddonButton"][index - 1]

                        selected_button.loading(True)

                        Clock.schedule_once(
                            functools.partial(
                                self.show_popup,
                                "addon",
                                " ",
                                " ",
                                (None, functools.partial(install_addon, index)),
                                functools.partial(load_addon, addon, index)
                            ),
                            0
                        )


                    # Add-on button click function
                    self.scroll_layout.add_widget(
                        ScrollItem(
                            widget = AddonButton(
                                properties = addon_object,
                                installed = False,
                                fade_in = ((x if x <= 8 else 8) / self.anim_speed),
                                click_function = functools.partial(
                                    view_addon,
                                    addon_object,
                                    x
                                )
                            )
                        )
                    )

                self.resize_bind()
                self.scroll_layout.parent.parent.scroll_y = 1

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.header = None
        self.scroll_layout = None
        self.blank_label = None
        self.search_bar = None
        self.page_switcher = None

        self.last_results = []
        self.page_size = 20
        self.current_page = 0
        self.max_pages = 0
        self.anim_speed = 10

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        super()._on_keyboard_down(keyboard, keycode, text, modifiers)

        # Press arrow keys to switch pages
        if keycode[1] in ['right', 'left'] and self.name == screen_manager.current_screen.name:
            self.switch_page(keycode[1])
        elif keycode[1] == "tab" and self.name == screen_manager.current_screen.name:
            for widget in self.search_bar.children:
                try:
                    if widget.id == "search_input":
                        widget.grab_focus()
                        break
                except AttributeError:
                    pass

    def generate_menu(self, **kwargs):

        # Scroll list
        scroll_widget = ScrollViewWidget(position=(0.5, 0.437))
        scroll_anchor = AnchorLayout()
        self.scroll_layout = GridLayout(cols=1, spacing=15, size_hint_max_x=1250, size_hint_y=None, padding=[0, 30, 0, 30])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 1.79
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1
            self.anim_speed = 13 if Window.width > grid_layout.size_hint_max_x else 10

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, self.scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        self.scroll_layout.bind(minimum_height=self.scroll_layout.setter('height'))
        self.scroll_layout.id = 'scroll_content'

        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.715}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.17}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60))

        # Generate buttons on page load
        addon_count = 0
        very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["very-bold"])
        header_content = constants.translate("Modpack Search")
        self.header = HeaderText(header_content, '', (0, 0.89), __translate__ = (False, True))

        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(self.header)

        # Add blank label to the center
        self.blank_label = Label()
        self.blank_label.text = "search for modpacks above"
        self.blank_label.font_name = os.path.join(constants.gui_assets, 'fonts', constants.fonts['italic'])
        self.blank_label.pos_hint = {"center_x": 0.5, "center_y": 0.48}
        self.blank_label.font_size = sp(24)
        self.blank_label.color = (0.6, 0.6, 1, 0.35)
        float_layout.add_widget(self.blank_label)


        search_function = addons.search_modpacks
        self.search_bar = search_input(return_function=search_function, pos_hint={"center_x": 0.5, "center_y": 0.795})
        self.page_switcher = PageSwitcher(0, 0, (0.5, 0.805), self.switch_page)


        # Append scroll view items
        scroll_anchor.add_widget(self.scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)
        float_layout.add_widget(self.search_bar)
        float_layout.add_widget(self.page_switcher)

        buttons.append(ExitButton('Back', (0.5, 0.12), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        menu_name = "Install a modpack, Download"
        float_layout.add_widget(generate_title("Download Modpack"))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)

        # # Autofocus search bar
        # for widget in self.search_bar.children:
        #     try:
        #         if widget.id == "search_input":
        #             widget.grab_focus()
        #             break
        #     except AttributeError:
        #         pass

        Clock.schedule_once(functools.partial(self.search_bar.execute_search, ""), 0)


# Server Manager Overview ----------------------------------------------------------------------------------------------

# Opens server in panel, and updates Server Manager current_server
def open_server(server_name, wait_page_load=False, show_banner='', ignore_update=True, launch=False, show_readme=None, *args):
    def next_screen(*args):
        different_server = constants.server_manager.current_server.name != server_name
        if different_server:
            while constants.server_manager.current_server.name != server_name:
                time.sleep(0.005)

        if screen_manager.current == 'ServerViewScreen' and different_server:
            screen_manager.current = 'ServerManagerScreen'

        screen_manager.current = 'ServerViewScreen'

        if launch:
            Clock.schedule_once(screen_manager.current_screen.console_panel.launch_server, 0)

        if show_banner:
            Clock.schedule_once(
                functools.partial(
                    screen_manager.current_screen.show_banner,
                    (0.553, 0.902, 0.675, 1),
                    show_banner,
                    "checkmark-circle-sharp.png",
                    2.5,
                    {"center_x": 0.5, "center_y": 0.965}
                ), 0
            )

        constants.screen_tree = ['MainMenuScreen', 'ServerManagerScreen']


        # If showing readme
        if show_readme:
            Clock.schedule_once(
                functools.partial(screen_manager.current_screen.show_popup, "file", "Author's Notes", show_readme, (None)),
                1
            )


    constants.server_manager.open_server(server_name)
    server_obj = constants.server_manager.current_server

    needs_update = False
    try:
        if constants.update_list:
            needs_update = constants.update_list[server_obj.name]['needsUpdate'] == 'true'
    except:
        pass

    # Automatically update if available
    if server_obj.running:
        ignore_update = True
    if server_obj.auto_update == "true" and needs_update and constants.app_online and not ignore_update and constants.check_free_space(telepath_data=server_obj._telepath_data):
        while not server_obj.addon:
            time.sleep(0.05)

        if server_obj.is_modpack == 'mrpack':
            if constants.update_list[server_obj.name]['updateUrl']:
                constants.import_data = {
                    'name': server_obj.name,
                    'url': constants.update_list[server_obj.name]['updateUrl']
                }
                os.chdir(constants.get_cwd())
                constants.safe_delete(constants.tempDir)
                screen_manager.current = 'UpdateModpackProgressScreen'
                screen_manager.current_screen.page_contents['launch'] = launch

        else:
            constants.new_server_init()
            constants.init_update()
            constants.new_server_info['type'] = server_obj.type
            constants.new_server_info['version'] = constants.latestMC[server_obj.type]
            if server_obj.type in ['forge', 'paper', 'purpur', 'quilt', 'neoforge']:
                constants.new_server_info['build'] = constants.latestMC['builds'][server_obj.type]
            screen_manager.current = 'MigrateServerProgressScreen'
            screen_manager.current_screen.page_contents['launch'] = launch

    else:
        Clock.schedule_once(next_screen, 0.8 if wait_page_load else 0)

def open_remote_server(instance, server_name, wait_page_load=False, show_banner='', ignore_update=True, launch=False, show_readme=None, *args):

    def next_screen(*args):
        different_server = constants.server_manager.current_server.name != server_name
        if different_server:
            while constants.server_manager.current_server.name != server_name:
                time.sleep(0.005)

        elif constants.server_manager.current_server:
            constants.server_manager.current_server.reload_config()

        if screen_manager.current == 'ServerViewScreen' and different_server:
            screen_manager.current = 'ServerManagerScreen'

        screen_manager.current = 'ServerViewScreen'

        if launch:
            Clock.schedule_once(screen_manager.current_screen.console_panel.launch_server, 0)

        if show_banner:
            Clock.schedule_once(
                functools.partial(
                    screen_manager.current_screen.show_banner,
                    (0.553, 0.902, 0.675, 1),
                    show_banner,
                    "checkmark-circle-sharp.png",
                    2.5,
                    {"center_x": 0.5, "center_y": 0.965}
                ), 0
            )

        constants.screen_tree = ['MainMenuScreen', 'ServerManagerScreen']


        # If showing readme
        if show_readme:
            Clock.schedule_once(
                functools.partial(screen_manager.current_screen.show_popup, "file", "Author's Notes", show_readme, (None)),
                1
            )

    remote_obj = constants.api_manager.request(
        endpoint=f'/main/open_remote_server?name={constants.quote(server_name)}',
        host=instance['host'],
        port=instance['port'],
        args={'none': None}
    )

    if remote_obj:
        telepath_data = {'name': server_name, 'host': instance['host'], 'port': instance['port'], 'nickname': instance['nickname']}
        constants.server_manager._init_telepathy(telepath_data)
        server_obj = constants.server_manager.current_server
        update_list = constants.get_remote_var('update_list', telepath_data)

        needs_update = False
        try:
            if update_list:
                needs_update = update_list[server_obj.name]['needsUpdate'] == 'true'
        except:
            pass

        # Automatically update if available
        if server_obj.running:
            ignore_update = True
        if server_obj.auto_update == "true" and needs_update and constants.app_online and not ignore_update and constants.check_free_space(telepath_data=server_obj._telepath_data):
            while not server_obj.addon:
                time.sleep(0.05)

            if server_obj.is_modpack == 'mrpack':
                if update_list[server_obj.name]['updateUrl']:
                    constants.import_data = {
                        'name': server_obj.name,
                        'url': update_list[server_obj.name]['updateUrl']
                    }
                    os.chdir(constants.get_cwd())
                    constants.safe_delete(constants.tempDir)
                    screen_manager.current = 'UpdateModpackProgressScreen'
                    screen_manager.current_screen.page_contents['launch'] = launch

            else:
                constants.new_server_init()
                constants.init_update()
                constants.new_server_info['type'] = server_obj.type
                constants.new_server_info['version'] = constants.latestMC[server_obj.type]
                if server_obj.type in ['forge', 'paper', 'purpur', 'quilt', 'neoforge']:
                    constants.new_server_info['build'] = constants.latestMC['builds'][server_obj.type]
                screen_manager.current = 'MigrateServerProgressScreen'
                screen_manager.current_screen.page_contents['launch'] = launch

        else:
            telepath_data = {'name': server_name, 'host': instance['host'], 'port': instance['port'], 'nickname': instance['nickname']}
            constants.server_manager._init_telepathy(telepath_data)
            Clock.schedule_once(next_screen, 0.8 if wait_page_load else 0)

    return remote_obj


def disk_popup(go_to='back', telepath_data=None):
    if not constants.check_free_space(telepath_data=telepath_data):
        def go_back(*a):
            constants.back_clicked = True
            if go_to == 'back':
                previous_screen()
            else:
                screen_manager.current = go_to
            constants.back_clicked = False

        def disk_error(*_):
            screen_manager.current_screen.show_popup(
                "warning",
                "Storage Error",
                f"auto-mcs has limited functionality from low disk space. Further changes can lead to corruption in your servers.\n\nPlease free up space on {'this $Telepath$ instance' if telepath_data else 'your disk'} to continue",
                go_back
            )
        Clock.schedule_once(disk_error, 0)
        return True
def telepath_popup(go_to='back'):
    if constants.telepath_busy():
        def go_back(*a):
            constants.back_clicked = True
            if go_to == 'back':
                previous_screen()
            else:
                screen_manager.current = go_to
            constants.back_clicked = False

        def telepath_error(*_):
            screen_manager.current_screen.show_popup(
                "warning",
                "Telepath Error",
                "A critical operation is currently running through a $Telepath$ session.\n\nPlease try again later",
                go_back
            )
        Clock.schedule_once(telepath_error, 0)
        return True

def refresh_ips(server_name):
    screen = screen_manager.current_screen
    if "ServerViewScreen" in screen.name:
        if screen.server.name == server_name:
            screen.server_button.update_subtitle(screen.server.run_data)
constants.refresh_ips = refresh_ips

class ServerButton(HoverButton):

    class ParagraphLabel(Label, HoverBehavior):

        def on_mouse_pos(self, *args):

            if "ServerViewScreen" in screen_manager.current_screen.name and self.copyable:
                try:
                    super().on_mouse_pos(*args)
                except:
                    pass

        # Hover stuffies
        def on_enter(self, *args):

            if self.copyable:
                self.outline_width = 0
                self.outline_color = constants.brighten_color(self.color, 0.05)
                Animation(outline_width=1, duration=0.03).start(self)

        def on_leave(self, *args):

            if self.copyable:
                Animation.stop_all(self)
                self.outline_width = 0

        # Normal stuffies
        def on_ref_press(self, *args):
            if not self.disabled:
                def click(*a):
                    clipboard_text = re.sub("\[.*?\]", "", self.text.split(" ")[-1].strip())
                    if self.parent.button_pressed == "left":
                        banner_text = "Copied IP address  (right-click for LAN)"

                    else:
                        server_obj = self.parent.properties
                        if server_obj.running:
                            clipboard_text = server_obj.run_data['network']['private_ip'] + ':' + server_obj.run_data['network']['address']['port']

                        banner_text = "Copied LAN IP address  (left-click for public)"


                    Clock.schedule_once(
                        functools.partial(
                            screen_manager.current_screen.show_banner,
                            (0.85, 0.65, 1, 1),
                            banner_text,
                            "link-sharp.png",
                            2,
                            {"center_x": 0.5, "center_y": 0.965}
                        ), 0
                    )

                    Clipboard.copy(clipboard_text)

                Clock.schedule_once(click, 0)

        def ref_text(self, *args):

            if '[ref=' not in self.text and '[/ref]' not in self.text and self.copyable:
                self.text = f'[ref=none]{self.text.strip()}[/ref]'
            elif '[/ref]' in self.text:
                self.text = self.text.replace("[/ref]", "") + "[/ref]"

        def __init__(self, **kwargs):
            super().__init__(**kwargs)
            self.markup = True
            self.copyable = True
            self.bind(text=self.ref_text)

    class ChangeIconButton(Button, HoverBehavior):

        # Show menu to replace icon
        def on_click(self, *a):

            def apply_new_icon(path: str = None, *a):
                def do_change():
                    icon_path = False

                    # Upload to remote if Telepath
                    if path:
                        if self.server_obj._telepath_data:
                            icon_path = constants.telepath_upload(self.server_obj._telepath_data, path)['path']
                        else:
                            icon_path = path
                    success, message = self.server_obj.update_icon(icon_path)

                    # Reload page
                    if success:

                        # Override for Telepath
                        if self.server_obj._telepath_data:
                            constants.get_server_icon(self.server_obj.name, self.server_obj._telepath_data, overwrite=True)

                        # Remove the cached image and texture
                        Cache.remove('kv.image')
                        Cache.remove('kv.texture')
                        for item in glob(os.path.join(constants.gui_assets, 'live', 'blur_icon_*.png')):
                            os.remove(item)

                    return success, message

                def loading_screen(*a):
                    screen_manager.current = 'BlurredLoadingScreen'

                Clock.schedule_once(loading_screen, 0)

                # Actually rename the server files
                time.sleep(0.5)
                success, message = do_change()

                # Change header and footer text to reflect change
                def reload_page(*a):
                    def go_back(*a):
                        screen_manager.current = 'ServerViewScreen'

                    Clock.schedule_once(go_back, 0)

                    # Display banner to show success
                    Clock.schedule_once(
                        functools.partial(
                            screen_manager.current_screen.show_banner,
                            (0.553, 0.902, 0.675, 1) if success else (1, 0.5, 0.65, 1),
                            message,
                            "checkmark-circle-sharp.png" if success else "close-circle-sharp.png",
                            3,
                            {"center_x": 0.5, "center_y": 0.965}
                        ), 0.1
                    )

                Clock.schedule_once(reload_page, 0)

            # Add icon with left click
            if self.last_touch.button == 'left':
                title = "Select an image"
                selection = file_popup("file", start_dir=constants.userDownloads, ext=constants.valid_image_formats, input_name=None, select_multiple=False, title=title)
                if selection and selection[0]:
                    threading.Timer(0, functools.partial(apply_new_icon, selection[0])).start()

            # Delete icon with right click
            elif self.last_touch.button == 'right' and self.is_custom:

                Clock.schedule_once(
                    functools.partial(
                        screen_manager.current_screen.show_popup,
                        "warning_query",
                        'Remove Icon',
                        "Do you want to remove this icon?\n\nYou'll need to re-import it again later",
                        (None, functools.partial(threading.Timer(0, apply_new_icon).start))
                    ),
                    0
                )

        def on_enter(self, *args):
            Animation.stop_all(self)
            Animation.stop_all(self.type_image)
            Animation(opacity=1, duration=self.anim_duration).start(self)
            Animation(opacity=0, duration=self.anim_duration).start(self.type_image.image)
            if self.server_obj._telepath_data:
                Animation(opacity=0, duration=self.anim_duration).start(self.type_image.tp_shadow)
                Animation(opacity=0, duration=self.anim_duration).start(self.type_image.tp_icon)

        def on_leave(self, *args):
            Animation.stop_all(self)
            Animation.stop_all(self.type_image)
            Animation(opacity=0, duration=self.anim_duration).start(self)
            Animation(opacity=1, duration=self.anim_duration).start(self.type_image.image)
            if self.server_obj._telepath_data:
                Animation(opacity=1, duration=self.anim_duration).start(self.type_image.tp_shadow)
                Animation(opacity=1, duration=self.anim_duration).start(self.type_image.tp_icon)

        def generate_blur_background(self, *args):
            def run_in_foreground(*a):
                self.blur_background.source = image_path
                self.canvas.ask_update()

            try:
                # Attempt to remove existing icon temp, who even cares lol
                for item in glob(os.path.join(constants.gui_assets, 'live', 'blur_icon_*.png')):
                    if self.server_obj.name in item:
                        image_path = item
                        return run_in_foreground()
                    os.remove(item)
            except:
                pass
            image_path = os.path.join(constants.gui_assets, 'live', f'blur_icon_{self.server_obj.name}_{constants.gen_rstring(4)}.png')
            constants.folder_check(os.path.join(constants.gui_assets, 'live'))

            self.type_image.image.export_to_png(image_path)

            # Convert the image in the background
            def convert(*a):
                im = PILImage.open(image_path)

                # Center and resize icon when custom
                if self.is_custom:
                    im = im.convert('RGBA')
                    left = 4
                    upper = (im.height - 65)
                    right = left + 65
                    lower = upper + 65
                    im = im.crop((left, upper, right, lower))

                # Blur and darken the icon
                im = ImageEnhance.Brightness(im)
                im = im.enhance(0.75)
                im1 = im.filter(GaussianBlur(3))

                im1.save(image_path)

                Clock.schedule_once(run_in_foreground, 0)
            threading.Timer(0, convert).start()

        def resize_self(self, *a):
            for child in self.children:
                child.pos = self.pos

            offset = (self.pos[0] + 17.5, self.pos[1] + 16.5)
            self.background_ellipse.pos = offset
            self.blur_background.pos = offset
            self.background_outline.ellipse = (*offset, 66, 66)

        def __init__(self, type_image, **kwargs):
            super().__init__(**kwargs)
            self.type_image = type_image
            self.size_hint_max = self.type_image.image.size
            self.is_custom = self.type_image.image.__class__.__name__ == 'CustomServerIcon'
            self.background_normal = os.path.join(constants.gui_assets, 'empty.png')
            self.background_down = os.path.join(constants.gui_assets, 'empty.png')
            self.anim_duration = 0.1
            self.fg = self.type_image.version_label.color
            self.bc = constants.brighten_color(constants.background_color, -0.1)
            self.server_obj = constants.server_manager.current_server

            with self.canvas.before:
                # Background ellipse (drawn first)
                Color(self.bc[0], self.bc[1], self.bc[2], 0.3)  # Adjust alpha as needed
                self.background_ellipse = Ellipse(
                    size=(66, 66),
                    angle_start=0,
                    angle_end=360
                )

            with self.canvas:
                # Blur background ellipse (drawn after background ellipse)
                Color(*self.fg)
                self.blur_background = Ellipse(
                    size=(66, 66),
                    angle_start=0,
                    angle_end=360
                )

                # Outline of the ellipse
                Color(*self.fg[:3], 0.0)
                self.background_outline = Line(
                    ellipse=(0, 0, 66, 66),
                    width=2
                )

            self.shadow = Image(source=icon_path('shadow.png'), color="#111122")
            self.shadow.opacity = 0.5
            self.icon = Image(source=icon_path('pencil-sharp.png'), color=constants.brighten_color(self.fg, 0.15))
            self.add_widget(self.shadow)
            self.add_widget(self.icon)

            # Bind and initialize
            self.bind(size=self.resize_self, pos=self.resize_self)
            self.bind(on_press=self.on_click)
            self.generate_blur_background()
            self.opacity = 0


    def toggle_favorite(self, favorite, *args):
        self.favorite = favorite
        self.color_id = [(0.05, 0.05, 0.1, 1), constants.brighten_color((0.85, 0.6, 0.9, 1) if self.favorite else (0.65, 0.65, 1, 1), 0.07)]
        self.title.text_size = (self.size_hint_max[0] * (0.7 if favorite else 0.94), self.size_hint_max[1])
        self.background_normal = os.path.join(constants.gui_assets, f'{self.id}{"_favorite" if self.favorite else ""}.png')
        self.resize_self()
        return favorite

    def animate_button(self, image, color, **kwargs):
        image_animate = Animation(duration=0.05)

        def f(w):
            w.background_normal = image

        Animation(color=color, duration=0.06).start(self.title)
        Animation(color=self.run_color if (self.running and not self.hovered) else color, duration=0.06).start(self.subtitle)

        if not self.custom_icon:
            Animation(color=color, duration=0.06).start(self.type_image.image)

        if self.type_image.version_label.__class__.__name__ == "AlignLabel":
            Animation(color=color, duration=0.06).start(self.type_image.version_label)
        Animation(color=color, duration=0.06).start(self.type_image.type_label)

        a = Animation(duration=0.0)
        a.on_complete = functools.partial(f)

        image_animate += a

        image_animate.start(self)

    def resize_self(self, *args):

        # Title and description
        padding = 2.17
        self.title.pos = (self.x + (self.title.text_size[0] / padding) - (5.3 if self.favorite else 8.3) + 30, self.y + 31)
        self.subtitle.pos = (self.x + (self.subtitle.text_size[0] / padding) - 78, self.y + 8)


        offset = 9.45 if self.type_image.type_label.text in ["vanilla", "paper", "purpur"]\
            else 9.6 if self.type_image.type_label.text == "forge"\
            else 9.35 if self.type_image.type_label.text == "craftbukkit"\
            else 9.55


        self.type_image.image.x = self.width + self.x - (self.type_image.image.width) - 13
        self.type_image.image.y = self.y + ((self.height / 2) - (self.type_image.image.height / 2))

        # Telepath icon
        if self.telepath_data:
            self.type_image.tp_shadow.pos = (self.type_image.image.x - 2, self.type_image.image.y)
            self.type_image.tp_icon.pos = (self.type_image.image.x - 2, self.type_image.image.y)


        self.type_image.type_label.x = self.width + self.x - (self.padding_x * offset) - self.type_image.width - 83
        self.type_image.type_label.y = self.y + (self.height * 0.05)

        # Update label
        if self.type_image.version_label.__class__.__name__ == "AlignLabel":
            self.type_image.version_label.x = self.width + self.x - (self.padding_x * offset) - self.type_image.width - 83
            self.type_image.version_label.y = self.y - (self.height / 3.2)

        # Banner version object
        else:
            self.type_image.version_label.x = self.width + self.x - (self.padding_x * offset) - self.type_image.width - 130
            self.type_image.version_label.y = self.y - (self.height / 3.2) - 2


        # Favorite button
        self.favorite_layout.size_hint_max = (self.size_hint_max[0], self.size_hint_max[1])
        self.favorite_layout.pos = (self.pos[0] - 6, self.pos[1] + 13)


        # Change Icon button pos
        if self.icon_button:
            half = self.type_image.image.size_hint_max[0] / 4
            offset = 2.5 if self.type_image.image.__class__.__name__ == 'CustomServerIcon' else -1
            self.icon_button.pos = (self.type_image.image.x - half + offset, self.type_image.image.y - half)


        # Highlight border
        self.highlight_border.pos = self.pos

    def highlight(self):
        def next_frame(*args):
            Animation.stop_all(self.highlight_border)
            self.highlight_border.opacity = 1
            Animation(opacity=0, duration=0.7).start(self.highlight_border)

        Clock.schedule_once(next_frame, 0)

    def update_subtitle(self, run_data=None, last_modified=None):

        def reset(*a):
            self.running = False
            self.subtitle.copyable = False
            if last_modified:
                self.original_subtitle = backup.convert_date(last_modified)
            self.subtitle.color = self.color_id[1]
            self.subtitle.default_opacity = 0.56
            self.subtitle.font_name = self.original_font
            self.subtitle.text = self.original_subtitle

        try:
            if run_data:
                self.running = True
                self.subtitle.copyable = True
                self.subtitle.color = self.run_color
                self.subtitle.default_opacity = 0.8
                self.subtitle.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
                if 'playit-tunnel' in run_data and run_data['playit-tunnel']:
                    text = run_data['network']['address']['ip']
                else:
                    text = ':'.join(run_data['network']['address'].values())
                self.subtitle.text = f"[font={self.icons}]N[/font]  {text.replace('127.0.0.1', 'localhost')}"
            else:
                reset()

        except KeyError:
            reset()

        self.subtitle.opacity = self.subtitle.default_opacity

    def generate_name(self, color='#7373A2'):
        if self.telepath_data:
            tld = self.telepath_data['host']
            if self.telepath_data['nickname']:
                tld = self.telepath_data['nickname']
            return f'[color={color}]{tld}/[/color]{self.properties.name}'
        else:
            return self.properties.name.strip()

    def __init__(self, server_object, click_function=None, fade_in=0.0, highlight=None, update_banner="", view_only=False, **kwargs):
        super().__init__(**kwargs)

        # Check if server is remote
        self.telepath_data = server_object._telepath_data

        self.view_only = view_only

        if self.view_only:
            self.ignore_hover = True

        self.favorite = server_object.favorite
        self.properties = server_object
        self.border = (-5, -5, -5, -5)
        self.color_id = [(0.05, 0.05, 0.1, 1), constants.brighten_color((0.85, 0.6, 0.9, 1) if self.favorite else (0.65, 0.65, 1, 1), 0.07)]
        self.run_color = (0.529, 1, 0.729, 1)
        self.running = server_object.running and server_object.run_data
        self.pos_hint = {"center_x": 0.5, "center_y": 0.6}
        self.size_hint_max = (580, 80)
        self.id = "server_button"

        if not self.view_only:
            self.background_normal = os.path.join(constants.gui_assets, f'{self.id}.png')
            self.background_down = os.path.join(constants.gui_assets, f'{self.id}{"_favorite" if self.favorite else ""}_click.png')
        else:
            self.background_normal = os.path.join(constants.gui_assets, f'{self.id}_ro.png')
            self.background_down = os.path.join(constants.gui_assets, f'{self.id}{"_favorite" if self.favorite else "_ro"}.png')

        self.icons = os.path.join(constants.gui_assets, 'fonts', constants.fonts['icons'])


        # Loading stuffs
        self.original_subtitle = backup.convert_date(server_object.last_modified)
        self.original_font = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["regular"]}.ttf')


        # Title of Server
        self.title = Label()
        self.title.__translate__ = False
        self.title.id = "title"
        self.title.halign = "left"
        self.title.color = self.color_id[1]
        self.title.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
        self.title.font_size = sp(25)
        self.title.text_size = (self.size_hint_max[0] * 0.58, self.size_hint_max[1])
        self.title.shorten = True
        self.title.markup = True
        self.title.shorten_from = "right"
        self.title.max_lines = 1
        self.title.text = self.generate_name()
        self.add_widget(self.title)


        # Server last modified date formatted
        if self.view_only:
            self.subtitle = self.ParagraphLabel()
        else:
            self.subtitle = Label()
        self.subtitle.__translate__ = False
        self.subtitle.size = (300, 30)
        self.subtitle.id = "subtitle"
        self.subtitle.halign = "left"
        self.subtitle.valign = "center"
        self.subtitle.font_size = sp(21)
        self.subtitle.text_size = (self.size_hint_max[0] * 0.91, self.size_hint_max[1])
        self.subtitle.shorten = True
        self.subtitle.markup = True
        self.subtitle.shorten_from = "right"
        self.subtitle.max_lines = 1
        self.subtitle.text_size[0] = 350

        if self.running:
            self.subtitle.copyable = True
            self.subtitle.color = self.run_color
            self.subtitle.default_opacity = 0.8
            self.subtitle.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')

            if 'playit-tunnel' in server_object.run_data and server_object.run_data['playit-tunnel']:
                text = server_object.run_data['network']['address']['ip']
            else:
                text = ':'.join(server_object.run_data['network']['address'].values())
            self.subtitle.text = f"[font={self.icons}]N[/font]  {text.replace('127.0.0.1', 'localhost')}"
        else:
            self.subtitle.copyable = False
            self.subtitle.color = self.color_id[1]
            self.subtitle.default_opacity = 0.56
            self.subtitle.font_name = self.original_font
            self.subtitle.text = self.original_subtitle

        self.subtitle.opacity = self.subtitle.default_opacity

        self.add_widget(self.subtitle)



        # Type icon and info
        self.type_image = RelativeLayout()
        self.type_image.width = 400

        # Check for custom server icon
        if self.telepath_data:
            self.telepath_data['icon-path'] = server_object.server_icon
            self.server_icon = constants.get_server_icon(server_object.name, self.telepath_data)
        else:
            self.server_icon = server_object.server_icon

        if self.server_icon:
            self.custom_icon = True
            class CustomServerIcon(RelativeLayout):
                def __init__(self, server_icon, **kwargs):
                    super().__init__(**kwargs)
                    with self.canvas:
                        Color(1, 1, 1, 1)  # Set the color to white
                        self.shadow = Ellipse(pos=(-23.5, -27.5), size=(120, 120), source=os.path.join(constants.gui_assets, 'icon_shadow.png'), angle_start=0, angle_end=360)
                        self.ellipse = Ellipse(pos=(4, 0), size=(65, 65), source=server_icon, angle_start=0, angle_end=360)
            self.type_image.image = CustomServerIcon(self.server_icon)
        else:
            self.custom_icon = False
            self.server_icon = os.path.join(constants.gui_assets, 'icons', 'big', f'{server_object.type.lower()}_small.png')
            self.type_image.image = Image(source=self.server_icon)

        self.type_image.image.allow_stretch = True
        self.type_image.image.size_hint_max = (65, 65)
        self.type_image.image.color = self.color_id[1]
        self.type_image.add_widget(self.type_image.image)


        # Show icon on self.type_image to specify
        if self.telepath_data:
            self.type_image.tp_shadow = Image(source=icon_path('shadow.png'))
            self.type_image.tp_shadow.allow_stretch = True
            self.type_image.tp_shadow.size_hint_max = (33, 33)
            self.type_image.tp_shadow.color = self.color_id[0]
            self.type_image.add_widget(self.type_image.tp_shadow)

            self.type_image.tp_icon = Image(source=icon_path('telepath.png'))
            self.type_image.tp_icon.allow_stretch = True
            self.type_image.tp_icon.size_hint_max = (33, 33)
            self.type_image.tp_icon.color = self.color_id[1]
            self.type_image.add_widget(self.type_image.tp_icon)
        else:
            self.type_image.tp_shadow = None
            self.type_image.tp_icon = None


        def TemplateLabel():
            template_label = AlignLabel()
            template_label.__translate__ = False
            template_label.halign = "right"
            template_label.valign = "middle"
            template_label.text_size = template_label.size
            template_label.font_size = sp(19)
            template_label.color = self.color_id[1]
            template_label.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
            template_label.width = 150
            return template_label


        if update_banner:
            self.type_image.version_label = RelativeLayout()
            self.type_image.version_label.add_widget(
                BannerObject(
                    pos_hint={"center_x": 1, "center_y": 0.5},
                    size=(100, 30),
                    color=(0.647, 0.839, 0.969, 1),
                    text= ('   ' + update_banner + '  ') if update_banner.startswith('b-') else update_banner,
                    icon="arrow-up-circle.png",
                    icon_side="left"
                )
            )

        else:
            self.type_image.version_label = TemplateLabel()
            self.type_image.version_label.text = server_object.version.lower()
            self.type_image.version_label.opacity = 0.6

        self.type_image.version_label.color = self.color_id[1]
        self.type_image.type_label = TemplateLabel()

        # Say modpack if such
        if self.properties.is_modpack:
            type_text = 'modpack'
        else:
            type_text = server_object.type.lower().replace("craft", "")
        self.type_image.type_label.text = type_text
        self.type_image.type_label.font_size = sp(23)
        self.type_image.add_widget(self.type_image.version_label)
        self.type_image.add_widget(self.type_image.type_label)
        self.add_widget(self.type_image)


        # Favorite button
        self.favorite_layout = RelativeLayout()
        favorite = None
        if not view_only:
            self.icon_button = None
            try:
                favorite = functools.partial(screen_manager.current_screen.favorite, server_object.name, server_object)
            except AttributeError:
                pass

        else:
            self.icon_button = self.ChangeIconButton(self.type_image)
            self.add_widget(self.icon_button)

        if self.favorite:
            self.favorite_button = IconButton('', {}, (0, 0), (None, None), 'heart-sharp.png', clickable=not self.view_only, force_color=[[(0.05, 0.05, 0.1, 1), (0.85, 0.6, 0.9, 1)], 'pink'], anchor='right', click_func=favorite)
        else:
            self.favorite_button = IconButton('', {}, (0, 0), (None, None), 'heart-outline.png', clickable=not self.view_only, anchor='right', click_func=favorite)

        self.favorite_layout.add_widget(self.favorite_button)
        self.add_widget(self.favorite_layout)


        # Highlight border
        self.highlight_layout = RelativeLayout()
        self.highlight_border = Image()
        self.highlight_border.keep_ratio = False
        self.highlight_border.allow_stretch = True
        self.highlight_border.color = constants.brighten_color(self.color_id[1], 0.1)
        self.highlight_border.opacity = 0
        self.highlight_border.source = os.path.join(constants.gui_assets, 'server_button_highlight.png')
        self.highlight_layout.add_widget(self.highlight_border)
        self.highlight_layout.width = self.size_hint_max[0]
        self.highlight_layout.height = self.size_hint_max[1]
        self.add_widget(self.highlight_layout)



        # Toggle favorite stuffies
        self.bind(pos=self.resize_self)
        if self.favorite:
            self.toggle_favorite(self.favorite)

        # If click_function
        if click_function and not view_only:
            self.bind(on_press=click_function)



        # Animate opacity
        if fade_in > 0:
            self.opacity = 0
            self.title.opacity = 0

            Animation(opacity=1, duration=fade_in).start(self)
            Animation(opacity=1, duration=fade_in).start(self.title)
            Animation(opacity=self.subtitle.default_opacity, duration=fade_in).start(self.subtitle)

        if highlight:
            self.highlight()

    def on_enter(self, *args):
        if not self.ignore_hover:
            self.animate_button(image=os.path.join(constants.gui_assets, f'{self.id}{"_favorite" if self.favorite else ""}_hover.png'), color=self.color_id[0], hover_action=True)

            self.title.text = self.generate_name('#2D2D4E')

            if self.telepath_data:
                new_color = constants.convert_color('#E865D4' if self.favorite else '#6769D9')['rgb']
                Animation(color=new_color, duration=0.1).start(self.type_image.tp_shadow)
                Animation(color=constants.brighten_color(self.color_id[0], -0.1), duration=0.1).start(self.type_image.tp_icon)

    def on_leave(self, *args):
        if not self.ignore_hover:
            self.animate_button(image=os.path.join(constants.gui_assets, f'{self.id}{"_favorite" if self.favorite else ""}.png'), color=self.color_id[1], hover_action=False)

            self.title.text = self.generate_name()

            if self.telepath_data:
                Animation(color=self.color_id[0], duration=0.1).start(self.type_image.tp_shadow)
                Animation(color=self.color_id[1], duration=0.1).start(self.type_image.tp_icon)

    def update_context_options(self):
        def _open_server(name):
            if self.telepath_data:
                constants.api_manager.request(
                    endpoint=f'/main/open_remote_server?name={constants.quote(name)}',
                    host=self.telepath_data['host'],
                    port=self.telepath_data['port'],
                    args={'none': None}
                )
                new_data = constants.deepcopy(self.telepath_data)
                new_data['name'] = name
                return constants.server_manager._init_telepathy(new_data)
            else:
                return constants.server_manager.open_server(name)

        # Functions for context menu
        def launch(*a):
            if self.telepath_data:
                open_remote_server(self.telepath_data, self.properties.name, launch=True)
            else:
                open_server(self.properties.name, launch=True)
        def restart(*a):
            _open_server(self.properties.name).restart()
        def stop(*a):
            _open_server(self.properties.name).stop()
        def settings(*a):
            _open_server(self.properties.name)
            screen_manager.current = 'ServerSettingsScreen'
        def update(*a):
            settings()
            screen_manager.current_screen.update_button.button.trigger_action()
        def rename(*a):
            settings()
            rename_input = screen_manager.current_screen.rename_input
            screen_manager.current_screen.scroll_widget.scroll_to(rename_input)
            Clock.schedule_once(rename_input.grab_focus, 0.2)
        def delete(*a):
            settings()
            delete_button = screen_manager.current_screen.delete_button
            screen_manager.current_screen.scroll_widget.scroll_to(delete_button, animate=False)
            Clock.schedule_once(delete_button.button.trigger_action, 0.1)
        def copy_ip(local, *a):
                def click(*a):
                    clipboard_text = re.sub("\[.*?\]", "", self.subtitle.text.split(" ")[-1].strip())
                    if not local:
                        banner_text = "Copied IP address"

                    else:
                        server_obj = self.properties
                        if server_obj.running:
                            clipboard_text = server_obj.run_data['network']['private_ip'] + ':' + server_obj.run_data['network']['address']['port']
                        banner_text = "Copied LAN IP address"

                    Clock.schedule_once(
                        functools.partial(
                            screen_manager.current_screen.show_banner,
                            (0.85, 0.65, 1, 1),
                            banner_text,
                            "link-sharp.png",
                            2,
                            {"center_x": 0.5, "center_y": 0.965}
                        ), 0
                    )

                    Clipboard.copy(clipboard_text)

                Clock.schedule_once(click, 0)

        # Context menu buttons
        if self.view_only and self.properties.running:
            self.context_options = [
                {'name': 'Copy local IP', 'icon': 'ethernet.png', 'action': functools.partial(copy_ip, True)},
                {'name': 'Copy public IP', 'icon': 'wifi.png', 'action': functools.partial(copy_ip, False)}
            ]
        else:
            if self.properties.running:
                self.context_options = [
                    {'name': 'Restart', 'icon': 'restart-server.png', 'action': restart},
                    {'name': 'Stop', 'icon': 'stop-server.png', 'action': stop},
                    {'name': 'Copy IP', 'icon': 'wifi-sharp.png', 'action': functools.partial(copy_ip, False)},
                    {'name': 'Settings', 'icon': os.path.join('sm', 'advanced.png'), 'action': settings}
                ]
            else:
                if self.properties.is_modpack == 'zip':
                    u = None
                else:
                    u = self.properties.update_string
                self.context_options = [
                    {'name': 'Launch', 'icon': 'start-server.png', 'action': launch} if screen_manager.current_screen.name != "ServerViewScreen" else None,
                    {'name': f'Update {"build" if u.startswith("b-") else f"{u}"}', 'icon': 'arrow-up.png', 'action': update} if u else None,
                    {'name': 'Rename', 'icon': 'rename.png', 'action': rename},
                    {'name': 'Settings', 'icon': os.path.join('sm', 'advanced.png'), 'action': settings},
                    {'name': 'Delete', 'icon': 'trash-sharp.png', 'action': delete, 'color': 'red'}
                ]

class ServerManagerScreen(MenuBackground):

    # Toggles favorite of item, and reload list
    def favorite(self, server_name, properties):
        if properties._telepath_data:
            properties.toggle_favorite()
            bool_favorite = properties.favorite

        else:
            bool_favorite = constants.toggle_favorite(server_name)

        # Show banner
        if server_name in constants.server_manager.running_servers:
            constants.server_manager.running_servers[server_name].favorite = bool_favorite

        if bool_favorite:
            banner_message = f"'${server_name}$' marked as favorite"
        else:
            banner_message = f"'${server_name}$' is no longer marked as favorite"

        Clock.schedule_once(
            functools.partial(
                screen_manager.current_screen.show_banner,
                (0.85, 0.65, 1, 1) if bool_favorite else (0.68, 0.68, 1, 1),
                banner_message,
                "heart-sharp.png" if bool_favorite else "heart-dislike-outline.png",
                2,
                {"center_x": 0.5, "center_y": 0.965}
            ), 0
        )


        constants.server_manager.refresh_list()
        self.gen_search_results(constants.server_manager.server_list, fade_in=False, highlight=properties._view_name)

    def switch_page(self, direction):

        if self.max_pages == 1:
            return

        if direction == "right":
            if self.current_page == self.max_pages:
                self.current_page = 1
            else:
                self.current_page += 1

        else:
            if self.current_page == 1:
                self.current_page = self.max_pages
            else:
                self.current_page -= 1

        self.page_switcher.update_index(self.current_page, self.max_pages)
        self.gen_search_results(self.last_results)

    def gen_search_results(self, results, new_search=False, fade_in=True, highlight=None, animate_scroll=True, *args):

        # Set to proper page on favorite/un-favorite
        default_scroll = 1
        if highlight:
            def divide_chunks(l, n):
                final_list = []

                for i in range(0, len(l), n):
                    final_list.append(l[i:i + n])

                return final_list

            for x, l in enumerate(divide_chunks([x._view_name for x in results], self.page_size), 1):
                if highlight in l:
                    if self.current_page != x:
                        self.current_page = x

                    # Update scroll when page is bigger than list
                    if Window.height < self.scroll_layout.height:
                        default_scroll = 1 - round(l.index(highlight) / len(l), 2)
                        if default_scroll < 0.2:
                            default_scroll = 0
                        if default_scroll > 0.97:
                            default_scroll = 1
                    break


        # Update page counter
        self.last_results = results
        self.max_pages = (len(results) / self.page_size).__ceil__()
        self.current_page = 1 if self.current_page == 0 or new_search else self.current_page


        self.page_switcher.update_index(self.current_page, self.max_pages)
        page_list = results[(self.page_size * self.current_page) - self.page_size:self.page_size * self.current_page]

        self.scroll_layout.clear_widgets()


        # Generate header
        server_count = len(constants.server_manager.server_list)
        header_content = "Select a server to manage"

        for child in self.header.children:
            if child.id == "text":
                child.text = header_content
                break


        # Show servers if they exist
        if server_count != 0:

            # Clear and add all ServerButtons
            for x, server_obj in enumerate(page_list, 1):

                # Activated when server is clicked
                def view_server(server, index, *args):
                    selected_button = [item for item in self.scroll_layout.walk() if item.__class__.__name__ == "ServerButton"][index - 1]

                    # View Server
                    if selected_button.last_touch.button == "left":
                        if not selected_button.telepath_data:
                            open_server(server.name, ignore_update=False)
                        else:
                            open_remote_server(selected_button.telepath_data, server.name, ignore_update=False)

                    # Favorite
                    elif selected_button.last_touch.button == "middle":
                        self.favorite(server.name)


                # Check if updates are available
                update_banner = ""
                if server_obj.auto_update == 'true':
                    update_banner = server_obj.update_string


                # Add-on button click function
                self.scroll_layout.add_widget(
                    ScrollItem(
                        widget = ServerButton(
                            server_object = server_obj,
                            fade_in = ((x if x <= 8 else 8) / self.anim_speed) if fade_in else 0,
                            highlight = (highlight == server_obj._view_name),
                            update_banner = update_banner,
                            click_function = functools.partial(
                                view_server,
                                server_obj,
                                x
                            )
                        )
                    )
                )

            self.resize_bind()

        # Go back to main menu if they don't
        else:
            screen_manager.current = 'MainMenuScreen'
            constants.screen_tree = []
            return

        # Animate scrolling
        def set_scroll(*args):
            Animation.stop_all(self.scroll_layout.parent.parent)
            if animate_scroll:
                Animation(scroll_y=default_scroll, duration=0.1).start(self.scroll_layout.parent.parent)
            else:
                self.scroll_layout.parent.parent.scroll_y = default_scroll
        Clock.schedule_once(set_scroll, 0)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.header = None
        self.scroll_layout = None
        self.blank_label = None
        self.page_switcher = None

        self.last_results = []
        self.page_size = 10
        self.current_page = 0
        self.max_pages = 0
        self.anim_speed = 10

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        super()._on_keyboard_down(keyboard, keycode, text, modifiers)

        # Press arrow keys to switch pages
        if keycode[1] in ['right', 'left'] and self.name == screen_manager.current_screen.name:
            self.switch_page(keycode[1])

    def generate_menu(self, **kwargs):

        # Scroll list
        scroll_widget = ScrollViewWidget(position=(0.5, 0.48))
        scroll_anchor = AnchorLayout()
        self.scroll_layout = GridLayout(cols=1, spacing=15, size_hint_max_x=1250, size_hint_y=None, padding=[0, 30, 0, 30])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 1.82
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1
            self.anim_speed = 13 if Window.width > grid_layout.size_hint_max_x else 10

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, self.scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        self.scroll_layout.bind(minimum_height=self.scroll_layout.setter('height'))
        self.scroll_layout.id = 'scroll_content'


        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.755}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.22}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60))

        # Generate buttons on page load
        header_content = "Select a server in which to manage"
        self.header = HeaderText(header_content, '', (0, 0.89))

        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(self.header)

        self.page_switcher = PageSwitcher(0, 0, (0.5, 0.887), self.switch_page)


        # Append scroll view items
        scroll_anchor.add_widget(self.scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)
        float_layout.add_widget(self.page_switcher)

        buttons.append(ExitButton('Back', (0.5, 0.12), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        menu_name = "Server Manager"
        float_layout.add_widget(generate_title("Server Manager"))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)

        # Automatically generate results on page load
        constants.server_manager.refresh_list()
        highlight = False
        self.gen_search_results(constants.server_manager.server_list)

        # Highlight the last server that was last selected
        def highlight_last_server(*args):
            server_obj = constants.server_manager.current_server
            if server_obj:
                highlight = server_obj._view_name
                self.gen_search_results(constants.server_manager.server_list, highlight=highlight, animate_scroll=False)
        Clock.schedule_once(highlight_last_server, 0)

class MenuTaskbar(RelativeLayout):

    def resize(self, *args):

        # Resize background
        self.bg_left.x = 0
        self.bg_right.x = self.width
        self.bg_center.x = 0 + self.bg_left.width
        self.bg_center.size_hint_max_x = self.width - (self.bg_left.width * 2)

    def show_notification(self, tile_name, show=True):
        for tile in self.taskbar.children:
            if tile_name == tile.name:
                tile.show_notification(show=show)
                break

    def __init__(self, selected_item=None, animate=False, **kwargs):
        super().__init__(**kwargs)

        server_obj = constants.server_manager.current_server

        show_addons = (server_obj.type != 'vanilla')
        server_obj.taskbar = self
        self.pos_hint = {"center_x": 0.5}


        # Layout for icon object
        class TaskbarItem(RelativeLayout):

            def show_notification(self, show=True, animate=True):
                if animate:
                    Animation(opacity=(1 if show else 0), duration=0.25, transition='in_out_sine').start(self.notification)
                    def fade_in(*a):
                        Animation(opacity=(0.5 if show else 0), duration=0.15, transition='in_out_sine').start(self.notification_glow)
                    Clock.schedule_once(fade_in, 0.1)
                    def fade_out(*a):
                        Animation(opacity=0, duration=0.5, transition='in_out_sine').start(self.notification_glow)
                    Clock.schedule_once(fade_out, 0.35)
                else:
                    self.notification.opacity = (1 if show else 0)

            def __init__(self, item_info, selected=False, **kwargs):
                super().__init__(**kwargs)
                new_color = constants.convert_color(item_info[2])['rgb']
                self.name = item_info[0]


                # Icon and listed functions
                class Icon(AnchorLayout, HoverBehavior):

                    # Pretty animation if specified
                    def animate(self, *args):
                        def anim_in(*args):
                            Animation(size_hint_max=(self.default_size + 6, self.default_size + 6), duration=0.15, transition='in_out_sine').start(self.icon)
                            if self.selected:
                                Animation(opacity=1, duration=0.3, transition='in_out_sine').start(self.background)
                                Animation(color=constants.brighten_color(self.hover_color, -0.87), duration=0.2, transition='in_out_sine').start(self.icon)

                        def anim_out(*args):
                            Animation(size_hint_max=(self.default_size, self.default_size), duration=0.15, transition='in_out_sine').start(self.icon)

                        Clock.schedule_once(anim_in, 0.1)
                        Clock.schedule_once(anim_out, 0.25)


                    # Execute click function
                    def on_touch_down(self, touch):
                        if self.hovered and not self.selected and not screen_manager.current_screen.popup_widget:

                            # Log for crash info
                            try:
                                interaction = f"TaskbarButton ({self.data[0].title()})"
                                constants.last_widget = interaction + f" @ {constants.format_now()}"
                            except:
                                pass

                            # Animate button
                            self.icon.color = constants.brighten_color(self.hover_color, 0.2)
                            Animation(color=self.hover_color, duration=0.3).start(self.icon)

                            constants.back_clicked = True

                            # Return if back is clicked
                            if self.data[0] == 'back':

                                screen_manager.current = 'ServerManagerScreen'
                                constants.screen_tree = ['MainMenuScreen']


                            # If not back, proceed to next screen
                            else:
                                # Wait for data to exist on ServerAclScreen, ServerBackupScreen, And ServerAddonScreen
                                if self.data[-1] == 'ServerAclScreen':
                                    if not constants.server_manager.current_server.acl:
                                        while not constants.server_manager.current_server.acl:
                                            time.sleep(0.2)

                                if self.data[-1] == 'ServerBackupScreen':
                                    if not constants.server_manager.current_server.backup:
                                        while not constants.server_manager.current_server.backup:
                                            time.sleep(0.2)

                                if self.data[-1] == 'ServerAddonScreen':
                                    if not constants.server_manager.current_server.addon:
                                        while not constants.server_manager.current_server.addon:
                                            time.sleep(0.2)

                                if self.data[-1] == 'ServerAmscriptScreen':
                                    if not constants.server_manager.current_server.script_manager:
                                        while not constants.server_manager.current_server.script_manager:
                                            time.sleep(0.2)

                                screen_manager.current = self.data[-1]

                            constants.back_clicked = False

                        # If no button is matched, return touch to super
                        else:
                            super().on_touch_down(touch)


                    # Change attributes when hovered
                    def on_enter(self):
                        if self.ignore_hover:
                            return

                        if not self.selected:
                            Animation(size_hint_max=(self.default_size + 6, self.default_size + 6), duration=0.15, transition='in_out_sine', color=self.hover_color).start(self.icon)
                        Animation(opacity=1, duration=0.25, transition='in_out_sine').start(self.parent.text)

                    def on_leave(self):
                        self.ignore_hover = False
                        if not self.selected:
                            Animation(size_hint_max=(self.default_size, self.default_size), duration=0.15, transition='in_out_sine', color=self.default_color).start(self.icon)
                        Animation(opacity=0, duration=0.25, transition='in_out_sine').start(self.parent.text)

                    def __init__(self, **kwargs):
                        super().__init__(**kwargs)

                        self.data = item_info
                        self.default_size = 40
                        self.default_color = (0.8, 0.8, 1, 1)
                        self.selected = selected
                        self.hover_color = new_color
                        self.size_hint_max = (self.default_size + 23, self.default_size + 23)
                        self.icon = Image()
                        self.icon.size_hint_max = (self.default_size, self.default_size)
                        self.icon.pos_hint = {'center_x': 0.5, 'center_y': 0.5}
                        self.icon.source = item_info[1]
                        self.icon.color = self.default_color


                        # Add background and change color if selected
                        if self.selected:
                            self.background = Image(source=os.path.join(constants.gui_assets, 'icons', 'sm', 'selected.png'))
                            self.background.pos_hint = {'center_x': 0.5, 'center_y': 0.5}
                            self.background.size_hint_max = self.size_hint_max
                            self.background.color = self.hover_color
                            self.add_widget(self.background)
                            if animate:
                                self.background.opacity = 0
                            else:
                                self.icon.color = constants.brighten_color(self.hover_color, -0.87)

                        self.add_widget(self.icon)


                        # Ignore on_hover when selected widget is already selected on page load
                        self.ignore_hover = False
                        def check_prehover(*args):
                            if self.collide_point(*self.to_widget(*Window.mouse_pos)) and self.selected:
                                self.ignore_hover = True
                        Clock.schedule_once(check_prehover, 0)


                self.icon = Icon()
                self.add_widget(self.icon)

                self.text = RelativeLayout(size_hint_min=(300, 50))
                self.text.add_widget(BannerObject(pos_hint={'center_x': 0.5, 'center_y': 0.75}, text=item_info[0], size=(70, 30), color=new_color))
                self.text.pos_hint = {'center_x': 0.5, 'center_y': 1}
                self.text.opacity = 0
                self.add_widget(self.text)


                # Notification icon
                self.notification_glow = Image(source=os.path.join(constants.gui_assets, 'icons', 'sm', 'notification-glow.png'))
                self.notification_glow.opacity = 0
                self.notification_glow.pos_hint = {'center_x': 0.7, 'center_y': 0.7}
                self.notification_glow.size_hint_max = (27, 27)
                self.notification_glow.color = constants.convert_color('#FFC175')['rgb']
                self.add_widget(self.notification_glow)

                self.notification = Image(source=os.path.join(constants.gui_assets, 'icons', 'sm', 'notification.png'))
                self.notification.opacity = 0
                self.notification.pos_hint = {'center_x': 0.7, 'center_y': 0.7}
                self.notification.size_hint_max = (20, 20)
                self.notification.color = constants.convert_color('#FFC175')['rgb']
                self.add_widget(self.notification)

        # Icon list  (name, path, color, next_screen)
        icon_path = os.path.join(constants.gui_assets, 'icons', 'sm')
        self.item_list = [
            ('back',            os.path.join(icon_path, 'back-outline.png'),  '#FF6FB4'),
            ('launch',          os.path.join(icon_path, 'terminal.png'),      '#817EFF',  'ServerViewScreen'),
            ('back-ups',        os.path.join(icon_path, 'backup.png'),        '#56E6FF',  'ServerBackupScreen'),
            ('access control',  os.path.join(icon_path, 'acl.png'),           '#00FFB2',  'ServerAclScreen'),
            ('add-ons',         os.path.join(icon_path, 'addon.png'),         '#42FF5E',  'ServerAddonScreen'),
            ('amscript',        os.path.join(icon_path, 'amscript.png'),      '#BFFF2B',  'ServerAmscriptScreen'),
            ('settings',        os.path.join(icon_path, 'advanced.png'),      '#FFFF44',  'ServerSettingsScreen')
        ]


        self.y = 65
        self.size_hint_max = (500 if show_addons else 430, 64)
        self.side_width = self.size_hint_max[1] * 0.55
        self.background_color = (0.063, 0.067, 0.141, 1)


        # Define resizable background
        self.bg_left = Image()
        self.bg_left.keep_ratio = False
        self.bg_left.allow_stretch = True
        self.bg_left.size_hint_max = (self.side_width, self.size_hint_max[1])
        self.bg_left.source = os.path.join(constants.gui_assets, 'taskbar_edge.png')
        self.bg_left.color = self.background_color
        self.add_widget(self.bg_left)

        self.bg_right = Image()
        self.bg_right.keep_ratio = False
        self.bg_right.allow_stretch = True
        self.bg_right.size_hint_max = (-self.side_width, self.size_hint_max[1])
        self.bg_right.source = os.path.join(constants.gui_assets, 'taskbar_edge.png')
        self.bg_right.color = self.background_color
        self.add_widget(self.bg_right)

        self.bg_center = Image()
        self.bg_center.keep_ratio = False
        self.bg_center.allow_stretch = True
        self.bg_center.source = os.path.join(constants.gui_assets, 'taskbar_center.png')
        self.bg_center.color = self.background_color
        self.add_widget(self.bg_center)


        # Taskbar layout
        self.taskbar = BoxLayout(orientation='horizontal', padding=[5,0,5,0])
        for x, item in enumerate(self.item_list):

            name = item[0]

            if name == 'add-ons' and not show_addons:
                continue

            selected = (selected_item == name)
            item = TaskbarItem(item, selected=selected)
            self.taskbar.add_widget(item)
            if animate:
                Clock.schedule_once(item.icon.animate, x / 15)

            # Show notification if appropriate
            show = False

            if name == 'settings' and server_obj.update_string:
                if 'settings' not in server_obj.viewed_notifs:
                    show = True
                elif server_obj.update_string != server_obj.viewed_notifs['settings']:
                    show = True

            elif name in server_obj.viewed_notifs:
                if not server_obj.viewed_notifs[name]:
                    show = True

            if show:
                item.show_notification(True, animate)

        self.add_widget(self.taskbar)


        self.bind(pos=self.resize, size=self.resize)
        Clock.schedule_once(self.resize, 0)



# Server Manager Launch ------------------------------------------------------------------------------------------------

# Prompt for backups and updates on new server config
def prompt_new_server(server_obj, *args):

    # Step 3 - prompt for updates
    def set_update(boolean):
        server_obj.enable_auto_update(boolean)
        server_obj.reload_config()

    def prompt_updates(*args):
        screen_manager.current_screen.show_popup(
            "query",
            "Automatic Updates",
            f"Would you like to enable automatic updates for '${server_obj.name}$'?\n\nIf an update is available, auto-mcs will update this server when opened",
            [functools.partial(set_update, False),
             functools.partial(set_update, True)]
        )

    # Step 2 - apply settings from backup popup and prompt for updates
    def set_bkup_and_prompt_update(boolean):
        server_obj.backup.enable_auto_backup(boolean)
        if boolean:
            threading.Timer(0, server_obj.backup.save).start()

        def wait_timer(*a):
            while screen_manager.current_screen.popup_widget:
                time.sleep(0.1)
            if not constants.server_manager.current_server.is_modpack or constants.server_manager.current_server.is_modpack == 'mrpack':
                Clock.schedule_once(prompt_updates, 0)
        threading.Timer(0, wait_timer).start()

    # Step 1 - prompt for backups
    def prompt_backup(*args):
        screen_manager.current_screen.show_popup(
            "query",
            "Automatic Back-ups",
            f"Would you like to enable automatic back-ups for '${server_obj.name}$'?\n\nauto-mcs will back up this server when closed",
            [functools.partial(set_bkup_and_prompt_update, False),
             functools.partial(set_bkup_and_prompt_update, True)]
        )

    prompt_backup()

class PerformancePanel(RelativeLayout):

    def update_rect(self, *args):
        texture_offset = 70

        # Resize panel
        console_panel = screen_manager.current_screen.console_panel
        self.y = console_panel.default_y + (Window.height - console_panel.size_offset[1]) - 24
        self.width = Window.width - console_panel.size_offset[0] + texture_offset
        self.height = 240

        # Repos panel widgets
        overview_max = (Window.width * 0.2)
        self.overview_widget.size_hint_max_x = overview_max if overview_max >= self.overview_min else self.overview_min

        meter_max = (Window.width * 0.32)
        self.meter_layout.size_hint_max_x = meter_max if meter_max >= self.meter_min else self.meter_min
        self.meter_layout.x = self.width - self.meter_layout.width
        for child in self.meter_layout.children:
            Clock.schedule_once(child.recalculate_size, 0)

        self.player_widget.x = self.overview_widget.x + self.overview_widget.width - texture_offset + 12
        self.player_widget.size_hint_max_x = (self.width) - self.meter_layout.width - self.overview_widget.width + (texture_offset * 2) - 24
        Clock.schedule_once(self.player_widget.recalculate_size, 0)

    # Updates data in panel while the server is running
    def refresh_data(self, interval=0.5, *args):

        # Get performance stats if running locally
        server_obj = constants.server_manager.current_server

        # Prevent a crash from doing something while in the menu of a server, and current_server is reset
        if not server_obj:
            return

        if server_obj and not server_obj._telepath_data:
            threading.Timer(0, functools.partial(server_obj.performance_stats, interval, (self.player_clock == 3))).start()

        # If the server is running remotely, update the console text as needed
        # This should probably be moved, though, it's the only client loop
        elif screen_manager.current_screen.name == 'ServerViewScreen' and server_obj._telepath_data:
            console_panel = screen_manager.current_screen.console_panel
            if server_obj.running and server_obj.run_data:
                server_obj.run_data = server_obj._telepath_run_data()

                # Check if remote server has disconnected when updating panel
                if not server_obj.run_data:
                    if check_telepath_disconnect():
                        return True

                try:
                    data_len = len(console_panel.scroll_layout.data)
                    run_len = len(server_obj.run_data['log'])
                    if data_len <= run_len:
                        console_panel.update_text(server_obj.run_data['log'], animate_last=(run_len > data_len))

                    if server_obj.run_data['deadlocked']:
                        console_panel.toggle_deadlock(True)

                # If log was removed from run_data
                except KeyError:
                    pass

                # Close the console if remotely launched, and no logs exist
                if not server_obj.running or not server_obj.run_data:
                    data = server_obj._sync_telepath_stop()
                    server_obj.crash_log = data['crash']
                    console_panel.update_text(data['log'])
                    console_panel.reset_panel(data['crash'])

                    # Before closing, save contents to temp for view screen
                    constants.folder_check(constants.tempDir)
                    file_name = f"{server_obj._telepath_data['display-name']}, {server_obj.name}-latest.log"
                    with open(os.path.join(constants.tempDir, file_name), 'w+') as f:
                        f.write(json.dumps(data['log']))


        def update_data(*args):
            try:
                perf_data = constants.server_manager.current_server.run_data['performance']
            except KeyError:
                return
            except AttributeError:
                return

            # Update meter
            self.cpu_meter.set_percent(perf_data['cpu'])
            self.ram_meter.set_percent(perf_data['ram'])

            # Update up-time
            formatted_color = '[color=#737373]'
            found = False
            for x, item in enumerate(perf_data['uptime'].split(":")):
                if x == 0 and len(item) > 2:
                    formatted_color = f'{item}:'
                    found = True
                    continue
                if x == 0 and item != '00':
                    item = int(item)
                    formatted_color += '[/color]' if len(str(item)) >= 2 else '0[/color]'
                    found = True
                if item != "00" and not found:
                    found = True
                    item = int(item)
                    formatted_color += f'[/color]{item}:' if len(str(item)) == 2 else f'0[/color]{item}:'
                else:
                    formatted_color += f'{item}:'


            # Update player count every 5 cycles
            self.player_clock += 1
            if self.player_clock > 5:
                self.player_clock = 0

                total_count = int(self.overview_widget.max_players)
                percent = (len(perf_data['current-players']) / total_count)
                self.player_widget.update_data(perf_data['current-players'])

                # Update Discord rich presence
                constants.discord_presence.update_presence('Server Manager > Launch')

                # Colors
                if percent == 0:
                    color = (0.45, 0.45, 0.45, 1)
                elif percent < 50:
                    color = (0.92, 0.92, 0.92, 1)
                elif percent < 75:
                    color = (1, 0.9, 0.5, 1)
                else:
                    color = (1, 0.53, 0.58, 1)

                Animation(color=color, duration=0.4, transition='in_out_sine').start(self.overview_widget.player_label.label)
                self.overview_widget.player_label.label.text = f'{len(perf_data["current-players"])}[color=#737373] / [/color]{total_count}'

            self.overview_widget.uptime_label.text = formatted_color[:-1]
            Animation(color=(0.92, 0.92, 0.92, 1), duration=0.4, transition='in_out_sine').start(self.overview_widget.uptime_label.label)

        if server_obj:
            Clock.schedule_once(update_data, (interval + 0.05))

    # Sets panel back to the default state
    def reset_panel(self):
        def reset(*args):
            self.cpu_meter.set_percent(0)
            self.ram_meter.set_percent(0)
            self.overview_widget.reset_panel()
            self.player_widget.update_data(None)
        Clock.schedule_once(reset, 1.5)

    def __init__(self, server_name, **kwargs):
        super().__init__(**kwargs)

        normal_accent = constants.convert_color("#707CB7")['rgb']
        dark_accent = constants.convert_color("#151523")['rgb']
        yellow_accent = (1, 0.9, 0.5, 1)
        gray_accent = (0.45, 0.45, 0.45, 1)
        green_accent = (0.3, 1, 0.6, 1)
        red_accent = (1, 0.53, 0.58, 1)

        self.overview_min = 280
        self.meter_min = 350
        self.player_clock = 0


        # Label with shadow
        class ShadowLabel(RelativeLayout):

            def __setattr__(self, attr, value):
                if "text" in attr or "color" in attr:
                    try:
                        self.label.__setattr__(attr, value)
                        self.shadow.__setattr__(attr, value)
                        Clock.schedule_once(self.on_resize, 0)
                    except AttributeError:
                        super().__setattr__(attr, value)
                else:
                    super().__setattr__(attr, value)


            def on_resize(self, *args):
                max_x = 500
                self.label.texture_update()
                self.size_hint_max = self.label.texture_size
                self.size_hint_max[0] = max_x
                self.label.size_hint_max = self.label.texture_size
                self.label.size_hint_max[0] = max_x

                self.shadow.texture_update()
                self.shadow.size_hint_max = self.shadow.texture_size
                self.shadow.size_hint_max[0] = max_x
                self.shadow.pos = (self.label.x + self.offset, self.label.y - self.offset)


            def __init__(self, text, font, size, color, align='left', offset=2, shadow_color=dark_accent, __translate__=True, **kwargs):
                super().__init__(**kwargs)

                self.offset = offset

                # Shadow
                self.shadow = AlignLabel()
                self.shadow.__translate__ = __translate__
                self.shadow.text = text
                self.shadow.font_name = font
                self.shadow.font_size = size
                self.shadow.color = shadow_color
                self.shadow.halign = align
                self.add_widget(self.shadow)

                # Main label
                self.label = AlignLabel()
                self.label.__translate__ = __translate__
                self.label.text = text
                self.label.font_name = font
                self.label.font_size = size
                self.label.color = color
                self.label.halign = align
                self.label.markup = True
                self.add_widget(self.label)

                self.bind(pos=self.on_resize)
                Clock.schedule_once(self.on_resize, 0)

        # Hacky background for panel objects
        class PanelFrame(Button):

            def on_press(self):
                self.state = 'normal'
                pass

            def on_touch_down(self, touch):
                return super().on_touch_down(touch)

            def on_touch_up(self, touch):
                return super().on_touch_up(touch)

            def __init__(self, **kwargs):
                super().__init__(**kwargs)

                self.background_normal = os.path.join(constants.gui_assets, 'performance_panel.png')
                self.background_down = os.path.join(constants.gui_assets, 'performance_panel.png')
                self.background_color = constants.convert_color("#232439")['rgb']
                self.pos_hint = {'center_x': 0.5, 'center_y': 0.5}
                self.border = (60, 60, 60, 60)


        class MeterWidget(RelativeLayout):

            def set_percent(self, percent: float or int, animate=True, *args):

                # Normalize value
                self.percent = round(percent, 1)
                if percent >= 100:
                    self.percent = 100
                if percent <= 0:
                    self.percent = 0


                # Colors
                if self.percent < 5:
                    color = gray_accent
                elif self.percent < 50:
                    color = green_accent
                elif self.percent < 75:
                    color = yellow_accent
                else:
                    color = red_accent


                # Update properties
                self.percentage_label.text = f'{self.percent} %'
                new_size = round(self.progress_bg.size_hint_max_x * (self.percent / 100)) if self.percent >= 1 else 0

                Animation.stop_all(self.progress_bar)
                Animation.stop_all(self.percentage_label.label)

                if animate:
                    Animation(color=color, duration=0.3, transition='in_out_sine').start(self.percentage_label.label)
                    Animation(color=color, duration=0.3, transition='in_out_sine').start(self.progress_bar)
                    if new_size == 0:
                        Animation.stop_all(self.progress_bar)
                        Animation(color=color, size_hint_max_x=new_size, duration=0.4, transition='in_out_sine').start(self.progress_bar)
                    else:
                        Animation(size_hint_max_x=new_size, duration=0.99, transition='in_out_sine').start(self.progress_bar)
                else:
                    self.percentage_label.label.color = self.progress_bar.color = color
                    self.progress_bar.size_hint_max_x = new_size

            def recalculate_size(self, *args):

                # Update bar size
                padding = (self.width - self.meter_min) * 0.03
                self.progress_bg.pos = (45 + padding, 52)
                self.progress_bg.size_hint_max = (self.width - 145 - (padding * 2), 7)
                self.progress_bar.pos = (self.progress_bg.x, self.progress_bg.y + self.progress_bar.size_hint_max[1] + 1)
                self.set_percent(self.percent, animate=False)

                # Set text position
                text_x = self.width - self.percentage_label.width - 45 - padding
                self.percentage_label.pos = (text_x, self.progress_bar.pos[1] + 12)
                self.name.pos = (text_x, self.progress_bg.pos[1] - (self.progress_bar.size_hint_max[1] / 2))

            def __init__(self, meter_name, meter_min=350, **kwargs):
                super().__init__(**kwargs)

                self.percent = 0
                self.meter_min = meter_min

                # Background
                self.background = PanelFrame()
                self.size_hint_max_y = 152
                self.add_widget(self.background)


                # Progress bar
                self.progress_bg = Image(color=dark_accent)
                self.add_widget(self.progress_bg)

                self.progress_bar = Image(color=gray_accent)
                self.progress_bar.size_hint_max = (0, 7)
                self.add_widget(self.progress_bar)


                # Label text
                self.name = ShadowLabel(
                    __translate__ = False,
                    text = meter_name,
                    font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["medium"]),
                    size = sp(22),
                    color = normal_accent,
                    align = 'right',
                    shadow_color = (0, 0, 0, 0)
                )
                self.add_widget(self.name)


                # Percent text
                self.percentage_label = ShadowLabel(
                    __translate__ = False,
                    text = f'{self.percent} %',
                    font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["bold"]),
                    size = sp(30),
                    color = gray_accent,
                    offset = 3,
                    align = 'right',
                    shadow_color = (0, 0, 0, 0)
                )
                self.add_widget(self.percentage_label)

                Clock.schedule_once(self.recalculate_size, 0)


        class OverviewWidget(RelativeLayout):

            def reset_panel(self):
                def reset_text(*args):
                    self.uptime_label.text = f'00:00:00:00'
                    self.player_label.text = f'0 / {self.max_players}'
                Animation(color=gray_accent, duration=0.4, transition='in_out_sine').start(self.uptime_label.label)
                Animation(color=gray_accent, duration=0.4, transition='in_out_sine').start(self.player_label.label)
                Clock.schedule_once(reset_text, 0.4)

            def __init__(self, overview_min=270, **kwargs):
                super().__init__(**kwargs)

                try:
                    self.max_players = constants.server_manager.current_server.server_properties['max-players']
                except KeyError:
                    self.max_players = 20

                self.background = PanelFrame()
                self.size_hint_max_x = overview_min
                self.overview_min = overview_min
                self.add_widget(self.background)


                # Up-time title
                self.uptime_title = ShadowLabel(
                    text = f'up-time',
                    font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["italic"]),
                    size = sp(23),
                    color = normal_accent,
                    offset = 3,
                    align = 'center',
                    shadow_color = constants.brighten_color(dark_accent, 0.04)
                )
                self.uptime_title.pos_hint = {'center_x': 0.5}
                self.uptime_title.y = 170
                self.add_widget(self.uptime_title)

                # Up-time label
                self.uptime_label = ShadowLabel(
                    __translate__ = False,
                    text = f'00:00:00:00',
                    font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["mono-bold"]) + '.otf',
                    size = sp(30),
                    color = gray_accent,
                    offset = 3,
                    align = 'center',
                    shadow_color = (0, 0, 0, 0)
                )
                self.uptime_label.pos_hint = {'center_x': 0.5}
                self.uptime_label.y = 135
                self.add_widget(self.uptime_label)



                # Player count title
                self.player_title = ShadowLabel(
                    text = f'capacity',
                    font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["italic"]),
                    size = sp(23),
                    color = normal_accent,
                    offset = 3,
                    align = 'center',
                    shadow_color = constants.brighten_color(dark_accent, 0.04)
                )
                self.player_title.pos_hint = {'center_x': 0.5}
                self.player_title.y = 80
                self.add_widget(self.player_title)

                # Player count label
                self.player_label = ShadowLabel(
                    __translate__ = False,
                    text = f'0 / {self.max_players}',
                    font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["bold"]),
                    size = sp(26),
                    color = gray_accent,
                    offset = 3,
                    align = 'center',
                    shadow_color = (0, 0, 0, 0)
                )
                self.player_label.pos_hint = {'center_x': 0.5}
                self.player_label.y = 45
                self.add_widget(self.player_label)


        class PlayerWidget(RelativeLayout):

            # Add players
            def update_data(self, player_dict):
                if player_dict:
                    if self.player_list:
                        self.player_list.rows = None

                    if self.layout.opacity == 0:
                        Animation(opacity=0, duration=0.4, transition='in_out_sine').start(self.empty_label)
                        def after_anim(*args):
                            Animation(opacity=1, duration=0.4, transition='in_out_sine').start(self.layout)
                        Clock.schedule_once(after_anim, 0.4)

                    # if self.scroll_layout.data:
                    #     self.unq_hash['before'] = self.scroll_layout.data
                    # self.unq_hash['after'] = player_dict
                    self.scroll_layout.data = player_dict

                    if self.resize_list:
                        self.resize_list()

                else:
                    if self.layout.opacity == 1:
                        Animation(opacity=0, duration=0.4, transition='in_out_sine').start(self.layout)
                        def after_anim(*args):
                            Animation(opacity=1, duration=0.4, transition='in_out_sine').start(self.empty_label)
                        Clock.schedule_once(after_anim, 0.4)

            def resize_list(self, *args):
                blank_name = ''

                data_len = len(self.scroll_layout.data)

                try:
                    if self.player_list.rows <= 5:
                        for player in self.scroll_layout.data:
                            if player['text'] == blank_name:
                                self.scroll_layout.data.remove(player)
                        data_len = len([item for item in self.scroll_layout.data if item['text'] != blank_name])
                except TypeError:
                    pass


                text_width = 240
                if self.scroll_layout.width <= 50:
                    self.recalculate_size()
                    return

                # Dirty fix to circumvent RecycleView missing data: https://github.com/kivy/kivy/pull/7262
                try:
                    text_width = int(((self.scroll_layout.width // text_width) // 1))
                    self.player_list.cols = text_width
                    self.player_list.rows = round(data_len / text_width) + 3
                    # print(text_width, self.player_list.cols, self.player_list.rows, data_len)

                    if ((data_len <= self.player_list.cols) and self.player_list.rows <= 5) or data_len + 1 == self.player_list.cols:
                        if self.scroll_layout.data[-1] is not {'text': blank_name}:
                            for x in range(self.player_list.cols):
                                self.scroll_layout.data.append({'text': blank_name})
                except ZeroDivisionError:
                    pass
                except IndexError:
                    pass

            def recalculate_size(self, *args):
                texture_offset = 70
                list_offset = 15

                self.layout.pos = ((texture_offset / 2), (texture_offset / 2) + list_offset)
                self.layout.size_hint_max = (self.width - texture_offset, self.height - texture_offset - (list_offset * 3.5))
                self.scroll_layout.size = self.layout.size

                Clock.schedule_once(self.resize_list, 0)

            def __init__(self, **kwargs):
                super().__init__(**kwargs)

                # self.unq_hash = {'before': None, 'after': None}

                class PlayerLabel(RelativeLayout):

                    class PlayerButton(HoverButton):
                        def update_context_options(self):
                            username = self.parent.label.text
                            if not self.ignore_hover and username:

                                # Functions for context menu
                                def permissions(*a):
                                    if constants.server_manager.current_server.acl:
                                        constants.server_manager.current_server.acl.get_rule(re.sub("\[.*?\]", "", username))
                                        constants.back_clicked = True
                                        screen_manager.current = 'ServerAclScreen'
                                        constants.back_clicked = False
                                def copy(data_type: str, *a):
                                    try:
                                        player_info = constants.server_manager.current_server.run_data['player-list'][username]
                                        text = player_info[data_type]
                                        banner_text = f'Copied ${data_type.upper().replace("USER","username")}$ to clipboard'

                                        Clock.schedule_once(
                                            functools.partial(
                                                screen_manager.current_screen.show_banner,
                                                (0.85, 0.65, 1, 1),
                                                banner_text,
                                                "link-sharp.png",
                                                2,
                                                {"center_x": 0.5, "center_y": 0.965}
                                            ), 0
                                        )

                                        Clipboard.copy(text)

                                    except KeyError:
                                        pass
                                def kick(*a):
                                    constants.server_manager.current_server.acl.kick_player(username)

                                # Context menu buttons
                                self.context_options = [
                                    {'name': 'Copy username', 'icon': 'person.png', 'action': functools.partial(copy, 'user')},
                                    {'name': 'Copy UUID', 'icon': 'id-card-sharp.png', 'action': functools.partial(copy, 'uuid')},
                                    {'name': 'Copy IP', 'icon': 'wifi-sharp.png', 'action': functools.partial(copy, 'ip')},
                                    {'name': 'Permissions', 'icon': 'shield-half-small.png', 'action': permissions},
                                    {'name': 'Kick player', 'icon': 'exit-sharp.png', 'action': kick, 'color': 'red'}
                                ]

                    def disable(self, boolean: bool, animate=False):
                        def disable(*a):
                            self.button.ignore_hover = boolean
                            constants.hide_widget(self, boolean)
                            constants.hide_widget(self.button, boolean)
                            self.button.disabled = boolean

                        if animate:
                            duration = 0.3

                            if not boolean:
                                disable()

                            self.opacity = (1 if boolean else 0)
                            Animation.stop_all(self)
                            Animation(opacity=(0 if boolean else 1), duration=duration).start(self)

                            if boolean:
                                Clock.schedule_once(disable, duration + 0.1)

                        else:
                            disable()

                    def check_anim(self, value):
                        animate = (self.name_value or value)
                        if self.parent:
                            panel = self.parent.parent.parent.parent
                            animate = animate and (panel.unq_hash['before'] != panel.unq_hash['after'])
                        self.disable(not bool(value), animate)

                    def __setattr__(self, attr, value):
                        super().__setattr__(attr, value)

                        # Change attributes dynamically based on rule
                        if attr == "text" and value:
                            # Update text
                            self.label.text = value.strip()

                            # Update font size
                            self.label.font_size = sp(22 - (0 if len(self.label.text) < 11 else (len(self.label.text) // 3)))

                            # Update icon
                            def update_source(*a):
                                source = constants.get_player_head(value.strip())
                                def main_thread(*b):
                                    self.icon.source = source
                                Clock.schedule_once(main_thread, 0)
                            threading.Timer(0, update_source).start()


                        if attr == "text":
                            # self.check_anim(value)
                            self.disable(not bool(value), False)
                            self.name_value = value

                        if attr == "color" and value:
                            self.color_values = [(value[0], value[1], value[2], 0.75), value]
                            self.button.background_color = self.color_values[0]
                            label_color = Color(*self.color_values[1])
                            label_color.v -= 0.68
                            label_color.s += 0.05
                            self.label.color = label_color.rgba

                    def __init__(self, **kwargs):
                        super().__init__(**kwargs)

                        size = (215, 45)
                        name = 'player_label'
                        position = (0.5, 0.5)
                        self.name_value = None
                        self.color_values = [(0.8, 0.8, 0.8, 0), (1, 1, 1, 0)]

                        self.id = name
                        self.size_hint_max = size
                        self.size_hint_min = size

                        self.button = self.PlayerButton()
                        self.button.id = 'player_button'
                        self.button.border = (20, 20, 20, 20)
                        self.button.size_hint_max = size
                        self.button.size_hint_min = size
                        self.button.background_normal = os.path.join(constants.gui_assets, f'{self.button.id}.png')
                        self.button.background_down = os.path.join(constants.gui_assets, f'{self.button.id}.png')

                        self.label = AlignLabel()
                        self.label.__translate__ = False
                        self.label.halign = 'left'
                        self.label.valign = 'center'
                        self.label.id = 'label'
                        self.label.size_hint_max = size
                        self.label.pos_hint = {"center_x": position[0] + 0.18, "center_y": position[1] - 0.02}
                        self.label.text = name.upper()
                        self.label.font_size = sp(22)
                        self.label.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["bold"]}.ttf')
                        self.label.color = dark_accent
                        def on_touch_down(touch, *a):
                            super(Label, self.label).on_touch_down(touch)
                        self.label.on_touch_down = on_touch_down

                        # Button click behavior
                        def click_func(*a):
                            if not self.button.ignore_hover and self.label.text and self.button.last_touch.button == 'left':
                                if constants.server_manager.current_server.acl:
                                    constants.server_manager.current_server.acl.get_rule(re.sub("\[.*?\]", "", self.label.text))
                                    constants.back_clicked = True
                                    screen_manager.current = 'ServerAclScreen'
                                    constants.back_clicked = False
                        def hover(enter=True, *a):
                            Animation.stop_all(self.button)
                            Animation.stop_all(self.hicon)
                            Animation(opacity=(0.25 if enter else 0), duration=0.12).start(self.hicon)
                            Animation(background_color=self.color_values[1 if enter else 0], duration=0.12).start(self.button)
                        self.button.bind(on_press=click_func)
                        self.button.on_enter = functools.partial(hover, True)
                        self.button.on_leave = functools.partial(hover, False)
                        self.add_widget(self.button)

                        self.picon = Image()
                        self.picon.id = 'icon_placeholder'
                        self.picon.size_hint_max_y = size[1]
                        self.picon.pos_hint = {'center_x': 0.09}
                        self.picon.source = os.path.join(constants.gui_assets, 'steve.png')
                        self.add_widget(self.picon)

                        self.icon = AsyncImage()
                        self.icon.anim_delay = constants.anim_speed * 0.02
                        self.icon.id = 'icon'
                        self.icon.nocache = False
                        self.icon.size_hint_max_y = size[1]
                        self.icon.pos_hint = {'center_x': 0.09}
                        self.icon.source = os.path.join(constants.gui_assets, 'steve.png')
                        self.add_widget(self.icon)

                        self.hicon = Image()
                        self.hicon.id = 'icon_highlight'
                        self.hicon.size_hint_max_y = size[1]
                        self.hicon.pos_hint = {'center_x': 0.09}
                        self.hicon.source = os.path.join(constants.gui_assets, 'head_highlight.png')
                        self.hicon.opacity = 0
                        self.add_widget(self.hicon)

                        self.add_widget(self.label)

                self.background = PanelFrame()
                self.add_widget(self.background)

                self.current_players = None
                self.padding = 10


                # List layout
                self.layout = RelativeLayout()
                self.layout.opacity = 0
                self.layout_bg = Image(source=os.path.join(constants.gui_assets, 'performance_panel_background.png'))
                self.layout_bg.allow_stretch = True
                self.layout_bg.keep_ratio = False
                self.layout_bg.color = constants.brighten_color(constants.convert_color("#232439")['rgb'], -0.015)
                self.layout.add_widget(self.layout_bg)


                # Player layout
                self.scroll_layout = RecycleViewWidget(position=None, view_class=PlayerLabel)
                self.scroll_layout.always_overscroll = False
                self.scroll_layout.scroll_wheel_distance = dp(50)
                self.player_list = RecycleGridLayout(size_hint_y=None, default_size=(240, 50), padding=[self.padding, 3, self.padding, -20], spacing=[0, 8])
                self.player_list.bind(minimum_height=self.player_list.setter('height'))
                self.scroll_layout.add_widget(self.player_list)
                self.layout.add_widget(self.scroll_layout)
                self.add_widget(self.layout)


                # List shadow
                self.layout_shadow = Image(source=os.path.join(constants.gui_assets, 'performance_panel_shadow.png'))
                self.layout_shadow.allow_stretch = True
                self.layout_shadow.keep_ratio = False
                self.layout.add_widget(self.layout_shadow)


                # Player title
                self.title = ShadowLabel(
                    text = f'connected players',
                    font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["italic"]),
                    size = sp(23),
                    color = normal_accent,
                    offset = 3,
                    align = 'center',
                    shadow_color = constants.brighten_color(dark_accent, 0.04)
                )
                self.title.pos_hint = {'center_x': 0.5}
                self.title.y = 170
                self.add_widget(self.title)


                # Empty label
                self.empty_label = ShadowLabel(
                    text = f'*crickets*',
                    font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["italic"]),
                    size = sp(24),
                    color = gray_accent,
                    offset = 3,
                    align = 'center',
                    shadow_color = (0, 0, 0, 0)
                )
                self.empty_label.pos_hint = {'center_x': 0.5}
                self.empty_label.y = 95
                self.add_widget(self.empty_label)

                Clock.schedule_once(self.recalculate_size, 0)


        self.title_text = "Paragraph"
        self.size_hint = (None, None)
        self.size_hint_max = (None, None)
        self.pos_hint = {"center_x": 0.5}


        # Add widgets to layouts

        # Overview widget
        self.overview_widget = OverviewWidget(overview_min=self.overview_min)
        self.add_widget(self.overview_widget)

        # Player widget
        self.player_widget = PlayerWidget()
        self.add_widget(self.player_widget)

        # Meter widgets
        self.meter_layout = RelativeLayout(size_hint_max_x=self.meter_min)
        self.cpu_meter = MeterWidget(meter_name='CPU', pos_hint={'center_y': 0.684}, meter_min=self.meter_min)
        self.ram_meter = MeterWidget(meter_name='RAM', pos_hint={'center_y': 0.316}, meter_min=self.meter_min)
        self.meter_layout.add_widget(self.ram_meter)
        self.meter_layout.add_widget(self.cpu_meter)
        self.add_widget(self.meter_layout)


        self.bind(pos=self.update_rect)
        self.bind(size=self.update_rect)
        Clock.schedule_once(self.update_rect, 0)

class ConsolePanel(FloatLayout):

    # Update process to communicate with
    def update_process(self, run_data, *args):

        self.run_data = run_data

        # Close panel if telepath server closed immediately
        server_obj = constants.server_manager.current_server

        if server_obj._telepath_data:
            def check_for_crash(*a):
                data = server_obj._sync_telepath_stop(reset=False)
                if data['crash']:
                    server_obj.crash_log = data['crash']
                    self.update_text(data['log'])
                    self.reset_panel(data['crash'])

                    # Before closing, save contents to temp for view screen
                    constants.folder_check(constants.tempDir)
                    file_name = f"{server_obj._telepath_data['display-name']}, {server_obj.name}-latest.log"
                    with open(os.path.join(constants.tempDir, file_name), 'w+') as f:
                        f.write(json.dumps(data['log']))
            Clock.schedule_once(check_for_crash, 1)


        try:
            if self.update_text not in self.run_data['process-hooks']:
                self.run_data['process-hooks'].append(self.update_text)

            if self.reset_panel not in self.run_data['close-hooks']:
                self.run_data['close-hooks'].append(self.reset_panel)

            self.update_text(self.run_data['log'])

            def update_scroll(*args):
                if (self.console_text.height > self.scroll_layout.height - self.console_text.padding[-1]):
                    self.scroll_layout.scroll_y = 0
            Clock.schedule_once(update_scroll, 0)

        except KeyError:
            pass


    # Updates RecycleView text with console text
    def update_text(self, text, force_scroll=False, animate_last=True, *args):
        current_filter = self.filter_menu.current_filter
        self._unfiltered_text = text

        # Filterrrr oh yeah
        if current_filter != 'everything':
            event_whitelist = ['INIT', 'START', 'STOP', 'SUCCESS']

            if current_filter == 'errors':
                event_whitelist.extend(['WARN', 'ERROR', 'CRITICAL', 'SEVERE', 'FATAL'])

            elif current_filter == 'players':
                event_whitelist.extend(['CHAT', 'PLAYER'])

            elif current_filter == 'amscript':
                event_whitelist.extend(['AMS', 'EXEC'])

            text = [l for l in text if l['text'][1] in event_whitelist]



        original_scroll = self.scroll_layout.scroll_y
        original_len = len(self.scroll_layout.data)
        label_height = 41.8
        self.scroll_layout.data = text


        # Make the console sticky if scrolled to the bottom of the viewport
        viewport_size = self.scroll_layout.height - self.console_text.padding[-1] - self.console_text.padding[1]
        if (len(self.scroll_layout.data) * label_height > viewport_size) and ((original_scroll == 0 or not self.auto_scroll) or force_scroll):
            self.scroll_layout.scroll_y = 0
            self.auto_scroll = True


        # Temporary fix to prevent console text from moving when new data is added
        else:

            delta = self.scroll_layout.convert_distance_to_scroll(0, ((len(self.scroll_layout.data) * label_height) * (1 - self.scroll_layout.scroll_y)) - ((original_len * label_height) * (1 - original_scroll)))[1]
            if delta:
                final_scroll = self.scroll_layout.scroll_y + delta

                if final_scroll > 1:
                    final_scroll = 1
                elif final_scroll < 0:
                    final_scroll = 0

                self.scroll_layout.scroll_y = final_scroll

        def fade_animation(*args):
            for label in self.console_text.children:
                Animation.stop_all(label.anim_cover)
                Animation.stop_all(label.main_label)
                label.main_label.opacity = 1
                label.anim_cover.opacity = 0
                try:
                    if label.original_text == self.scroll_layout.data[-1]['text']:
                        label.main_label.opacity = 0
                        label.anim_cover.opacity = 1
                        Animation(opacity=1, duration=0.3).start(label.main_label)
                        Animation(opacity=0, duration=0.3).start(label.anim_cover)
                except:
                    pass
        if len(text) > original_len and animate_last:
            Clock.schedule_once(fade_animation, -1)


        # Update selection coordinates if they exist
        if self.last_self_touch:
            lst = self.last_self_touch
            self.last_self_touch = (lst[0], lst[1] + ((len(self.scroll_layout.data) - original_len) * label_height))


    # Fit background color across screen for transitions, and fix position
    def update_size(self, *args):
        self.rect.pos = self.pos
        self.rect.size = self.size

        self.scroll_layout.height = self.height - self.input.height
        self.scroll_layout.width = self.width
        self.scroll_layout.x = self.x
        self.scroll_layout.y = self.y + self.input.height

        self.console_text.width = self.width

        self.input.pos = (self.x, self.y)

        self.gradient.pos = (self.input.pos[0], self.pos[1] + (self.input.height * 1.2))
        self.gradient.width = self.scroll_layout.width - self.scroll_layout.bar_width
        self.gradient.height = 0-(self.input.height*0.5)

        self.input_background.pos = (self.pos[0] - 22, self.pos[1] + 8)


        # Corner resize
        offset = self.corner_size
        self.corner_mask.size_hint_max = (self.size[0] - offset, self.size[1] - offset)
        self.corner_mask.pos = (self.x + (offset/2), self.y + (offset/2))
        self.corner_mask.sl.size_hint_max_y = self.height - (self.corner_size*2)
        self.corner_mask.sr.size_hint_max_y = self.height - (self.corner_size*2)
        self.corner_mask.sb.size_hint_max_x = self.width - (self.corner_size*2)
        self.corner_mask.st.size_hint_max_x = self.width - (self.corner_size*2)


        # Console panel resize:
        texture = self.controls.background.texture_size
        self.controls.background.size_hint_max = (texture[0] + (self.height - texture[1]) + 200, texture[1] + (self.height - texture[1]))
        if self.full_screen == "animate":
            pass
        elif self.full_screen:
            self.size_hint_max = (Window.width, Window.height - self.full_screen_offset)
            self.y = 47
        else:
            self.size_hint_max = (Window.width - self.size_offset[0], Window.height - self.size_offset[1])
            self.y = self.default_y

        self.stop_click.size = self.size
        self.stop_click.pos = self.pos

        # Console controls resize
        self.controls.size = self.size
        self.controls.pos = self.pos

        shadow_size = self.controls.control_shadow.size
        self.controls.control_shadow.pos = (self.width - shadow_size[0], self.height - shadow_size[1])

        # Control buttons
        if self.controls.maximize_button and self.controls.stop_button and self.controls.restart_button and not self.full_screen:
            self.controls.view_button.pos = (self.width - 142, self.height - 80) if self.log_view else (self.width - 90, self.height - 80)
            self.controls.maximize_button.pos = (self.width - 90, self.height - 80)
            self.controls.stop_button.pos = (self.width - 142, self.height - 80)
            self.controls.restart_button.pos = (self.width - 194, self.height - 80)
            self.controls.filter_button.pos = (self.width - 246, self.height - 80)

        # Fullscreen shadow
        self.fullscreen_shadow.y = self.height + self.x - 3 + 25
        self.fullscreen_shadow.width = Window.width

        # Controls background
        def resize_background(*args):
            self.controls.background_ext.x = self.controls.background.width
            self.controls.background_ext.size_hint_max_x = self.width - self.controls.background.width
        Clock.schedule_once(resize_background, 0)


    # Launch server and update properties
    def launch_server(self, animate=True, wait_for_ip=True, *args):
        self.update_size()
        self.toggle_deadlock(False)
        self.selected_labels = []

        for k in self.parent._ignore_keys:
            if k == 'f':
                self.parent._ignore_keys.remove(k)

        anim_speed = 0.15 if animate else 0
        self.scroll_layout.scroll_y = 1
        self.auto_scroll = False

        # Animate panel
        self.controls.launch_button.disabled = True
        self.controls.log_button.disabled = True
        constants.hide_widget(self.controls.maximize_button, False)
        constants.hide_widget(self.controls.stop_button, False)
        constants.hide_widget(self.controls.restart_button, False)
        constants.hide_widget(self.controls.filter_button, False)
        self.controls.maximize_button.opacity = 0
        self.controls.stop_button.opacity = 0
        self.controls.restart_button.opacity = 0
        self.controls.filter_button.opacity = 0

        self.controls.crash_text.clear_text()

        if self.controls.view_button:
            Animation(opacity=0, duration=anim_speed).start(self.controls.view_button)
        Animation(opacity=0, duration=anim_speed).start(self.controls.button_shadow)
        Animation(opacity=0, duration=anim_speed).start(self.controls.background)
        Animation(opacity=0, duration=anim_speed).start(self.controls.background_ext)
        Animation(opacity=0, duration=(anim_speed*1.5) if animate else 0).start(self.controls.launch_button)
        Animation(opacity=0, duration=(anim_speed*1.5) if animate else 0).start(self.controls.log_button)

        def after_anim(*a):
            self.controls.maximize_button.disabled = False
            self.controls.stop_button.disabled = False
            self.controls.restart_button.disabled = False
            self.controls.filter_button.disabled = False
            self.controls.remove_widget(self.controls.launch_button)
            self.controls.remove_widget(self.controls.log_button)
            self.controls.remove_widget(self.controls.view_button)
            self.controls.launch_button.button.on_leave()
            self.controls.log_button.button.on_leave()
            self.controls.view_button.button.on_leave()
            def delay(function, obj, delay):
                def anim_delay(*a):
                    function.start(obj)
                Clock.schedule_once(anim_delay, delay)
            delay(Animation(opacity=1, duration=(anim_speed*2.7) if animate else 0, transition='in_out_sine'), self.controls.filter_button, 0.18)
            delay(Animation(opacity=1, duration=(anim_speed*2.7) if animate else 0, transition='in_out_sine'), self.controls.restart_button, 0.12)
            delay(Animation(opacity=1, duration=(anim_speed*2.7) if animate else 0, transition='in_out_sine'), self.controls.stop_button, 0.06)
            Animation(opacity=1, duration=(anim_speed*2.7) if animate else 0, transition='in_out_sine').start(self.controls.maximize_button)

        # Update IP info at the top of the ServerViewScreen
        def update_launch_data(*args):
            if self.server_button:
                self.server_button.update_subtitle(self.run_data)
        Clock.schedule_once(update_launch_data, 3 if wait_for_ip else 1)
        if wait_for_ip:
            for x in range(5):
                Clock.schedule_once(update_launch_data, x*5)

        # Show telepath banner when server is started remotely
        server_obj = constants.server_manager.current_server
        if wait_for_ip and server_obj._telepath_data:
            constants.api_manager.request(
                endpoint='/main/telepath_banner',
                host=server_obj._telepath_data['host'],
                port=server_obj._telepath_data['port'],
                args={'message': f"$Telepath$ action: Launched '${server_obj.name}$'", 'finished': True}
            )

        Clock.schedule_once(after_anim, (anim_speed*1.51) if animate else 0)

        # Actually launch server
        def start_timer(*_):
            server_obj = screen_manager.current_screen.server

            if server_obj._telepath_data:
                boot_text = f"Connecting to '{server_obj._view_name}', please wait..."
            else:
                boot_text = f"Launching '{server_obj.name}', please wait..."

            text_list = [{'text': (dt.now().strftime(constants.fmt_date("%#I:%M:%S %p")).rjust(11), 'INIT', boot_text, (0.7,0.7,0.7,1))}]

            if server_obj.proxy_enabled and server_obj.proxy_installed() and not constants.playit.initialized:
                text_list.append({'text': (dt.now().strftime(constants.fmt_date("%#I:%M:%S %p")).rjust(11), 'INFO', 'Initializing playit agent...', (0.6,0.6,1,1))})

            self.update_text(text=text_list)
            while not server_obj.addon or not server_obj.backup or not server_obj.script_manager or not server_obj.acl:
                time.sleep(0.05)

            self.update_process(screen_manager.current_screen.server.launch())

            # Start performance counter
            try:
                screen_manager.current_screen.set_timer(True)
            except AttributeError:
                pass

            self.input.disabled = False
            constants.server_manager.current_server.run_data['console-panel'] = self
            constants.server_manager.current_server.run_data['performance-panel'] = self.performance_panel

            # Update Discord rich presence
            constants.discord_presence.update_presence('Server Manager > Launch')

        threading.Timer(0, start_timer).start()


        # Show pop-up to ask user for initial user feedback
        try:
            if constants.app_config.prompt_feedback and constants.app_online:
                constants.app_config.prompt_feedback = False

                def open_feedback(*a):
                    url = "https://www.auto-mcs.com/feedback"
                    webbrowser.open_new_tab(url)

                Clock.schedule_once(
                    functools.partial(
                        screen_manager.current_screen.show_popup,
                        "query",
                        "Share Your Feedback",
                        "Thanks for using $auto-mcs$!\n\nWhile your server is launching, please take a moment to leave us your feedback",
                        (None, threading.Timer(0, open_feedback).start)
                    ),
                    1
                )
        except:
            pass


    # Stop server
    def stop_server(self, *args):
        if self.run_data:
            screen_manager.current_screen.server.stop()

        # Show deadlocked icon after stopping
        Clock.schedule_once(self.toggle_deadlock, 1)


    # Kills running process forcefully
    def kill_server(self, *args):
        if self.run_data:
            screen_manager.current_screen.server.kill()


    # Restart server
    def restart_server(self, *args):
        if self.run_data and not self.deadlocked:
            screen_manager.current_screen.server.restart()
            self.toggle_deadlock(False)


    # Called from ServerObject when process stops
    def reset_panel(self, crash=None):
        if self.server_obj.restart_flag:
            return


        def reset(*args):
            server_obj = constants.server_manager.current_server

            # Show crash banner if not on server screen
            def show_crash_banner(*args):
                if crash:
                    Clock.schedule_once(
                        functools.partial(
                            screen_manager.current_screen.show_banner,
                            (1, 0.5, 0.65, 1),
                            f"'${self.server_name}$' has crashed",
                            "close-circle-sharp.png",
                            2.5,
                            {"center_x": 0.5, "center_y": 0.965}
                        ), 0
                    )

            # Ignore if screen isn't visible or a different server
            if not (screen_manager.current_screen.name == 'ServerViewScreen'):
                show_crash_banner()

                # Update caption on list if user is staring at it for some reason
                if (screen_manager.current_screen.name == 'ServerManagerScreen'):
                    for button in screen_manager.current_screen.scroll_layout.children:
                        button = button.children[0]
                        if button.title.text.strip() == self.server_name:
                            button.update_subtitle(None, dt.now())
                            break
                return

            if screen_manager.current_screen.server.name != self.server_name or not self.run_data:
                show_crash_banner()
                return


            # Do things when on server launch screen
            screen_manager.current_screen.set_timer(False)
            screen_manager.current_screen.performance_panel.reset_panel()
            try:
                if 'f' not in self.parent._ignore_keys:
                    self.parent._ignore_keys.append('f')

            # Return if parent is None-type (screen does not exist)
            except AttributeError:
                return


            # Before deleting run data, save log to a file
            if not server_obj._telepath_data:
                constants.folder_check(constants.tempDir)
                file_name = f"{server_obj.name}-latest.log"
                with open(os.path.join(constants.tempDir, file_name), 'w+') as f:
                    f.write(json.dumps(self.run_data['log']))


            self.run_data = None
            self.ignore_keypress = True

            if self.parent.server_button:
                self.parent.server_button.update_subtitle(self.run_data, dt.now())


            # Else, reset it back to normal
            def disable_buttons(*a):
                constants.hide_widget(self.controls.maximize_button, True)
                constants.hide_widget(self.controls.stop_button, True)
                constants.hide_widget(self.controls.restart_button, True)
                constants.hide_widget(self.controls.filter_button, True)
                self.controls.control_shadow.opacity = 0


            if self.full_screen:
                self.maximize(False)
                disable_buttons()


            def after_anim(*a):
                anim_speed = 0.15

                # Update crash widgets
                if crash:
                    self.controls.log_button.disabled = False
                    self.controls.log_button.opacity = 0
                    self.controls.add_widget(self.controls.log_button)
                    Animation(opacity=1, duration=anim_speed).start(self.controls.log_button)
                    self.controls.crash_text.update_text(f"Uh oh, '${self.server_name}$' has crashed", False)


                # Animate panel
                self.controls.launch_button.disabled = False
                self.input.disabled = True
                self.input.text = ''

                self.controls.launch_button.opacity = 0
                self.controls.add_widget(self.controls.launch_button)

                Animation(opacity=1, duration=anim_speed).start(self.controls.button_shadow)
                Animation(opacity=1, duration=anim_speed).start(self.controls.launch_button)
                Animation(opacity=1, duration=anim_speed).start(self.controls.background)
                Animation(opacity=1, duration=anim_speed).start(self.controls.background_ext)

                if self.controls.maximize_button.opacity > 0:
                    Animation(opacity=0, duration=anim_speed).start(self.controls.maximize_button)
                    Animation(opacity=0, duration=anim_speed).start(self.controls.stop_button)
                    Animation(opacity=0, duration=anim_speed).start(self.controls.restart_button)
                    Animation(opacity=0, duration=anim_speed).start(self.controls.filter_button)
                    Clock.schedule_once(disable_buttons, anim_speed*1.1)

                def after_anim2(*a):
                    self.toggle_deadlock(False)
                    self.controls.maximize_button.disabled = False
                    self.controls.stop_button.disabled = False
                    self.controls.restart_button.disabled = False
                    self.controls.filter_button.disabled = False
                    self.scroll_layout.data = []
                    self.controls.control_shadow.opacity = 1

                    # View log button
                    self.add_log_button()

                    # Update Discord rich presence
                    constants.discord_presence.update_presence('Server Manager > Launch')

                Clock.schedule_once(after_anim2, (anim_speed * 1.51))

            Clock.schedule_once(after_anim, 1.5)

        Clock.schedule_once(reset, 0)

        # Prompt new server to enable automatic backups and updates
        if not crash and (self.server_obj.auto_update == 'prompt' or self.server_obj.backup._backup_stats['auto-backup'] == 'prompt'):
            Clock.schedule_once(functools.partial(prompt_new_server, self.server_obj))


    # Toggles full screen on the console
    def maximize(self, maximize=True, *args):

        # Make sure the buttons exist
        if 'f' in self.parent._ignore_keys and maximize and not self.log_view or self.full_screen == 'animate':
            return

        try:
            test = self.controls.maximize_button.button.hovered
        except AttributeError:
            return

        anim_speed = 0.135
        self.full_screen = "animate"

        # Fix scrolling
        def fix_scroll(*a):
            if (self.console_text.height > self.scroll_layout.height):
                Animation(scroll_y=0, duration=anim_speed, transition='out_sine').start(self.scroll_layout)
            else:
                Animation(scroll_y=1, duration=anim_speed, transition='out_sine').start(self.scroll_layout)


        # Entering full screen
        if maximize:
            Animation(size_hint_max=(Window.width, Window.height - self.full_screen_offset), y=47, duration=anim_speed, transition='out_sine').start(self)

            # If server is not running
            if self.log_view:

                # Hide log button
                self.controls.remove_widget(self.controls.view_button)
                del self.controls.view_button
                self.controls.view_button = IconButton('hide log', {}, (71, 150), (None, None), 'hide-log.png', clickable=True, anchor='right', force_color=self.button_colors['maximize'], click_func=self.hide_log)
                self.controls.view_button.opacity = 0
                self.controls.add_widget(self.controls.view_button)

                # Filter button
                self.controls.remove_widget(self.controls.filter_button)
                del self.controls.filter_button
                self.controls.filter_button = IconButton('filter', {}, (123, 150), (None, None), 'filter-sharp.png', clickable=True, anchor='right', text_offset=(9, 50), force_color=self.button_colors['filter'], click_func=self.filter_menu.show, text_hover_color=(0.722, 0.722, 1, 1))
                self.controls.filter_button.opacity = 0
                self.controls.add_widget(self.controls.filter_button)

                def after_anim(*a):
                    self.full_screen = True
                    self.ignore_keypress = False
                    Animation(opacity=0, duration=(anim_speed * 0.1), transition='out_sine').start(self.corner_mask)
                    Animation(opacity=1, duration=(anim_speed * 0.1), transition='out_sine').start(self.fullscreen_shadow)
                    Animation(opacity=1, duration=anim_speed, transition='out_sine').start(self.controls.view_button)
                    Animation(opacity=1, duration=anim_speed, transition='out_sine').start(self.controls.filter_button)

                Clock.schedule_once(after_anim, (anim_speed * 1.1))


            # If server is running
            else:

                # Full screen button
                self.controls.remove_widget(self.controls.maximize_button)
                del self.controls.maximize_button
                self.controls.maximize_button = IconButton('minimize', {}, (71, 150), (None, None), 'minimize.png', clickable=True, anchor='right', force_color=self.button_colors['maximize'], click_func=functools.partial(self.maximize, False))
                self.controls.maximize_button.opacity = 0
                self.controls.add_widget(self.controls.maximize_button)

                # Stop server button
                self.controls.remove_widget(self.controls.stop_button)
                del self.controls.stop_button
                if not self.deadlocked:
                    self.controls.stop_button = IconButton('stop server', {}, (123, 150), (None, None), 'stop-server.png', clickable=True, anchor='right', text_offset=(13, 50), force_color=self.button_colors['stop'], click_func=self.stop_server, text_hover_color=(0.85, 0.7, 1, 1))
                else:
                    self.controls.stop_button = IconButton('kill server', {}, (123, 150), (None, None), 'kill-server.png', clickable=True, anchor='right', text_offset=(13, 50), force_color=self.button_colors['stop'], click_func=self.kill_server, text_hover_color=(0.85, 0.7, 1, 1))
                self.controls.stop_button.opacity = 0
                self.controls.add_widget(self.controls.stop_button)

                # Restart server button
                self.controls.remove_widget(self.controls.restart_button)
                del self.controls.restart_button
                self.controls.restart_button = IconButton('restart server', {}, (175, 150), (None, None), 'restart-server.png', clickable=True, anchor='right', text_offset=(-25, 50), force_color=self.button_colors['stop'], click_func=self.restart_server, text_hover_color=(0.85, 0.7, 1, 1))
                self.controls.restart_button.opacity = 0
                self.controls.add_widget(self.controls.restart_button)

                # Filter button
                self.controls.remove_widget(self.controls.filter_button)
                del self.controls.filter_button
                self.controls.filter_button = IconButton('filter', {}, (227, 150), (None, None), 'filter-sharp.png', clickable=True, anchor='right', text_offset=(9, 50), force_color=self.button_colors['filter'], click_func=self.filter_menu.show, text_hover_color=(0.722, 0.722, 1, 1))
                self.controls.filter_button.opacity = 0
                self.controls.add_widget(self.controls.filter_button)

                def after_anim(*a):
                    self.full_screen = True
                    self.ignore_keypress = False
                    Animation(opacity=0, duration=(anim_speed*0.1), transition='out_sine').start(self.corner_mask)
                    Animation(opacity=1, duration=(anim_speed * 0.1), transition='out_sine').start(self.fullscreen_shadow)
                    Animation(opacity=1, duration=anim_speed, transition='out_sine').start(self.controls.maximize_button)
                    Animation(opacity=1, duration=anim_speed, transition='out_sine').start(self.controls.stop_button)
                    Animation(opacity=1, duration=anim_speed, transition='out_sine').start(self.controls.restart_button)
                    Animation(opacity=1, duration=anim_speed, transition='out_sine').start(self.controls.filter_button)
                    fix_scroll()

                Clock.schedule_once(after_anim, (anim_speed*1.1))


        # Exiting full screen
        else:
            Animation(size_hint_max=(Window.width - self.size_offset[0], Window.height - self.size_offset[1]), y=self.default_y, duration=anim_speed, transition='out_sine').start(self)
            Animation(opacity=1, duration=(anim_speed*0.1), transition='out_sine').start(self.corner_mask)
            Animation(opacity=0, duration=(anim_speed*0.1), transition='out_sine').start(self.fullscreen_shadow)

            # Full screen button
            self.controls.remove_widget(self.controls.maximize_button)
            del self.controls.maximize_button
            self.controls.maximize_button = RelativeIconButton('maximize', {}, (20, 20), (None, None), 'maximize.png', clickable=True, anchor='right', text_offset=(24, 80), force_color=self.button_colors['maximize'], click_func=functools.partial(self.maximize, True))
            self.controls.maximize_button.opacity = 0
            self.controls.add_widget(self.controls.maximize_button)

            # Stop server button
            self.controls.remove_widget(self.controls.stop_button)
            del self.controls.stop_button
            if not self.deadlocked:
                self.controls.stop_button = RelativeIconButton('stop server', {}, (20, 20), (None, None), 'stop-server.png', clickable=True, anchor='right', text_offset=(8, 80), force_color=self.button_colors['stop'], click_func=self.stop_server, text_hover_color=(0.85, 0.7, 1, 1))
            else:
                self.controls.stop_button = RelativeIconButton('kill server', {}, (20, 20), (None, None), 'kill-server.png', clickable=True, anchor='right', text_offset=(8, 80), force_color=self.button_colors['stop'], click_func=self.kill_server, text_hover_color=(0.85, 0.7, 1, 1))
            self.controls.stop_button.opacity = 0
            self.controls.add_widget(self.controls.stop_button)

            # Restart server button
            self.controls.remove_widget(self.controls.restart_button)
            del self.controls.restart_button
            self.controls.restart_button = RelativeIconButton('restart server', {}, (20, 20), (None, None), 'restart-server.png', clickable=True, anchor='right', text_offset=(-30, 80), force_color=self.button_colors['stop'], click_func=self.restart_server, text_hover_color=(0.85, 0.7, 1, 1))
            self.controls.restart_button.opacity = 0
            self.controls.add_widget(self.controls.restart_button)

            # Filter button
            self.controls.remove_widget(self.controls.filter_button)
            del self.controls.filter_button
            self.controls.filter_button = RelativeIconButton('filter', {}, (20, 20), (None, None), 'filter-sharp.png', clickable=True, anchor='right', text_offset=(3, 80), force_color=self.button_colors['filter'], click_func=self.filter_menu.show, text_hover_color=(0.722, 0.722, 1, 1))
            self.controls.filter_button.opacity = 0
            self.controls.add_widget(self.controls.filter_button)

            if not self.run_data:
                constants.hide_widget(self.controls.maximize_button, True)
                constants.hide_widget(self.controls.stop_button, True)
                constants.hide_widget(self.controls.restart_button, True)
                constants.hide_widget(self.controls.filter_button, True)

            def after_anim(*a):
                self.full_screen = False
                self.ignore_keypress = False
                if self.run_data:
                    self.update_size()
                    Animation(opacity=1, duration=anim_speed, transition='out_sine').start(self.controls.maximize_button)
                    Animation(opacity=1, duration=anim_speed, transition='out_sine').start(self.controls.stop_button)
                    Animation(opacity=1, duration=anim_speed, transition='out_sine').start(self.controls.restart_button)
                    Animation(opacity=1, duration=anim_speed, transition='out_sine').start(self.controls.filter_button)
                fix_scroll()

            Clock.schedule_once(after_anim, (anim_speed*1.1))


    # Toggles deadlock button visibility
    def toggle_deadlock(self, boolean=True):
        def main_thread(*a):
            self.deadlocked = boolean
            if boolean:
                self.controls.stop_button.change_data('kill-server.png', 'kill server', self.kill_server)
            else:
                self.controls.stop_button.change_data('stop-server.png', 'stop server', self.stop_server)
        Clock.schedule_once(main_thread, 0)


    # Opens crash log in auto-mcs logviewer
    def open_log(self, *args):
        server_obj = constants.server_manager.current_server
        title = None

        if server_obj._telepath_data:
            title = f'{server_obj._view_name}'

        view_file(server_obj.crash_log, title)
        self.controls.log_button.button.on_leave()
        self.controls.log_button.button.on_release()


    # Adds show/hide log button
    def add_log_button(self, *args):
        self.log_view = False
        self.input.hint_text = "enter command..."

        # Choose path based on server name
        server_obj = constants.server_manager.current_server
        if server_obj._telepath_data:
            log_name = f"{server_obj._telepath_data['display-name']}, {server_obj.name}-latest.log"
        else:
            log_name = f"{server_obj.name}-latest.log"

        # Before deleting run data, save log to a file
        constants.folder_check(constants.tempDir)
        file_path = os.path.join(constants.tempDir, log_name)
        if os.path.isfile(file_path):
            self.deselect_all()
            self.scroll_layout.data = []
            def change_later(*a):
                try:
                    with open(file_path, 'r') as f:
                        self._unfiltered_text = json.loads(f.read())
                        self.update_text(self._unfiltered_text)
                except:
                    if constants.debug:
                        print('Failed to load "latest.log"')
            Clock.schedule_once(change_later, 0)

            self.controls.remove_widget(self.controls.view_button)
            del self.controls.view_button
            self.controls.view_button = RelativeIconButton('view log', {}, (20, 20), (None, None), 'view-log.png', clickable=True, anchor='right', text_offset=(18, 80), force_color=self.button_colors['maximize'], click_func=self.show_log)
            self.controls.add_widget(self.controls.view_button)
            self.controls.view_button.opacity = 0
            Animation(opacity=1, duration=0.15).start(self.controls.view_button)
            self.update_size()


    # Shows previous console log in panel
    def show_log(self, *args):

        if self.run_data:
            return


        self.log_view = True

        self.controls.control_shadow.opacity = 0
        self.input.hint_text = "viewing last run..."
        self.controls.control_shadow.size_hint_max = (135, 120)
        self.selected_labels = []
        anim_speed = 0.15
        self.scroll_layout.scroll_y = 0
        self.auto_scroll = False

        Animation(opacity=0, duration=anim_speed).start(self.controls.view_button)
        Animation(opacity=0, duration=anim_speed).start(self.controls.crash_text)
        Animation(opacity=0, duration=anim_speed).start(self.controls.button_shadow)
        Animation(opacity=0, duration=anim_speed).start(self.controls.background)
        Animation(opacity=0, duration=anim_speed).start(self.controls.background_ext)
        Animation(opacity=0, duration=(anim_speed * 1.5)).start(self.controls.launch_button)
        Animation(opacity=0, duration=(anim_speed * 1.5)).start(self.controls.log_button)

        def after_anim(*a):
            self.controls.maximize_button.disabled = False
            self.controls.remove_widget(self.controls.launch_button)
            self.controls.remove_widget(self.controls.log_button)
            self.controls.launch_button.button.on_leave()
            self.controls.log_button.button.on_leave()
            Animation(opacity=1, duration=anim_speed).start(self.controls.control_shadow)

        Clock.schedule_once(after_anim, (anim_speed * 1.51))
        Clock.schedule_once(functools.partial(self.maximize, True), 0.2)


    # Hides previous console log in panel
    def hide_log(self, *args):

        self.selected_labels = []

        def after_anim(*a):
            anim_speed = 0.15

            # Update crash widgets
            if self.controls.crash_text.text.text.strip():
                self.controls.log_button.disabled = False
                self.controls.log_button.opacity = 0
                self.controls.add_widget(self.controls.log_button)
                Animation(opacity=1, duration=anim_speed).start(self.controls.log_button)
                Animation(opacity=1, duration=anim_speed).start(self.controls.crash_text)

            # Animate panel
            self.controls.launch_button.disabled = False
            self.input.disabled = True
            self.input.text = ''

            self.controls.launch_button.opacity = 0
            self.controls.add_widget(self.controls.launch_button)

            Animation(opacity=1, duration=anim_speed).start(self.controls.button_shadow)
            Animation(opacity=1, duration=anim_speed).start(self.controls.launch_button)
            Animation(opacity=1, duration=anim_speed).start(self.controls.background)
            Animation(opacity=1, duration=anim_speed).start(self.controls.background_ext)

            Clock.schedule_once(functools.partial(self.maximize, False), 0)

            if self.controls.view_button.opacity > 0:
                constants.hide_widget(self.controls.view_button, True)

            def after_anim2(*a):
                self.controls.view_button.disabled = False
                self.scroll_layout.data = []

                # View log button
                self.controls.control_shadow.size_hint_max = (255, 120)
                Clock.schedule_once(self.update_size, -1)
                self.add_log_button()

            Clock.schedule_once(after_anim2, (anim_speed * 1.51))

        Clock.schedule_once(after_anim, 0)


    # Select all ConsoleLabels
    def select_all(self):
        self.selected_labels = [x['text'] for x in self.scroll_layout.data]
        for label in self.console_text.children:
            Animation.stop_all(label.sel_cover)
            label.sel_cover.opacity = 0.2
        Clock.schedule_once(self.scroll_layout.refresh_from_layout, 0)


    # Deselect all selected ConsoleLabels
    def deselect_all(self):
        self.selected_labels = []
        for label in self.console_text.children:
            Animation.stop_all(label.sel_cover)
            Animation(opacity=0, duration=0.05).start(label.sel_cover)
        Clock.schedule_once(self.scroll_layout.refresh_from_layout, 0.1)


    # Format and copy all selected text to clipboard
    def copy_selection(self):
        if self.selected_labels:
            text = '\n'.join([str(x[0].rjust(11) + ('['+x[1]+']').rjust(9) + ' >   '+x[2]) for x in self.selected_labels])

            # Remove formatting from text
            if '[/color]' in text:
                text = re.sub(r'\[\/?color(=#\w+)?\]', '', text)
            if 'Â§' in text:
                for code in constants.color_table.keys():
                    text = text.replace(code, '')
            Clipboard.copy(text)
            self.selected_labels = []

        # Animate to convey copying
        for label in self.console_text.children:
            if label.sel_cover.opacity > 0:
                Animation.stop_all(label.sel_cover)
                label.sel_cover.opacity = 0.4
                Animation(opacity=0, duration=0.2).start(label.sel_cover)
        Clock.schedule_once(self.scroll_layout.refresh_from_layout, 0.41)

    # Check for drag select
    def on_touch_down(self, touch):
        if touch.device == "wm_touch":
            touch.button = "left"


        # Copy when right-clicked
        if self.selected_labels and touch.button == "right":
            self.copy_selection()
            return True

        # Select code for a single ConsoleLabel is under "SelectCover.on_touch_down()"
        try:
            if touch.button == "left":
                self.last_self_touch = self.console_text.to_widget(*touch.pos)

        # Ignore invalid inputs from non-standard input devices
        except AttributeError:
            pass

        return super().on_touch_down(touch)


    # Check for drag select
    def on_touch_up(self, touch):
        self.last_self_touch = None
        return super().on_touch_up(touch)


    # Automatically scroll console_text when mouse is dragged on the top or bottom regions
    def scroll_region(self, top=True, last_touch=None):
        if not self.in_scroll_region:
            self.in_scroll_region = True
            scroll_padding = 50
            try:
                scroll_speed = (self.scroll_layout.height / len(self.scroll_layout.data)) / 1800
            except ZeroDivisionError:
                scroll_speed = 100
            last_touch.pos = self.to_widget(*Window.mouse_pos)

            if top:
                while (Window.mouse_pos[1] >= self.scroll_layout.y + (self.scroll_layout.height - scroll_padding)) and self.last_self_touch:
                    def scroll_up(*a):
                        self.scroll_layout.scroll_y += scroll_speed

                    if self.scroll_layout.scroll_y < 1:
                        Clock.schedule_once(scroll_up, 0)
                        Clock.schedule_once(functools.partial(self.on_touch_move, last_touch), 0)
                    else:
                        self.scroll_layout.scroll_y = 1
                        break
                    time.sleep(0.01)

            else:
                while (self.scroll_layout.y + (scroll_padding * 2) >= Window.mouse_pos[1] >= self.scroll_layout.y) and self.last_self_touch:
                    def scroll_down(*a):
                        self.scroll_layout.scroll_y -= scroll_speed

                    if self.scroll_layout.scroll_y > 0:
                        Clock.schedule_once(scroll_down, 0)
                        Clock.schedule_once(functools.partial(self.on_touch_move, last_touch), 0)
                    else:
                        self.scroll_layout.scroll_y = 0
                        break
                    time.sleep(0.01)

            self.in_scroll_region = False


    def on_touch_move(self, touch, *a):

        # Move the scrollbar when near the top or bottom to select more than the viewport
        scroll_padding = 50
        if (touch.dsy > 0) and (touch.pos[1] >= self.scroll_layout.y + (self.scroll_layout.height - scroll_padding)):
            threading.Timer(0, functools.partial(self.scroll_region, True, touch)).start()

        if (touch.dsy < 0) and (self.scroll_layout.y + (scroll_padding * 2) >= touch.pos[1] >= self.scroll_layout.y):
            threading.Timer(0, functools.partial(self.scroll_region, False, touch)).start()

        def is_between(y3):
            y1 = self.console_text.height - self.last_self_touch[1]
            y2 = self.console_text.height - self.console_text.to_widget(*touch.pos)[1]
            y3 = self.console_text.height - self.console_text.to_widget(*self.scroll_layout.to_parent(0, y3))[1] - 25
            return ((y1 <= y3 <= y2) or (y2 <= y3 <= y1)) and not (touch.pos[0] > self.scroll_layout.x + (self.scroll_layout.width - self.scroll_layout.drag_pad))

        for widget in self.console_text.children:
            try:
                if is_between(widget.y) and widget.original_text not in self.selected_labels:

                    # Use Y delta to orient clipboard content
                    if touch.dsy > 0:
                        self.selected_labels.insert(0, widget.original_text)
                    else:
                        self.selected_labels.append(widget.original_text)
                    widget.sel_cover.opacity = 0.2

                elif (not is_between(widget.y)) and widget.original_text in self.selected_labels:
                    self.selected_labels.remove(widget.original_text)
                    widget.sel_cover.opacity = 0
            except:
                pass
        return super().on_touch_move(touch)


    def __init__(self, server_name, server_button=None, start_launched=False, performance_panel: PerformancePanel = None, **kwargs):
        super().__init__(**kwargs)

        self.performance_panel = performance_panel

        self.server_name = server_name
        self.server_obj = None
        self.run_data = None
        self.server_button = server_button
        self.deadlocked = False
        self.log_view = False
        self.full_screen = False
        self.full_screen_offset = 95
        self.size_offset = (70, 550)
        self.ignore_keypress = False
        self.pos_hint = {"center_x": 0.5}
        self.default_y = 170
        self.y = self.default_y

        # Selection info
        self.selected_labels = []
        self.last_touch = None
        self.last_self_touch = None
        self.in_scroll_region = False

        self._unfiltered_text = []

        self.button_colors = {
            'maximize': [[(0.05, 0.08, 0.07, 1), (0.722, 0.722, 1, 1)], ''],
            'filter': [[(0.05, 0.08, 0.07, 1), (0.251, 0.251, 0.451, 1)], ''],
            'stop': [[(0.05, 0.08, 0.07, 1), (0.722, 0.722, 1, 1)], 'pink']
        }


        # Stop clicks through the background
        class StopClick(FloatLayout):
            def on_touch_down(self, touch):
                if self.collide_point(*touch.pos):
                    return True
                else:
                    super().on_touch_down(touch)

        self.stop_click = StopClick()
        self.add_widget(self.stop_click)


        # Console line Viewclass for RecycleView
        class ConsoleLabel(RelativeLayout):

            def __setattr__(self, attr, value):
                # Change attributes dynamically based on rule
                if attr == "text" and value:
                    self.original_text = value
                    self.change_properties(value)

                super().__setattr__(attr, value)

            # Modifies rule attributes based on text content
            def change_properties(self, text):

                if not self.console_panel and constants.server_manager.current_server.run_data:
                    try:
                        self.console_panel = constants.server_manager.current_server.run_data['console-panel']
                    except KeyError:
                        pass

                if text and screen_manager.current_screen.name == 'ServerViewScreen':

                    if not self.console_panel and not constants.server_manager.current_server.run_data:
                        try:
                            self.console_panel = screen_manager.current_screen.console_panel
                        except:
                            pass

                    self.date_label.text = text[0]
                    self.type_label.text = text[1]
                    self.main_label.text = text[2]
                    type_color = text[3]

                    # Log text section formatting
                    width = screen_manager.current_screen.console_panel.console_text.width
                    self.width = width
                    self.main_label.width = width - (self.section_size * 2) - 3
                    self.main_label.text_size = (width - (self.section_size * 2) - 3, None)
                    try:
                        self.main_label.texture_update()
                    except:
                        self.date_label.text = kivy.utils.escape_markup(text[0])
                        self.type_label.text = kivy.utils.escape_markup(text[1])
                        self.main_label.text = kivy.utils.escape_markup(text[2])
                        self.main_label.texture_update()
                    self.main_label.size = self.main_label.texture_size
                    self.main_label.size_hint_max_x = width - (self.section_size * 2) - 3
                    self.size_hint_max_x = width

                    # This is an extremely dirty and stinky fix for setting position and height
                    self.main_label.x = (width / 2) - 50 + (self.section_size) - 3

                    # def update_grid(*args):
                    #     self.main_label.texture_update()
                    #     self.size[1] = self.main_label.texture_size[1] + self.line_spacing
                    #
                    # Clock.schedule_once(update_grid, 0)


                    # Type & date label stuffies
                    self.date_label.x = 8
                    self.type_label.x = self.date_label.x + self.section_size - 6
                    self.type_banner.x = self.type_label.x - 7

                    if type_color:
                        self.main_label.color = type_color
                        self.date_label.color = self.type_label.color = constants.brighten_color(type_color, -0.65)
                        self.date_banner1.color = self.date_banner2.color = constants.brighten_color(type_color, -0.2)
                        self.type_banner.color = type_color

                        # Format selection color
                        if self.console_panel:
                            self.sel_cover.opacity = 0.2 if text in self.console_panel.selected_labels else 0
                        self.sel_cover.color = constants.brighten_color(type_color, 0.05)
                        self.sel_cover.width = self.width


            def __init__(self, **kwargs):
                super().__init__(**kwargs)
                self.original_text = None
                self.console_panel = None
                self.line_spacing = 20
                self.font_size = sp(17)
                self.section_size = 110


                # Main text
                self.main_label = Label()
                self.main_label.__translate__ = False
                self.main_label.markup = True
                self.main_label.shorten = True
                self.main_label.shorten_from = 'right'
                self.main_label.font_size = sp(20)
                self.main_label.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["mono-bold"]}.otf')
                self.main_label.halign = 'left'
                self.add_widget(self.main_label)


                # Type label/banner
                self.type_banner = Image()
                self.type_banner.source = os.path.join(constants.gui_assets, 'console_banner.png')
                self.type_banner.allow_stretch = True
                self.type_banner.keep_ratio = False
                self.add_widget(self.type_banner)

                self.type_label = Label()
                self.type_label.__translate__ = False
                self.type_label.font_size = self.font_size
                self.type_label.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["mono-bold"]}.otf')
                self.add_widget(self.type_label)


                # Date label/banner
                self.date_banner1 = Image()
                self.date_banner1.source = os.path.join(constants.gui_assets, 'console_banner.png')
                self.date_banner1.allow_stretch = True
                self.date_banner1.keep_ratio = False
                self.add_widget(self.date_banner1)
                self.date_banner2 = Image()
                self.date_banner2.source = os.path.join(constants.gui_assets, 'console_banner.png')
                self.date_banner2.allow_stretch = True
                self.date_banner2.keep_ratio = False
                self.date_banner2.x = 27
                self.add_widget(self.date_banner2)

                self.date_label = Label()
                self.date_label.__translate__ = False
                self.date_label.font_size = self.font_size
                self.date_label.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["mono-medium"]}.otf')
                self.date_label.halign = 'left'
                self.add_widget(self.date_label)


                # Select cover for text selection
                class SelectCover(Image):

                    def on_touch_down(self, touch):
                        if self.collide_point(*touch.pos) and touch.button == 'left':
                            if self.parent:
                                for widget in self.parent.parent.children:
                                    widget.sel_cover.opacity = 0
                                try:
                                    if (self.parent.original_text in self.parent.console_panel.selected_labels) and (len(self.parent.console_panel.selected_labels) == 1):
                                        self.parent.console_panel.deselect_all()
                                    else:
                                        self.parent.console_panel.last_touch = touch.pos
                                        self.parent.console_panel.selected_labels = [self.parent.original_text]
                                        self.opacity = 0.2
                                        Clock.schedule_once(self.parent.console_panel.scroll_layout.refresh_from_layout, 0)
                                except:
                                    pass
                        else:
                            self.opacity = 0
                            return super().on_touch_down(touch)

                self.sel_cover = SelectCover()
                self.sel_cover.opacity = 0
                self.sel_cover.allow_stretch = True
                self.sel_cover.size_hint = (None, None)
                self.sel_cover.height = 42
                self.add_widget(self.sel_cover)


                # Cover for fade animation
                self.anim_cover = Image()
                self.anim_cover.opacity = 0
                self.anim_cover.allow_stretch = True
                self.anim_cover.size_hint = (None, None)
                self.anim_cover.width = self.section_size * 1.9
                self.anim_cover.height = self.section_size / 2.65
                self.anim_cover.color = background_color
                self.add_widget(self.anim_cover)

        # Command input at the bottom
        class ConsoleInput(TextInput):

            def _on_focus(self, instance, value, *largs):

                # Log for crash info
                if value:
                    try:
                        interaction = f"ConsoleInput (Sub-server {list(constants.server_manager.running_servers.keys()).index(self.parent.server_name)+1})"
                        constants.last_widget = interaction + f" @ {constants.format_now()}"
                    except:
                        pass

                # Update screen focus value on next frame
                def update_focus(*args):
                    screen_manager.current_screen._input_focused = self.focus

                Clock.schedule_once(update_focus, 0)

                super(ConsoleInput, self)._on_focus(instance, value)
                Animation.stop_all(self.parent.input_background)
                Animation(opacity=0.9 if self.focus else 0.35, duration=0.2, step=0).start(self.parent.input_background)

            def __init__(self, **kwargs):
                super().__init__(**kwargs)

                self.original_text = ''
                self.history_index = 0

                self.multiline = False
                self.halign = "left"
                self.hint_text = "enter command..."

                self.hint_text_color = (0.6, 0.6, 1, 0.4)
                self.foreground_color = (0.6, 0.6, 1, 1)
                self.background_color = (0, 0, 0, 0)
                self.disabled_foreground_color = (0.6, 0.6, 1, 0.4)
                self.cursor_color = (0.55, 0.55, 1, 1)
                self.selection_color = (0.5, 0.5, 1, 0.4)

                self.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["mono-bold"]}.otf')
                self.font_size = sp(22)
                self.padding_y = (12, 12)
                self.padding_x = (70, 12)
                self.cursor_width = dp(3)

                self.bind(on_text_validate=self.on_enter)

            def tab_player(self, *a):
                player_list = [k for k, v in self.parent.server_obj.get_players().items() if v['logged-in']]

                if self.text.strip():
                    key = self.text.split(" ")[-1].lower()
                    if key not in player_list:
                        for player in player_list:
                            if self.text.endswith(" "):
                                self.text = self.text.strip() + " " + player
                                break

                            elif player.lower().startswith(key):
                                self.text = self.text[:-len(key)] + player
                                break

            def grab_focus(self, *a):
                def focus_later(*args):
                    self.focus = True

                Clock.schedule_once(focus_later, 0)

            def on_enter(self, value):

                # Move this to a proper send_command() function in svrmgr
                if self.parent.run_data:
                    self.parent.run_data['send-command'](self.text)
                    self.parent.update_text(self.parent.run_data['log'], force_scroll=True)

                self.original_text = ''
                self.history_index = 0

                self.text = ''
                self.grab_focus()

            # Input validation
            def insert_text(self, substring, from_undo=False):
                if screen_manager.current_screen.popup_widget:
                    return None

                if not self.text and substring in [' ', '/']:
                    substring = ""

                if substring == "\t":
                    substring = ""

                else:
                    s = substring.replace("Â§", "[_color_]").encode("ascii", "ignore").decode().replace("\n","").replace("\r","").replace("[_color_]", "Â§")
                    self.original_text = self.text + s
                    self.history_index = 0
                    return super().insert_text(s, from_undo=from_undo)

            # Manipulate command history
            def keyboard_on_key_down(self, window, keycode, text, modifiers):

                if self.parent.run_data:

                    if keycode[1] == "backspace" and control in modifiers:
                        original_index = self.cursor_col
                        new_text, index = constants.control_backspace(self.text, original_index)
                        self.select_text(original_index - index, original_index)
                        self.delete_selection()
                    else:
                        super().keyboard_on_key_down(window, keycode, text, modifiers)

                    if keycode[1] == "tab":
                        self.tab_player()

                    if keycode[1] == 'up' and self.parent.run_data['command-history']:
                        if self.text != self.original_text:
                            self.history_index += 1
                        if self.history_index > len(self.parent.run_data['command-history']) - 1:
                            self.history_index = len(self.parent.run_data['command-history']) - 1
                            if self.history_index < 0:
                                self.history_index = 0
                        self.text = self.parent.run_data['command-history'][self.history_index]


                    elif keycode[1] == 'down' and self.parent.run_data['command-history']:
                        self.history_index -= 1
                        if self.history_index < 0:
                            self.history_index = 0
                            self.text = self.original_text
                        else:
                            self.text = self.parent.run_data['command-history'][self.history_index]

        # Controls and background for console panel
        class ConsoleControls(RelativeLayout):
            def __init__(self, panel, **kwargs):
                super().__init__(**kwargs)
                self.panel = panel

                # Blurred background image
                self.background = Image()
                self.background.allow_stretch = True
                self.background.keep_ratio = False
                self.background.source = os.path.join(constants.gui_assets, f'console_preview_{randrange(3)}.png')
                self.background_ext = Image(size_hint_max=(None, None))
                self.add_widget(self.background_ext)
                self.add_widget(self.background)

                # Button shadow
                self.button_shadow = Image(pos_hint={'center_x': 0.5, 'center_y': 0.5})
                self.button_shadow.allow_stretch = True
                self.button_shadow.keep_ratio = False
                self.button_shadow.size_hint_max = (580, 250)
                self.button_shadow.source = os.path.join(constants.gui_assets, 'banner_shadow.png')
                self.add_widget(self.button_shadow)

                # Launch button
                self.launch_button = color_button("LAUNCH", position=(0.5, 0.5), icon_name='play-circle-sharp.png', click_func=self.panel.launch_server, hover_data={'color': (0.05, 0.05, 0.1, 1), 'image': os.path.join(constants.gui_assets, 'launch-button-hover.png')})
                self.launch_button.disabled = False
                self.add_widget(self.launch_button)

                # Open log button
                self.log_button = color_button("VIEW CRASH LOG", position=(0.5, 0.22), icon_name='document-text-outline-sharp.png', click_func=self.panel.open_log, color=(1,0.65,0.75,1))
                self.log_button.disabled = False
                if constants.server_manager.current_server.crash_log:
                    self.add_widget(self.log_button)

                # Crash text
                self.crash_text = InputLabel(pos_hint={'center_y': 0.78})
                self.crash_text.text.text = ''
                self.add_widget(self.crash_text)
                if constants.server_manager.current_server.crash_log:
                    self.crash_text.update_text(f"Uh oh, '${self.panel.server_name}$' has crashed", False)


                # Button shadow in the top right
                self.control_shadow = Image()
                self.control_shadow.allow_stretch = True
                self.control_shadow.keep_ratio = False
                self.control_shadow.color = background_color
                self.control_shadow.source = os.path.join(constants.gui_assets, 'console_control_shadow.png')
                self.control_shadow.size_hint_max = (280, 120)
                self.add_widget(self.control_shadow)

                # Full screen button
                self.maximize_button = RelativeIconButton('maximize', {}, (20, 20), (None, None), 'maximize.png', clickable=True, anchor='right', text_offset=(24, 80), force_color=self.panel.button_colors['maximize'], click_func=functools.partial(self.panel.maximize, True))
                constants.hide_widget(self.maximize_button)
                self.add_widget(self.maximize_button)

                # Stop server button
                self.stop_button = RelativeIconButton('stop server', {}, (20, 20), (None, None), 'stop-server.png', clickable=True, anchor='right', text_offset=(8, 80), force_color=self.panel.button_colors['stop'], click_func=self.panel.stop_server, text_hover_color=(0.85, 0.7, 1, 1))
                constants.hide_widget(self.stop_button)
                self.add_widget(self.stop_button)

                # Restart server button
                self.restart_button = RelativeIconButton('restart server', {}, (20, 20), (None, None), 'restart-server.png', clickable=True, anchor='right', text_offset=(-30, 80), force_color=self.panel.button_colors['stop'], click_func=self.panel.restart_server, text_hover_color=(0.85, 0.7, 1, 1))
                constants.hide_widget(self.restart_button)
                self.add_widget(self.restart_button)

                # Filter button
                self.filter_button = RelativeIconButton('filter', {}, (20, 20), (None, None), 'filter-sharp.png', clickable=True, anchor='right', text_offset=(3, 80), force_color=self.panel.button_colors['filter'], click_func=self.panel.filter_menu.show, text_hover_color=(0.722, 0.722, 1, 1))
                constants.hide_widget(self.filter_button)
                self.add_widget(self.filter_button)

                # View log button
                self.view_button = RelativeIconButton('view log', {}, (20, 20), (None, None), 'view-log.png', clickable=True, anchor='right', text_offset=(18, 80), force_color=self.panel.button_colors['maximize'], click_func=functools.partial(self.panel.show_log, True))
                Clock.schedule_once(self.panel.add_log_button, 0)

        # Scrollable list for configuring console event filtering
        class FilterMenu(ContextMenu):
            def __init__(self, panel, **kwargs):
                super().__init__(**kwargs)
                self.panel = panel
                self.change_filter(constants.server_manager.current_server.console_filter)

            def change_filter(self, filter_type):
                if not filter_type:
                    filter_type = 'everything'

                self.current_filter = filter_type
                constants.server_manager.current_server.change_filter(filter_type)
                filter_button = None

                if self.panel.run_data or self.panel.log_view:
                    self.panel.update_text(self.panel._unfiltered_text)
                    filter_button = self.panel.controls.filter_button

                # Change filter icon colors
                filter_color = [[(0.05, 0.08, 0.07, 1), (0.6, 0.6, 1, 1)], '']
                default_color = [[(0.05, 0.08, 0.07, 1), (0.251, 0.251, 0.451, 1)], '']

                if filter_type == 'everything':
                    self.panel.button_colors['filter'] = default_color
                    if filter_button:
                        filter_button.button.color_id = default_color[0]
                        filter_button.button.on_leave()
                else:
                    self.panel.button_colors['filter'] = filter_color
                    if filter_button:
                        filter_button.button.color_id = filter_color[0]
                        filter_button.button.on_leave()

            def _change_options(self, options_list):
                self.options_list = options_list
                self.clear_widgets()

                for item in self.options_list:
                    if not item:
                        continue

                    selected = self.current_filter in item['name']

                    # Start of the list
                    if item == self.options_list[0]:
                        start_btn = self.ListButton(item, sub_id='list_start_button', selected=selected)
                        self.add_widget(start_btn)

                    # Middle of the list
                    elif item != self.options_list[-1]:
                        mid_btn = self.ListButton(item, sub_id='list_mid_button', selected=selected)
                        self.add_widget(mid_btn)

                    # Last button
                    else:
                        if 'color' in item:
                            sub_id = f'list_{item["color"]}_button'
                        else:
                            sub_id = 'list_end_button'
                        end_btn = self.ListButton(item, sub_id=sub_id, selected=selected)
                        self.add_widget(end_btn)

            def _update_pos(self):

                # Set initial position
                pos = (self.panel.x + self.panel.width - 220, self.panel.controls.y + self.panel.controls.height - 58)
                self.x = pos[0]
                self.y = pos[1] - self.height
                Clock.schedule_once(self._round_top_left, 0)

            def show(self):
                filters = [
                    {'name': 'everything', 'icon': 'reader.png', 'action': lambda *_: self.change_filter('everything')},
                    {'name': 'only errors', 'icon': 'warning.png', 'action': lambda *_: self.change_filter('errors')},
                    {'name': 'only players', 'icon': 'person.png', 'action': lambda *_: self.change_filter('players')},
                    {'name': 'amscript', 'icon': 'amscript.png', 'action': lambda *_: self.change_filter('amscript')}
                ]
                super().show(widget=self.panel.controls.filter_button.button, options_list=filters)

            def hide(self, animate=True, *args):
                Clock.schedule_once(self.widget.on_leave, 0.05)

                if animate:
                    Animation(opacity=0, size_hint_max_x=150, duration=0.13, transition='in_out_sine').start(self)
                    for b in self.children:
                        b.animate(False)
                    Clock.schedule_once(functools.partial(self._deselect_buttons), 0.14)
                    Clock.schedule_once(lambda *_: self.clear_widgets(), 0.141)
                else:
                    self.clear_widgets()

        # Event filter
        self.filter_menu = FilterMenu(self)


        # Popen object reference
        self.scale = 1
        self.auto_scroll = False

        background_color = constants.brighten_color(constants.background_color, -0.1)

        # Background
        with self.canvas.before:
            self.color = Color(*background_color, mode='rgba')
            self.rect = Rectangle(pos=self.pos, size=self.size)

        with self.canvas.after:
            self.canvas.clear()


        # Text Layout
        self.scroll_layout = RecycleViewWidget(position=None, view_class=ConsoleLabel)
        self.scroll_layout.always_overscroll = False
        self.scroll_layout.scroll_wheel_distance = dp(50)
        self.console_text = RecycleGridLayout(size_hint_y=None, cols=1, default_size=(100, 42), padding=[0, 3, 0, 30])
        self.console_text.bind(minimum_height=self.console_text.setter('height'))
        self.scroll_layout.add_widget(self.console_text)
        self.scroll_layout.scroll_type = ['bars']
        self.add_widget(self.scroll_layout)


        # Log gradient
        self.gradient = Image()
        self.gradient.allow_stretch = True
        self.gradient.keep_ratio = False
        self.gradient.size_hint = (None, None)
        self.gradient.color = background_color
        self.gradient.opacity = 0.65
        self.gradient.source = os.path.join(constants.gui_assets, 'scroll_gradient.png')
        self.add_widget(self.gradient)


        # Command input
        self.input = ConsoleInput(size_hint_max_y=50)
        self.input.disabled = True
        self.add_widget(self.input)

        # Input icon
        self.input_background = Image()
        self.input_background.default_opacity = 0.35
        self.input_background.color = self.input.foreground_color
        self.input_background.opacity = self.input_background.default_opacity
        self.input_background.allow_stretch = True
        self.input_background.size_hint = (None, None)
        self.input_background.height = self.input.size_hint_max_y / 1.45
        self.input_background.source = os.path.join(constants.gui_assets, 'console_input_banner.png')
        self.add_widget(self.input_background)


        # Fullscreen shadow
        self.fullscreen_shadow = Image()
        self.fullscreen_shadow.allow_stretch = True
        self.fullscreen_shadow.keep_ratio = False
        self.fullscreen_shadow.size_hint_max = (None, 25)
        self.fullscreen_shadow.color = background_color
        self.fullscreen_shadow.opacity = 0
        self.fullscreen_shadow.source = os.path.join(constants.gui_assets, 'control_fullscreen_gradient.png')
        self.add_widget(self.fullscreen_shadow)


        # Start server/blurred background layout
        self.controls = ConsoleControls(self)
        self.add_widget(self.controls)
        self.controls.background_ext.color = background_color


        # Rounded corner mask
        self.corner_size = 30
        class Corner(Image):
            def __init__(self, **kwargs):
                super().__init__(**kwargs)
                self.source = os.path.join(constants.gui_assets, 'console_border.png')
                self.color = constants.background_color
                self.allow_stretch = True
                self.keep_ratio = False

        class Side(Image):
            def __init__(self, vertical=True, **kwargs):
                super().__init__(**kwargs)
                self.source = os.path.join(constants.gui_assets, f'control_gradient_{"vertical" if vertical else "horizontal"}.png')
                self.allow_stretch = True
                self.keep_ratio = False

        self.corner_mask = RelativeLayout()
        self.corner_mask.tl = Corner(pos_hint={'center_x': 0, 'center_y': 1}, size_hint_max=(self.corner_size, self.corner_size))
        self.corner_mask.tr = Corner(pos_hint={'center_x': 1, 'center_y': 1}, size_hint_max=(-self.corner_size, self.corner_size))
        self.corner_mask.bl = Corner(pos_hint={'center_x': 0, 'center_y': 0}, size_hint_max=(self.corner_size, -self.corner_size))
        self.corner_mask.br = Corner(pos_hint={'center_x': 1, 'center_y': 0}, size_hint_max=(-self.corner_size, -self.corner_size))
        self.corner_mask.add_widget(self.corner_mask.tl)
        self.corner_mask.add_widget(self.corner_mask.tr)
        self.corner_mask.add_widget(self.corner_mask.bl)
        self.corner_mask.add_widget(self.corner_mask.br)

        self.corner_mask.sl = Side(pos_hint={'center_x': 0, 'center_y': 0.5}, size_hint_max=(self.corner_size, None), vertical=False)
        self.corner_mask.sr = Side(pos_hint={'center_x': 1, 'center_y': 0.5}, size_hint_max=(-self.corner_size, None), vertical=False)
        self.corner_mask.st = Side(pos_hint={'center_x': 0.5, 'center_y': 1}, size_hint_max=(None, self.corner_size))
        self.corner_mask.sb = Side(pos_hint={'center_x': 0.5, 'center_y': 0}, size_hint_max=(None, -self.corner_size))
        self.corner_mask.add_widget(self.corner_mask.sl)
        self.corner_mask.add_widget(self.corner_mask.sr)
        self.corner_mask.add_widget(self.corner_mask.st)
        self.corner_mask.add_widget(self.corner_mask.sb)

        self.add_widget(self.corner_mask)

        self.add_widget(self.filter_menu)


        self.bind(pos=self.update_size)
        self.bind(size=self.update_size)
        Clock.schedule_once(self.update_size, 0)

        if start_launched:
            Clock.schedule_once(functools.partial(self.launch_server, False, False), 0)

class ServerViewScreen(MenuBackground):

    # Fit background color across screen for transitions
    def update_rect(self, *args):

        # Hide context menu when screen is resized
        if self.context_menu:
            self.context_menu.hide(False)

        self.rect.pos = self.pos
        self.rect.size = self.size

        # Resize popup if it exists
        if self.popup_widget:
            self.popup_widget.resize()

        # Repos page switcher
        if self.page_switcher:
            self.page_switcher.resize_self()

        # Repos console panel and widgets
        if self.console_panel:
            Clock.schedule_once(self.console_panel.update_size, 0)
        if self.performance_panel:
            Clock.schedule_once(self.performance_panel.update_rect, 0)
        save_window_pos()

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.server = None
        self.performance_panel = None
        self.console_panel = None
        self.menu_taskbar = None
        self.server_button = None
        self.server_button_layout = None
        self.perf_timer = None

    def set_timer(self, start=True):
        if start:
            try:
                if 'launch-time' in self.server.run_data:
                    self.performance_panel.player_clock = 6
                    Clock.schedule_once(self.performance_panel.refresh_data, 0.5)
                    self.perf_timer = Clock.schedule_interval(self.performance_panel.refresh_data, 1)
            except AttributeError:
                pass
        else:
            if self.perf_timer:
                self.perf_timer.cancel()
            self.perf_timer = None

    def on_pre_leave(self, **kwargs):
        self.set_timer(False)
        super().on_pre_leave(**kwargs)

    def on_pre_enter(self, **kwargs):
        super().on_pre_enter(**kwargs)
        self.set_timer(True)

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        # print('The key', keycode, 'have been pressed')
        # print(' - text is %r' % text)
        # print(' - modifiers are %r' % modifiers)

        # Ignore key presses when popup is visible
        if self.popup_widget:

            # Override for PopupSearch
            if self.popup_widget.__class__.__name__ == 'PopupSearch':
                if keycode[1] == 'escape':
                    self.popup_widget.self_destruct(True)
                elif keycode[1] == 'backspace' or ('shift' in modifiers and text and not text.isalnum()):
                    self.popup_widget.resize_window()
                elif control not in modifiers and text and self.popup_widget.window_input.keyboard:

                    def insert_text(content):
                        col = self.popup_widget.window_input.cursor_col
                        start = self.popup_widget.window_input.text[:col]
                        end = self.popup_widget.window_input.text[col:]
                        self.popup_widget.window_input.text = start + content + end
                        for x in range(len(content)):
                            Clock.schedule_once(functools.partial(self.popup_widget.window_input.do_cursor_movement, 'cursor_right', True), 0)

                    new_str = self.popup_widget.window_input.keyboard.keycode_to_string(keycode[0])
                    if 'shift' in modifiers:
                        new_str = new_str.upper()
                    if len(new_str) == 1:
                        insert_text(new_str)
                    elif keycode[1] == 'spacebar':
                        insert_text(' ')
                    self.popup_widget.resize_window()
                else:
                    self.popup_widget.resize_window()
                return True

            if keycode[1] in ['escape', 'n']:
                try:
                    self.popup_widget.click_event(self.popup_widget, self.popup_widget.no_button)
                except AttributeError:
                    self.popup_widget.click_event(self.popup_widget, self.popup_widget.ok_button)

            elif keycode[1] in ['enter', 'return', 'y']:
                try:
                    self.popup_widget.click_event(self.popup_widget, self.popup_widget.yes_button)
                except AttributeError:
                    self.popup_widget.click_event(self.popup_widget, self.popup_widget.ok_button)
            return


        # Trigger for showing search bar
        elif keycode[1] == 'shift':
            if not self._shift_held:
                self._shift_held = True
                self._shift_press_count += 1

                if self._shift_timer:
                    self._shift_timer.cancel()

                # Check for double tap
                if self._shift_press_count == 2:
                    self.show_search()
                    self._shift_press_count = 0

                # Otherwise, reset the timer
                else:
                    self._shift_timer = Clock.schedule_once(self._reset_shift_counter, 0.25)  # Adjust time as needed
            return True


        # Ignore ESC commands while input focused
        if not self._input_focused and self.name == screen_manager.current_screen.name:

            # Keycode is composed of an integer + a string
            # If we hit escape, release the keyboard
            # On ESC, click on back button if it exists
            if keycode[1] == 'escape' and 'escape' not in self._ignore_keys:

                if self.context_menu:
                    self.context_menu.hide()

                elif self.console_panel.log_view:
                    self.console_panel.hide_log()

                elif self.console_panel.full_screen:
                    self.console_panel.maximize(False)

                else:
                    for button in self.walk():
                        try:
                            if button.id == "exit_button":
                                button.force_click()
                                break
                        except AttributeError:
                            continue
                keyboard.release()


            # Start server when enter is pressed
            if (keycode[1] == 'enter' and 'enter' not in self._ignore_keys) and not self.server.run_data:
                if not self.console_panel.log_view:
                    self.console_panel.controls.launch_button.button.on_enter()
                    Clock.schedule_once(self.console_panel.launch_server, 0.1)


            # Use 'F' to toggle fullscreen
            if keycode[1] == 'f' and 'f' not in self._ignore_keys and self.server.run_data:
                if not self.console_panel.log_view:
                    self.console_panel.maximize(not self.console_panel.full_screen)
                    self.console_panel.ignore_keypress = True


            # Focus text input if server is started
            if (keycode[1] == 'tab' and 'tab' not in self._ignore_keys) and self.server.run_data:
                self.console_panel.input.grab_focus()



        # Capture keypress on current screen no matter what
        if self.name == screen_manager.current_screen.name:

            # Copy selected console text
            if ((keycode[1] == 'c' and control in modifiers) and ('c' not in self._ignore_keys)) and (self.server.run_data or self.console_panel.log_view):
                self.console_panel.copy_selection()

            # Select all console text
            if ((keycode[1] == 'a' and control in modifiers) and ('a' not in self._ignore_keys)) and (self.server.run_data or self.console_panel.log_view):
                self.console_panel.select_all()

            # Deselect all console text
            if ((keycode[1] == 'd' and control in modifiers) and ('d' not in self._ignore_keys)) and (self.server.run_data or self.console_panel.log_view):
                self.console_panel.deselect_all()

            # Stop the server if it's currently running
            if ((keycode[1] == 'q' and control in modifiers) and ('q' not in self._ignore_keys)) and self.server.run_data:
                stop_button = self.console_panel.controls.stop_button
                if stop_button.opacity == 1:
                    stop_button.button.trigger_action(0.1)

            # Quit on macOS
            elif constants.os_name == 'macos' and (keycode[1] == 'q' and control in modifiers):
                if not main_app.exit_check():
                    exit_app()

            # Restart the server if it's currently running
            if ((keycode[1] == 'r' and (control in modifiers and 'shift' in modifiers)) and ('r' not in self._ignore_keys)) and self.server.run_data:
                restart_button = self.console_panel.controls.restart_button
                if restart_button.opacity == 1:
                    restart_button.button.trigger_action(0.1)



        # Return True to accept the key. Otherwise, it will be used by the system.
        return True


    def generate_menu(self, **kwargs):

        # If a new server is selected, animate the taskbar
        animate_taskbar = False
        try:
            if not self.server:
                animate_taskbar = True
            elif self.server.name != constants.server_manager.current_server.name:
                animate_taskbar = True
        except AttributeError:
            pass

        self.server = constants.server_manager.current_server

        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'

        # Check if updates are available
        update_banner = ""
        if self.server.auto_update == 'true':
            update_banner = self.server.update_string

        self.server_button = ServerButton(self.server, update_banner=update_banner, fade_in=0.3, view_only=True)
        grid_layout = GridLayout(cols=1, size_hint_max_x=None, padding=(0, 80, 0, 0))
        self.server_button_layout = ScrollItem()
        self.server_button_layout.add_widget(self.server_button)
        grid_layout.add_widget(self.server_button_layout)
        float_layout.add_widget(grid_layout)

        # Only add this off-screen for 'ESC' behavior
        buttons.append(ExitButton('Back', (0.5, -1), cycle=True))
        for button in buttons:
            float_layout.add_widget(button)

        float_layout.add_widget(generate_title(f"Server Manager: '{self.server.name}'"))
        float_layout.add_widget(generate_footer(f"{self.server.name}, Launch"))

        self.add_widget(float_layout)


        # Add ManuTaskbar
        self.menu_taskbar = MenuTaskbar(selected_item='launch', animate=animate_taskbar)
        self.add_widget(self.menu_taskbar)


        # Add performance panel
        perf_layout = ScrollItem()
        if self.server.run_data and 'performance-panel' in self.server.run_data and self.server.run_data['performance-panel']:
            self.performance_panel = self.server.run_data['performance-panel']
            try:
                if self.performance_panel.parent:
                    self.performance_panel.parent.remove_widget(self.performance_panel)
            except AttributeError:
                pass
        else:
            self.performance_panel = PerformancePanel(self.server.name)
        perf_layout.add_widget(self.performance_panel)
        self.add_widget(perf_layout)


        # Add ConsolePanel
        if self.server.run_data and 'console-panel' in self.server.run_data and 'log' in self.server.run_data and self.server.run_data['console-panel']:
            self.console_panel = self.server.run_data['console-panel']
            self.console_panel.scroll_layout.data = []
            Clock.schedule_once(functools.partial(self.console_panel.update_text, self.server.run_data['log'], True, False), 0)
        else:
            self.console_panel = ConsolePanel(self.server.name, self.server_button, start_launched=self.server.running, performance_panel=self.performance_panel)

        self.add_widget(self.console_panel)
        self.console_panel.server_obj = self.server



# Server Back-up Manager -----------------------------------------------------------------------------------------------

class ServerBackupScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'

        self.save_backup_button = None
        self.restore_backup_button = None
        self.open_path_button = None
        self.migrate_path_button = None
        self.download_button = None
        self.clone_button = None

        self.header = None
        self.menu_taskbar = None

    def solo_button(self, button_name, loading=True, *args):
        server_obj = constants.server_manager.current_server

        button_dict = {
            'save': self.save_backup_button,
            'restore': self.restore_backup_button,
            'migrate': self.migrate_path_button
        }

        for k, v in button_dict.items():
            # print(server_obj.backup._backup_stats['backup-list'])
            if k == 'restore' and not server_obj.backup._backup_stats['backup-list']:
                v.disable(True)
                if self.download_button:
                    self.download_button.disable(True)
                continue

            if k == 'migrate' and server_obj._telepath_data:
                continue

            if k == button_name:
                v.loading(True) if loading else v.loading(False)
            else:
                v.disable(True) if loading else v.disable(False)

    def generate_menu(self, **kwargs):
        server_obj = constants.server_manager.current_server

        # Return if no free space
        if disk_popup('ServerViewScreen', telepath_data=server_obj._telepath_data):
            return

        server_obj.backup._update_data()
        backup_stats = server_obj.backup._backup_stats
        very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["very-bold"])

        # Retain button persistence when disabled
        if server_obj.name in constants.backup_lock:
            Clock.schedule_once(functools.partial(self.solo_button, constants.backup_lock[server_obj.name], True), 0)
        else:
            Clock.schedule_once(functools.partial(self.solo_button, None, False), 0)


        # Scroll list
        scroll_widget = ScrollViewWidget(position=(0.5, 0.485))
        scroll_anchor = AnchorLayout()
        scroll_layout = GridLayout(cols=1, spacing=10, size_hint_max_x=1050, size_hint_y=None, padding=[0, 16, 0, 30])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 1.6
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1
            scroll_layout.spacing = 30 if grid_layout.cols == 2 else 10

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        scroll_layout.bind(minimum_height=scroll_layout.setter('height'))
        scroll_layout.id = 'scroll_content'

        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.8}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.17}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60))


        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'


        # Save back-up button
        def save_backup(*args):

            def run_backup(*args):

                # Run back-up
                Clock.schedule_once(functools.partial(self.solo_button, 'save', True), 0)
                server_obj.backup.save()

                # Update header
                def change_header(*args):
                    backup_stats = server_obj.backup._backup_stats
                    backup_count = len(backup_stats['backup-list'])
                    header_content = f"{constants.translate('Latest Back-up')}  [color=#494977]-[/color]  " + (f'[color=#6A6ABA]{constants.translate("Never")}[/color]' if not backup_stats['latest-backup'] else f'[font={very_bold_font}]{backup_stats["latest-backup"]}[/font]')
                    sub_header_content = f"{backup_count:,}  back-up" + ("" if backup_count == 1 else "s") + (f"   ({backup_stats['total-size']})" if backup_count > 0 else "")
                    self.header.text.text = header_content
                    self.header.lower_text.text = sub_header_content

                Clock.schedule_once(change_header, 0)

                # Show banner and update button
                Clock.schedule_once(functools.partial(self.solo_button, 'save', False), 0)

                Clock.schedule_once(
                    functools.partial(
                        self.show_banner,
                        (0.553, 0.902, 0.675, 1),
                        f"Backed up '${server_obj.name}$' successfully",
                        "checkmark-circle-sharp.png",
                        2.5,
                        {"center_x": 0.5, "center_y": 0.965}
                    ), 0
                )

            threading.Timer(0, run_backup).start()

        sub_layout = ScrollItem()
        self.save_backup_button = WaitButton('Save Back-up Now', (0.5, 0.5), 'save-sharp.png', click_func=save_backup)
        sub_layout.add_widget(self.save_backup_button)
        scroll_layout.add_widget(sub_layout)


        # Restore back-up button
        sub_layout = ScrollItem()
        self.restore_backup_button = WaitButton('Restore From Back-up', (0.5, 0.5), 'reload-sharp.png', disabled=server_obj.running)
        sub_layout.add_widget(self.restore_backup_button)
        scroll_layout.add_widget(sub_layout)


        # Auto-backup toggle
        start_value = False if str(backup_stats['auto-backup']) == 'prompt' else str(backup_stats['auto-backup']) == 'true'

        def toggle_auto(var):
            server_obj.backup.enable_auto_backup(var)

            Clock.schedule_once(
                functools.partial(
                    self.show_banner,
                    (0.553, 0.902, 0.675, 1) if var else (0.937, 0.831, 0.62, 1),
                    f"Automatic back-ups {'en' if var else 'dis'}abled",
                    "checkmark-circle-sharp.png" if var else "close-circle-sharp.png",
                    2,
                    {"center_x": 0.5, "center_y": 0.965}
                ), 0
            )

        sub_layout = ScrollItem()
        sub_layout.add_widget(blank_input(pos_hint={"center_x": 0.5, "center_y": 0.5}, hint_text="automatic back-ups"))
        sub_layout.add_widget(toggle_button('auto-backup', (0.5, 0.5), default_state=start_value, custom_func=toggle_auto))
        scroll_layout.add_widget(sub_layout)


        # Maximum back-up slider
        max_limit = 11
        start_value = max_limit if str(backup_stats['max-backup']) == 'unlimited' else int(backup_stats['max-backup'])

        def change_limit(val):
            server_obj.backup.set_amount('unlimited' if val == max_limit else val)

        sub_layout = ScrollItem()
        sub_layout.add_widget(blank_input(pos_hint={"center_x": 0.5, "center_y": 0.5}, hint_text="maximum back-ups"))
        sub_layout.add_widget(NumberSlider(start_value, (0.5, 0.5), input_name='BackupMaxInput', limits=(2, max_limit), max_icon='infinite-bold.png', function=change_limit))
        scroll_layout.add_widget(sub_layout)


        if server_obj._telepath_data:

            # Download a back-up
            def download_backup(*args):
                Clock.schedule_once(self.download_button.button.on_leave, 0.5)

            sub_layout = ScrollItem()
            self.download_button = WaitButton('Download a Back-up', (0.5, 0.5), 'cloud-download-sharp.png', click_func=download_backup)
            sub_layout.add_widget(self.download_button)
            scroll_layout.add_widget(sub_layout)


        # Only apply these buttons on a local server
        else:
            # Open back-up directory
            def open_backup_dir(*args):
                backup_stats = server_obj.backup._backup_stats
                constants.open_folder(backup_stats['backup-path'])
                Clock.schedule_once(self.open_path_button.button.on_leave, 0.5)

            self.open_path_button = IconButton('open directory', {}, (70, 110), (None, None), 'folder.png', anchor='right', click_func=open_backup_dir, text_offset=(10, 0))
            float_layout.add_widget(self.open_path_button)


            # Migrate back-up directory
            def change_backup_dir(*args):
                backup_stats = server_obj.backup._backup_stats
                current_path = backup_stats['backup-path']
                new_path = file_popup("dir", start_dir=(current_path if os.path.exists(current_path) else constants.backupFolder), input_name='migrate_backup_button', select_multiple=False, title="Select a New Back-up Directory")
                Clock.schedule_once(self.open_path_button.button.on_leave, 0.5)

                def run_migrate(*args):
                    Clock.schedule_once(functools.partial(self.solo_button, 'migrate', True), 0)
                    final_path = server_obj.backup.set_directory(new_path)

                    # Show banner and update button
                    Clock.schedule_once(functools.partial(self.solo_button, 'migrate', False), 0)

                    if final_path:
                        Clock.schedule_once(
                            functools.partial(
                                self.show_banner,
                                (0.553, 0.902, 0.675, 1),
                                "Migrated back-up directory successfully",
                                "checkmark-circle-sharp.png",
                                2.5,
                                {"center_x": 0.5, "center_y": 0.965}
                            ), 0
                        )
                    else:
                        Clock.schedule_once(
                            functools.partial(
                                self.show_banner,
                                (1, 0.53, 0.58, 1),
                                "Failed to migrate back-up directory",
                                "close-circle.png",
                                2.5,
                                {"center_x": 0.5, "center_y": 0.965}
                            ), 0
                        )


                # If path was selected, migrate folder
                if new_path:
                    threading.Timer(0, run_migrate).start()

            sub_layout = ScrollItem()
            self.migrate_path_button = WaitButton('Migrate Back-up Directory', (0.5, 0.5), 'migrate.png', click_func=change_backup_dir)
            sub_layout.add_widget(self.migrate_path_button)
            scroll_layout.add_widget(sub_layout)


        # Clone server button
        def clone_server(*args):
            screen_manager.current = 'ServerCloneScreen'

        sub_layout = ScrollItem()
        self.clone_button = WaitButton('Clone this server', (0.5, 0.5), 'duplicate-outline.png', click_func=clone_server)
        sub_layout.add_widget(self.clone_button)
        scroll_layout.add_widget(sub_layout)


        # Append scroll view items
        scroll_anchor.add_widget(scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)


        # Configure header
        # print(backup_stats)
        backup_count = len(backup_stats['backup-list'])
        header_content = f"{constants.translate('Latest Back-up')}  [color=#494977]-[/color]  " + (f'[color=#6A6ABA]{constants.translate("Never")}[/color]' if not backup_stats['latest-backup'] else f'[font={very_bold_font}]{backup_stats["latest-backup"]}[/font]')
        sub_header_content = f"{backup_count:,}  back-up" + ("" if backup_count == 1 else "s") + (f"   ({backup_stats['total-size']})" if backup_count > 0 else "")
        self.header = HeaderText(header_content, sub_header_content, (0, 0.89), __translate__ = (False, True))
        float_layout.add_widget(self.header)


        buttons.append(ExitButton('Back', (0.5, -1), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        float_layout.add_widget(generate_title(f"Back-up Manager: '{server_obj.name}'"))
        float_layout.add_widget(generate_footer(f"{server_obj.name}, Back-ups"))

        self.add_widget(float_layout)

        # Add ManuTaskbar
        self.menu_taskbar = MenuTaskbar(selected_item='back-ups')
        self.add_widget(self.menu_taskbar)

class BackupButton(HoverButton):

    def animate_button(self, image, color, **kwargs):
        image_animate = Animation(duration=0.05)

        def f(w):
            w.background_normal = image

        Animation(color=color, duration=0.06).start(self.title)
        Animation(color=color, duration=0.06).start(self.index_icon)
        Animation(color=color, duration=0.06).start(self.index_label)
        Animation(color=color, duration=0.06).start(self.subtitle)
        Animation(color=color, duration=0.06).start(self.type_image.image)
        if self.type_image.version_label.__class__.__name__ == "AlignLabel":
            Animation(color=color, duration=0.06).start(self.type_image.version_label)
        Animation(color=color, duration=0.06).start(self.type_image.type_label)

        a = Animation(duration=0.0)
        a.on_complete = functools.partial(f)

        image_animate += a

        image_animate.start(self)

    def resize_self(self, *args):

        # Title and description
        padding = 2.17
        self.title.pos = (self.x + (self.title.text_size[0] / padding) - (0) + 30, self.y + 31) # - (6)
        self.subtitle.pos = (self.x + (self.subtitle.text_size[0] / padding) - 1 + 30 - 100, self.y + 8)
        self.index_label.pos = (self.x - 19, self.y + 2.5)
        self.index_icon.pos = (self.x + 8, self.y + 18)

        offset = 9.45 if self.type_image.type_label.text in ["vanilla", "paper", "purpur"]\
            else 9.6 if self.type_image.type_label.text == "forge"\
            else 9.35 if self.type_image.type_label.text == "craftbukkit"\
            else 9.55


        self.type_image.image.x = self.width + self.x - (self.type_image.image.width) - 13
        self.type_image.image.y = self.y + ((self.height / 2) - (self.type_image.image.height / 2))

        self.type_image.type_label.x = self.width + self.x - (self.padding_x * offset) - self.type_image.width - 83
        self.type_image.type_label.y = self.y + (self.height * 0.05)

        # Update label
        if self.type_image.version_label.__class__.__name__ == "AlignLabel":
            self.type_image.version_label.x = self.width + self.x - (self.padding_x * offset) - self.type_image.width - 83
            self.type_image.version_label.y = self.y - (self.height / 3.2)

        # Banner version object
        else:
            self.type_image.version_label.x = self.width + self.x - (self.padding_x * offset) - self.type_image.width - 130
            self.type_image.version_label.y = self.y - (self.height / 3.2) - 2

    def __init__(self, backup_object, click_function=None, fade_in=0.0, index=0, **kwargs):
        super().__init__(**kwargs)

        self.properties = backup_object
        self.border = (-5, -5, -5, -5)
        self.color_id = [(0.05, 0.05, 0.1, 1), constants.brighten_color((0.65, 0.65, 1, 1), 0.07)]
        self.pos_hint = {"center_x": 0.5, "center_y": 0.6}
        self.size_hint_max = (580, 80)
        self.id = "server_button"
        self.index = index
        self.newest = (index == 1)

        self.background_normal = os.path.join(constants.gui_assets, f'{self.id}{"_ro" if self.newest else ""}.png')
        self.background_down = os.path.join(constants.gui_assets, f'{self.id}_click.png')

        # Loading stuffs
        self.original_subtitle = backup_object.date
        self.original_font = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["regular"]}.ttf')


        # Title of Server
        self.title = Label()
        self.title.__translate__ = False
        self.title.id = "title"
        self.title.halign = "left"
        self.title.color = self.color_id[1]
        self.title.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
        self.title.font_size = sp(25)
        self.title.text_size = (self.size_hint_max[0] * 0.94, self.size_hint_max[1])
        self.title.shorten = True
        self.title.markup = True
        self.title.shorten_from = "right"
        self.title.max_lines = 1
        self.title.text = backup_object.name
        self.add_widget(self.title)


        # Index Icon
        self.index_icon = Image()
        self.index_icon.id = "index_icon"
        self.index_icon.source = os.path.join(constants.gui_assets, 'icons', 'index-fade.png')
        self.index_icon.keep_ratio = False
        self.index_icon.allow_stretch = True
        self.index_icon.size = (44, 44)
        self.index_icon.color = self.color_id[1]
        self.index_icon.opacity = 0.4 if self.newest else 0.2
        self.add_widget(self.index_icon)


        # Index label
        self.index_label = Label()
        self.index_label.__translate__ = False
        self.index_label.id = "index_label"
        self.index_label.halign = "center"
        self.index_label.color = self.color_id[1]
        self.index_label.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
        self.index_label.font_size = sp(23)
        self.index_label.text_size = (50, 50)
        self.index_label.markup = True
        self.index_label.max_lines = 1
        self.index_label.text = str(self.index)
        self.index_label.opacity = 0.8 if self.newest else 0.5
        self.add_widget(self.index_label)


        # Server last modified date formatted
        self.subtitle = Label()
        self.subtitle.size = (300, 30)
        self.subtitle.id = "subtitle"
        self.subtitle.halign = "left"
        self.subtitle.valign = "center"
        self.subtitle.font_size = sp(21)
        self.subtitle.text_size = (self.size_hint_max[0] * 0.91, self.size_hint_max[1])
        self.subtitle.shorten = True
        self.subtitle.markup = True
        self.subtitle.shorten_from = "right"
        self.subtitle.max_lines = 1
        self.subtitle.color = self.color_id[1]
        self.subtitle.default_opacity = 0.56
        self.subtitle.font_name = self.original_font
        self.subtitle.text = self.original_subtitle
        self.subtitle.opacity = self.subtitle.default_opacity
        self.add_widget(self.subtitle)


        # Type icon and info
        "unknown_small.png"
        self.type_image = RelativeLayout()
        self.type_image.width = 400
        self.type_image.image = Image(source=os.path.join(constants.gui_assets, 'icons', 'big', f'{backup_object.type.lower()}_small.png'))
        self.type_image.image.allow_stretch = True
        self.type_image.image.size_hint_max = (65, 65)
        self.type_image.image.color = self.color_id[1]
        self.type_image.add_widget(self.type_image.image)

        def TemplateLabel():
            template_label = AlignLabel()
            template_label.__translate__ = False
            template_label.halign = "right"
            template_label.valign = "middle"
            template_label.text_size = template_label.size
            template_label.font_size = sp(19)
            template_label.color = self.color_id[1]
            template_label.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
            template_label.width = 150
            return template_label

        self.type_image.version_label = TemplateLabel()
        self.type_image.version_label.color = self.color_id[1]
        if backup_object.build:
            self.type_image.version_label.text = f'{backup_object.version.lower()} (b-{backup_object.build.lower()})'
        else:
            self.type_image.version_label.text = backup_object.version.lower()
        self.type_image.version_label.opacity = 0.6

        self.type_image.type_label = TemplateLabel()
        self.type_image.type_label.text = backup_object.type.lower().replace("craft", "")
        self.type_image.type_label.font_size = sp(23)
        self.type_image.add_widget(self.type_image.version_label)
        self.type_image.add_widget(self.type_image.type_label)
        self.add_widget(self.type_image)

        self.bind(pos=self.resize_self)

        # If click_function
        if click_function:
            self.bind(on_press=click_function)

        # Animate opacity
        if fade_in > 0:
            self.opacity = 0
            self.title.opacity = 0

            Animation(opacity=1, duration=fade_in).start(self)
            Animation(opacity=1, duration=fade_in).start(self.title)
            Animation(opacity=self.subtitle.default_opacity, duration=fade_in).start(self.subtitle)

    def on_enter(self, *args):
        if not self.ignore_hover:
            self.animate_button(image=os.path.join(constants.gui_assets, f'{self.id}_hover.png'), color=self.color_id[0], hover_action=True)

    def on_leave(self, *args):
        if not self.ignore_hover:
            self.animate_button(image=os.path.join(constants.gui_assets, f'{self.id}{"_ro" if self.newest else ""}.png'), color=self.color_id[1], hover_action=False)

class ServerBackupRestoreScreen(MenuBackground):

    def switch_page(self, direction):

        if self.max_pages == 1:
            return

        if direction == "right":
            if self.current_page == self.max_pages:
                self.current_page = 1
            else:
                self.current_page += 1

        else:
            if self.current_page == 1:
                self.current_page = self.max_pages
            else:
                self.current_page -= 1

        self.page_switcher.update_index(self.current_page, self.max_pages)
        self.gen_search_results(self.last_results)

    def gen_search_results(self, results, new_search=False, fade_in=True, animate_scroll=True, *args):

        # Set to proper page on favorite/unfavorite
        default_scroll = 1


        # Update page counter
        self.last_results = results
        self.max_pages = (len(results) / self.page_size).__ceil__()
        self.current_page = 1 if self.current_page == 0 or new_search else self.current_page


        self.page_switcher.update_index(self.current_page, self.max_pages)
        page_list = results[(self.page_size * self.current_page) - self.page_size:self.page_size * self.current_page]

        self.scroll_layout.clear_widgets()


        # Generate header
        backup_count = len(results)
        header_content = "Select a back-up to restore"

        for child in self.header.children:
            if child.id == "text":
                child.text = header_content
                break


        # Show back-ups if they exist
        if backup_count != 0:

            # Clear and add all ServerButtons
            for x, backup_object in enumerate(page_list, 1):

                # Activated when addon is clicked
                def restore_backup(backup_obj, index, *args):

                    def restore_screen(file, stop=False, *args):
                        server_obj = constants.server_manager.current_server
                        if stop:
                            server_obj.silent_command("stop")
                            while server_obj.running:
                                time.sleep(0.2)
                        constants.server_manager.current_server.backup._restore_file = file
                        screen_manager.current = 'ServerBackupRestoreProgressScreen'

                    selected_button = [item for item in self.scroll_layout.walk() if item.__class__.__name__ == "BackupButton"][index - 1]
                    if constants.server_manager.current_server.running:
                        screen_manager.current_screen.show_popup(
                            "query",
                            "Stop & Restore Back-up",
                            f"Are you sure you want to stop and revert '{backup_obj.name}' to {backup_obj.date}?\n\nThis action can't be undone",
                            [None, functools.partial(Clock.schedule_once, functools.partial(restore_screen, backup_obj, True), 0.25)]
                        )
                    else:
                        screen_manager.current_screen.show_popup(
                            "query",
                            "Restore Back-up",
                            f"Are you sure you want to revert '${backup_obj.name}$' to ${backup_obj.date}$?\n\nThis action can't be undone",
                            [None, functools.partial(Clock.schedule_once, functools.partial(restore_screen, backup_obj, False), 0.25)]
                        )


                # Add-on button click function
                self.scroll_layout.add_widget(
                    ScrollItem(
                        widget = BackupButton(
                            backup_object = backup_object,
                            fade_in = ((x if x <= 8 else 8) / self.anim_speed) if fade_in else 0,
                            index = x + ((self.current_page - 1) * self.page_size),
                            click_function = functools.partial(
                                restore_backup,
                                backup_object,
                                x
                            )
                        )
                    )
                )

            self.resize_bind()

        # Animate scrolling
        def set_scroll(*args):
            Animation.stop_all(self.scroll_layout.parent.parent)
            if animate_scroll:
                Animation(scroll_y=default_scroll, duration=0.1).start(self.scroll_layout.parent.parent)
            else:
                self.scroll_layout.parent.parent.scroll_y = default_scroll
        Clock.schedule_once(set_scroll, 0)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.header = None
        self.scroll_layout = None
        self.blank_label = None
        self.page_switcher = None

        self.last_results = []
        self.page_size = 10
        self.current_page = 0
        self.max_pages = 0
        self.anim_speed = 10

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        super()._on_keyboard_down(keyboard, keycode, text, modifiers)

        # Press arrow keys to switch pages
        if keycode[1] in ['right', 'left'] and self.name == screen_manager.current_screen.name:
            self.switch_page(keycode[1])

    def generate_menu(self, **kwargs):
        server_obj = constants.server_manager.current_server
        backup_list = server_obj.backup.return_backup_list()

        # Scroll list
        scroll_widget = ScrollViewWidget(position=(0.5, 0.52))
        scroll_anchor = AnchorLayout()
        self.scroll_layout = GridLayout(cols=1, spacing=15, size_hint_max_x=1250, size_hint_y=None, padding=[0, 30, 0, 30])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 1.82
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1
            self.anim_speed = 13 if Window.width > grid_layout.size_hint_max_x else 10

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, self.scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        self.scroll_layout.bind(minimum_height=self.scroll_layout.setter('height'))
        self.scroll_layout.id = 'scroll_content'


        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.795}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.26}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60))

        # Generate buttons on page load
        header_content = "Select a back-up to restore"
        self.header = HeaderText(header_content, '', (0, 0.89))

        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(self.header)

        self.page_switcher = PageSwitcher(0, 0, (0.5, 0.887), self.switch_page)


        # Append scroll view items
        scroll_anchor.add_widget(self.scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)
        float_layout.add_widget(self.page_switcher)

        buttons.append(ExitButton('Back', (0.5, 0.11), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        float_layout.add_widget(generate_title(f"Back-up Manager: '{server_obj.name}'"))
        float_layout.add_widget(generate_footer(f"{server_obj.name}, Back-ups, Restore"))

        self.add_widget(float_layout)

        # Automatically generate results on page load
        constants.server_manager.refresh_list()
        self.gen_search_results(backup_list)

class ServerBackupDownloadScreen(MenuBackground):

    def switch_page(self, direction):

        if self.max_pages == 1:
            return

        if direction == "right":
            if self.current_page == self.max_pages:
                self.current_page = 1
            else:
                self.current_page += 1

        else:
            if self.current_page == 1:
                self.current_page = self.max_pages
            else:
                self.current_page -= 1

        self.page_switcher.update_index(self.current_page, self.max_pages)
        self.gen_search_results(self.last_results)

    def gen_search_results(self, results, new_search=False, fade_in=True, animate_scroll=True, *args):

        # Set to proper page on favorite/unfavorite
        default_scroll = 1


        # Update page counter
        self.last_results = results
        self.max_pages = (len(results) / self.page_size).__ceil__()
        self.current_page = 1 if self.current_page == 0 or new_search else self.current_page


        self.page_switcher.update_index(self.current_page, self.max_pages)
        page_list = results[(self.page_size * self.current_page) - self.page_size:self.page_size * self.current_page]

        self.scroll_layout.clear_widgets()


        # Generate header
        backup_count = len(results)
        header_content = "Select a back-up to download"

        for child in self.header.children:
            if child.id == "text":
                child.text = header_content
                break


        # Show back-ups if they exist
        if backup_count != 0:

            # Clear and add all ServerButtons
            for x, backup_object in enumerate(page_list, 1):

                # Activated when addon is clicked
                def download_backup(backup_obj, index, *args):
                    server_obj = constants.server_manager.current_server
                    if not server_obj._telepath_data:
                        return

                    screen_manager.current = 'ServerBackupScreen'
                    def download_thread():
                        if screen_manager.current_screen.name == 'ServerBackupScreen':
                            download_button = screen_manager.current_screen.download_button
                            if download_button:
                                Clock.schedule_once(functools.partial(download_button.loading, True), 0)

                        location = constants.telepath_download(server_obj._telepath_data, backup_obj.path, constants.userDownloads)
                        if os.path.exists(location):
                            constants.open_folder(location)
                            Clock.schedule_once(
                                functools.partial(
                                    screen_manager.current_screen.show_banner,
                                    (0.553, 0.902, 0.675, 1),
                                    f'Downloaded back-up successfully',
                                    "cloud-download-sharp.png",
                                    3,
                                    {"center_x": 0.5, "center_y": 0.965}
                                ), 1
                            )

                        if screen_manager.current_screen.name == 'ServerBackupScreen':
                            download_button = screen_manager.current_screen.download_button
                            if download_button:
                                Clock.schedule_once(functools.partial(download_button.loading, False), 0)

                    threading.Timer(0, download_thread).start()


                # Add-on button click function
                self.scroll_layout.add_widget(
                    ScrollItem(
                        widget = BackupButton(
                            backup_object = backup_object,
                            fade_in = ((x if x <= 8 else 8) / self.anim_speed) if fade_in else 0,
                            index = x + ((self.current_page - 1) * self.page_size),
                            click_function = functools.partial(
                                download_backup,
                                backup_object,
                                x
                            )
                        )
                    )
                )

            self.resize_bind()

        # Animate scrolling
        def set_scroll(*args):
            Animation.stop_all(self.scroll_layout.parent.parent)
            if animate_scroll:
                Animation(scroll_y=default_scroll, duration=0.1).start(self.scroll_layout.parent.parent)
            else:
                self.scroll_layout.parent.parent.scroll_y = default_scroll
        Clock.schedule_once(set_scroll, 0)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.header = None
        self.scroll_layout = None
        self.blank_label = None
        self.page_switcher = None

        self.last_results = []
        self.page_size = 10
        self.current_page = 0
        self.max_pages = 0
        self.anim_speed = 10

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        super()._on_keyboard_down(keyboard, keycode, text, modifiers)

        # Press arrow keys to switch pages
        if keycode[1] in ['right', 'left'] and self.name == screen_manager.current_screen.name:
            self.switch_page(keycode[1])

    def generate_menu(self, **kwargs):
        server_obj = constants.server_manager.current_server
        backup_list = server_obj.backup.return_backup_list()

        # Scroll list
        scroll_widget = ScrollViewWidget(position=(0.5, 0.52))
        scroll_anchor = AnchorLayout()
        self.scroll_layout = GridLayout(cols=1, spacing=15, size_hint_max_x=1250, size_hint_y=None, padding=[0, 30, 0, 30])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 1.82
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1
            self.anim_speed = 13 if Window.width > grid_layout.size_hint_max_x else 10

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, self.scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        self.scroll_layout.bind(minimum_height=self.scroll_layout.setter('height'))
        self.scroll_layout.id = 'scroll_content'


        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.795}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.26}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60))

        # Generate buttons on page load
        header_content = "Select a back-up to download"
        self.header = HeaderText(header_content, '', (0, 0.89))

        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(self.header)

        self.page_switcher = PageSwitcher(0, 0, (0.5, 0.887), self.switch_page)


        # Append scroll view items
        scroll_anchor.add_widget(self.scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)
        float_layout.add_widget(self.page_switcher)

        buttons.append(ExitButton('Back', (0.5, 0.11), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        float_layout.add_widget(generate_title(f"Back-up Manager: '{server_obj.name}'"))
        float_layout.add_widget(generate_footer(f"{server_obj.name}, Back-ups, Download"))

        self.add_widget(float_layout)

        # Automatically generate results on page load
        constants.server_manager.refresh_list()
        self.gen_search_results(backup_list)

class ServerBackupRestoreProgressScreen(ProgressScreen):

    # Only replace this function when making a child screen
    # Set fail message in child functions to trigger an error
    def contents(self):

        def before_func(*args):

            # First, clean out any existing server in temp folder
            os.chdir(constants.get_cwd())
            constants.safe_delete(constants.tempDir)
            constants.folder_check(constants.tmpsvr)

        def after_func(server_obj, restore_date):
            message = f"'${server_obj.name}$' was restored to ${restore_date}$"
            self.open_server(server_obj.name, True, message)

        # Original is percentage before this function, adjusted is a percent of hooked value
        def adjust_percentage(*args):
            original = self.last_progress
            adjusted = args[0]
            total = args[1] * 0.01
            final = original + round(adjusted * total)
            if final < 0:
                final = original
            self.progress_bar.update_progress(final)

        server_obj = constants.server_manager.current_server
        restore_file = server_obj.backup._restore_file
        restore_date = server_obj.backup._restore_file.date
        self.page_contents = {

            # Page name
            'title': f"Restoring '${server_obj.name}$'",

            # Header text
            'header': "Sit back and relax, it's automation time...",

            # Tuple of tuples for steps (label, function, percent)
            # Percent of all functions must total 100
            # Functions must return True, or default error will be executed
            'default_error': 'There was an issue, please try again later',

            'function_list': (),

            # Function to run before steps (like checking for an internet connection)
            'before_function': before_func,

            # Function to run after everything is complete (like cleaning up the screen tree) will only run if no error
            'after_function': functools.partial(after_func, server_obj, restore_date),

            # Screen to go to after complete
            'next_screen': None
        }

        # Create function list
        java_text = 'Verifying Java Installation' if os.path.exists(constants.javaDir) else 'Installing Java'
        function_list = [
            (java_text, functools.partial(constants.java_check, functools.partial(adjust_percentage, 30)), 0),
            ('Restoring back-up', functools.partial(constants.restore_server, restore_file, functools.partial(adjust_percentage, 70)), 0),
        ]

        self.page_contents['function_list'] = tuple(function_list)

class ServerCloneScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.name_input = None

    def generate_menu(self, **kwargs):

        # Return if no free space or telepath is busy
        if disk_popup():
            return
        if telepath_popup():
            return

        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        constants.new_server_init()
        constants.import_data = {'name': None, 'path': None}
        server_obj = constants.server_manager.current_server

        # Regular menu
        float_layout.add_widget(InputLabel(pos_hint={"center_x": 0.5, "center_y": 0.58}))
        float_layout.add_widget(HeaderText("What would you like to name the copy?", '', (0, 0.76)))
        self.name_input = ServerNameInput(pos_hint={"center_x": 0.5, "center_y": 0.5}, text=server_obj.name)
        float_layout.add_widget(self.name_input)
        def start_clone(*a):
            screen_manager.current = 'ServerCloneProgressScreen'
        buttons.append(next_button('Clone', (0.5, 0.24), False, click_func=start_clone))
        buttons.append(ExitButton('Back', (0.5, 0.14), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)


        # Add telepath button if servers are connected
        if constants.server_manager.online_telepath_servers:
            float_layout.add_widget(TelepathDropButton('clone', (0.5, 0.4)))

        float_layout.add_widget(generate_title(f"Back-up Manager: '{server_obj.name}'"))
        float_layout.add_widget(generate_footer(f"{server_obj.name}, Back-ups, Clone"))

        self.add_widget(float_layout)
        self.name_input.grab_focus()
        Clock.schedule_once(functools.partial(self.name_input.on_enter, self.name_input.text, False), 0)


class ServerCloneProgressScreen(ProgressScreen):

    # Only replace this function when making a child screen
    # Set fail message in child functions to trigger an error
    def contents(self):
        server_name = constants.new_server_info['name']
        open_after = functools.partial(self.open_server, server_name, True, f"'${server_name}$' was created successfully")

        def before_func(*args):

            if not constants.check_free_space(telepath_data=constants.new_server_info['_telepath_data']):
                self.execute_error("Your primary disk is almost full\n\nFree up space and try again")

            else:
                constants.pre_server_create()

        def after_func(*args):
            constants.post_server_create()
            open_after()


        # Original is percentage before this function, adjusted is a percent of hooked value
        def adjust_percentage(*args):
            original = self.last_progress
            adjusted = args[0]
            total = args[1] * 0.01
            final = original + round(adjusted * total)
            if final < 0:
                final = original
            self.progress_bar.update_progress(final)

        self.page_contents = {

            # Page name
            'title': f"Creating '{server_name}'",

            # Header text
            'header': "Sit back and relax, it's automation time...",

            # Tuple of tuples for steps (label, function, percent)
            # Percent of all functions must total 100
            # Functions must return True, or default error will be executed
            'default_error': 'There was an issue, please try again later',

            'function_list': (),

            # Function to run before steps (like checking for an internet connection)
            'before_function': before_func,

            # Function to run after everything is complete (like cleaning up the screen tree) will only run if no error
            'after_function': after_func,

            # Screen to go to after complete
            'next_screen': None
        }


        # Create function list
        server_obj = constants.server_manager.current_server
        java_text = 'Verifying Java Installation' if os.path.exists(constants.javaDir) else 'Installing Java'

        # If remote data, open remote server after
        print(constants.new_server_info)
        if constants.new_server_info['_telepath_data']:
            self._telepath_override = constants.new_server_info['_telepath_data']

        # If not remote data, restore server manager open server on error
        else:
            self._telepath_override = '$local'
            def restore_server():
                constants.server_manager.current_server = server_obj
            self._error_callback = restore_server

        function_list = [
            (java_text, functools.partial(constants.java_check, functools.partial(adjust_percentage, 30)), 0),
            ('Saving a back-up', server_obj.backup.save, 10),
            ('Cloning server', functools.partial(constants.clone_server, server_obj, functools.partial(adjust_percentage, 50)), 0),
            ('Creating initial back-up', functools.partial(constants.create_backup, True), 10)
        ]

        self.page_contents['function_list'] = tuple(function_list)



# Server Access Control ------------------------------------------------------------------------------------------------

class ServerAclScreen(CreateServerAclScreen):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.menu_taskbar = None

    def generate_menu(self, **kwargs):

        # If self._hash doesn't match, set list to ops by default
        if self._hash != constants.server_manager.current_server._hash:
            self.acl_object = constants.server_manager.current_server.acl
            self._hash = constants.server_manager.current_server._hash
            self.current_list = 'ops'

        self.show_panel = False

        self.filter_text = ""
        self.currently_filtering = False

        # Scroll list
        self.scroll_widget = RecycleViewWidget(position=(0.5, 0.455), view_class=RuleButton)
        self.scroll_layout = RecycleGridLayout(spacing=[110, -15], size_hint_y=None, padding=[60, 20, 0, 30])
        test_rule = RuleButton()

        # Bind / cleanup height on resize
        def resize_scroll(*args):
            self.scroll_widget.height = Window.height // 1.69
            rule_width = test_rule.width + self.scroll_layout.spacing[0] + 2
            rule_width = int(((Window.width // rule_width) // 1) - 2)

            self.scroll_layout.cols = rule_width
            self.scroll_layout.rows = 2 if len(self.scroll_widget.data) <= rule_width else None

            self.user_panel.x = Window.width - (self.user_panel.size_hint_max[0] * 0.93)

            # Reposition header
            for child in self.header.children:
                if child.id == "text":
                    child.halign = "left"
                    child.text_size[0] = 500
                    child.x = Window.width / 2 + 240
                    break

            self.search_label.pos_hint = {"center_x": (0.28 if Window.width < 1300 else 0.5), "center_y": 0.42}
            self.search_label.text_size = (Window.width / 3, 500)

        self.resize_bind = lambda *_: Clock.schedule_once(functools.partial(resize_scroll), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        self.scroll_layout.bind(minimum_height=self.scroll_layout.setter('height'))
        self.scroll_layout.id = 'scroll_content'

        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.735}, pos=self.scroll_widget.pos, size=(self.scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.175}, pos=self.scroll_widget.pos, size=(self.scroll_widget.width // 1.5, -60))

        # Generate buttons on page load
        selector_text = "operators" if self.current_list == "ops" else "bans" if self.current_list == "bans" else "whitelist"
        self.page_selector = DropButton(selector_text, (0.5, 0.89), options_list=['operators', 'bans', 'whitelist'], input_name='ServerAclTypeInput', x_offset=-210, facing='center', custom_func=self.update_list)
        header_content = ""
        self.header = HeaderText(header_content, '', (0, 0.89), fixed_x=True, no_line=True)

        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(self.header)

        # Search bar
        self.search_bar = AclInput(pos_hint={"center_x": 0.5, "center_y": 0.815})
        buttons.append(input_button('Add Rules...', (0.5, 0.815), input_name='AclInput'))

        # Whitelist toggle button
        def toggle_whitelist(boolean):
            self.acl_object.enable_whitelist(boolean)

            Clock.schedule_once(
                functools.partial(
                    self.show_banner,
                    (0.553, 0.902, 0.675, 1) if boolean else (0.937, 0.831, 0.62, 1),
                    f"Server whitelist {'en' if boolean else 'dis'}abled",
                    "shield-checkmark-outline.png" if boolean else "shield-disabled-outline.png",
                    2,
                    {"center_x": 0.5, "center_y": 0.965}
                ), 0
            )

            # Update list
            self.update_list('wl', reload_children=True, reload_panel=True)

        self.whitelist_toggle = toggle_button('whitelist', (0.5, 0.89), default_state=self.acl_object._server['whitelist'], x_offset=-395, custom_func=toggle_whitelist)

        # Legend for rule types
        self.list_header = BoxLayout(orientation="horizontal", pos_hint={"center_x": 0.5, "center_y": 0.749}, size_hint_max=(400, 100))
        self.list_header.global_rule = RelativeLayout()
        self.list_header.global_rule.add_widget(BannerObject(size=(120, 32), color=test_rule.global_icon_color, text="global", icon="earth-sharp.png", icon_side="left"))
        self.list_header.add_widget(self.list_header.global_rule)

        self.list_header.enabled_rule = RelativeLayout()
        self.list_header.enabled_rule.add_widget(BannerObject(size=(120, 32), color=(1, 1, 1, 1), text=" ", icon="add.png"))
        self.list_header.add_widget(self.list_header.enabled_rule)

        self.list_header.disabled_rule = RelativeLayout()
        self.list_header.disabled_rule.add_widget(BannerObject(size=(120, 32), color=(1, 1, 1, 1), text=" ", icon="add.png"))
        self.list_header.add_widget(self.list_header.disabled_rule)

        # Add blank label to the center, then load self.gen_search_results()
        self.blank_label = Label()
        self.blank_label.text = ""
        self.blank_label.font_name = os.path.join(constants.gui_assets, 'fonts', constants.fonts['italic'])
        self.blank_label.pos_hint = {"center_x": 0.5, "center_y": 0.48}
        self.blank_label.font_size = sp(23)
        self.blank_label.opacity = 0
        self.blank_label.color = (0.6, 0.6, 1, 0.35)
        float_layout.add_widget(self.blank_label)

        # Lol search label idek
        self.search_label = Label()
        self.search_label.text = ""
        self.search_label.halign = "center"
        self.search_label.valign = "center"
        self.search_label.font_name = os.path.join(constants.gui_assets, 'fonts', constants.fonts['italic'])
        self.search_label.pos_hint = {"center_x": 0.28, "center_y": 0.42}
        self.search_label.font_size = sp(25)
        self.search_label.color = (0.6, 0.6, 1, 0.35)
        float_layout.add_widget(self.search_label)

        # Controls button
        def show_controls():

            controls_text = """This menu shows enabled rules from files like 'ops.json', and disabled rules as others who have joined. Global rules are applied to every server. Rules can be modified in a few different ways:

â€¢ Right-click a rule to view, and see more options

â€¢ Left-click a rule to toggle permission

â€¢ Press middle-mouse to toggle globally

Rules can be filtered with the search bar, and can be added with the 'Add Rules' button or by pressing 'TAB'. The visible list can be switched between operators, bans, and the whitelist from the drop-down at the top."""

            Clock.schedule_once(
                functools.partial(
                    self.show_popup,
                    "controls",
                    "Controls",
                    controls_text,
                    (None)
                ),
                0
            )

        self.controls_button = IconButton('controls', {}, (70, 110), (None, None), 'question.png', clickable=True, anchor='right', click_func=show_controls)

        # User panel
        self.user_panel = AclRulePanel()
        self.user_panel.pos_hint = {"center_y": 0.44}

        # Append scroll view items
        self.scroll_widget.add_widget(self.scroll_layout)
        float_layout.add_widget(self.scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)
        float_layout.add_widget(self.page_selector)
        float_layout.add_widget(self.list_header)
        float_layout.add_widget(self.search_bar)
        float_layout.add_widget(self.whitelist_toggle)
        float_layout.add_widget(self.user_panel)

        buttons.append(ExitButton('Back', (0.5, -1), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        menu_name = f"{constants.server_manager.current_server.name}, Access Control"
        float_layout.add_widget(generate_title(f"Access Control Manager: '{constants.server_manager.current_server.name}'"))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)


        # Add ManuTaskbar
        self.menu_taskbar = MenuTaskbar(selected_item='access control')
        self.add_widget(self.menu_taskbar)

        # Add controls after taskbar because it's unclickable for some reason
        float_layout.add_widget(self.controls_button)


        # Generate page content
        self.update_list(self.current_list, reload_children=True)

        # Generate user panel info
        current_list = acl.deepcopy(self.acl_object.rules[self.current_list])
        if self.current_list == "bans":
            current_list.extend(acl.deepcopy(self.acl_object.rules['subnets']))

        if self.acl_object.displayed_rule and current_list:
            global_rules = acl.load_global_acl()
            self.acl_object.displayed_rule.acl_group = self.current_list
            rule_scope = acl.check_global_acl(global_rules, self.acl_object.displayed_rule).rule_scope
            self.update_user_panel(self.acl_object.displayed_rule.rule, rule_scope)
        else:
            self.update_user_panel(None, None)

class ServerAclRuleScreen(CreateServerAclRuleScreen):

    def generate_menu(self, **kwargs):
        # Generate buttons on page load

        class HintLabel(RelativeLayout):

            def icon_pos(self, *args):
                self.text.texture_update()
                self.icon.pos_hint = {"center_x": 0.57 - (0.005 * self.text.texture_size[0]), "center_y": 0.95}

            def __init__(self, pos, label, **kwargs):
                super().__init__(**kwargs)

                self.pos_hint = {"center_x": 0.5, "center_y": pos}
                self.size_hint_max = (100, 50)

                self.text = Label()
                self.text.id = 'text'
                self.text.size_hint = (None, None)
                self.text.markup = True
                self.text.halign = "center"
                self.text.valign = "center"
                self.text.text = "        " + label
                self.text.font_size = sp(22)
                self.text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
                self.text.color = (0.6, 0.6, 1, 0.55)

                self.icon = Image()
                self.icon.id = 'icon'
                self.icon.source = os.path.join(constants.gui_assets, 'icons', 'information-circle-outline.png')
                self.icon.pos_hint = {"center_y": 0.95}
                self.icon.color = (0.6, 0.6, 1, 1)

                self.add_widget(self.text)
                self.add_widget(self.icon)

                self.bind(size=self.icon_pos)
                self.bind(pos=self.icon_pos)


        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'

        self.current_list = screen_manager.get_screen("ServerAclScreen").current_list
        self.acl_object = screen_manager.get_screen("ServerAclScreen").acl_object

        if self.current_list == "bans":
            header_message = "Enter usernames/IPs delimited, by, commas"
            float_layout.add_widget(HintLabel(0.464, "Use   [color=#FFFF33]!g <rule>[/color]   to apply globally on all servers"))
            float_layout.add_widget(HintLabel(0.374, "You can ban IP ranges/whitelist:   [color=#FF6666]192.168.0.0-150[/color], [color=#66FF88]!w 192.168.1.1[/color]"))
        else:
            header_message = "Enter usernames delimited, by, commas"
            float_layout.add_widget(HintLabel(0.425, "Use   [color=#FFFF33]!g <rule>[/color]   to apply globally on all servers"))

        float_layout.add_widget(InputLabel(pos_hint={"center_x": 0.5, "center_y": 0.72}))
        float_layout.add_widget(HeaderText(header_message, '', (0, 0.8)))
        self.acl_input = AclRuleInput(pos_hint={"center_x": 0.5, "center_y": 0.64}, text="")
        float_layout.add_widget(self.acl_input)

        buttons.append(next_button('Add Rules', (0.5, 0.24), True, next_screen='ServerAclScreen'))
        buttons.append(ExitButton('Back', (0.5, 0.14), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        menu_name = f"{constants.server_manager.current_server.name}, Access Control"
        list_name = "Operators" if self.current_list == "ops" else "Bans" if self.current_list == "bans" else "Whitelist"
        float_layout.add_widget(generate_title(f"Access Control Manager: Add {list_name}"))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)
        self.acl_input.grab_focus()



# Server Add-on Manager ------------------------------------------------------------------------------------------------

class AddonListButton(HoverButton):

    def toggle_enabled(self, *args):
        self.title.text_size = (self.size_hint_max[0] * (0.7), self.size_hint_max[1])
        self.background_normal = os.path.join(constants.gui_assets, f'{self.id}{"" if self.enabled else "_disabled"}.png')

        # If disabled, add banner as such
        if not self.enabled:
            self.disabled_banner = BannerObject(
                pos_hint = {"center_x": 0.5, "center_y": 0.5},
                size = (125, 32),
                color = (1, 0.53, 0.58, 1),
                text = "disabled",
                icon = "close-circle.png",
                icon_side = "right"
            )
            self.add_widget(self.disabled_banner)

        self.resize_self()

    def animate_addon(self, image, color, **kwargs):
        image_animate = Animation(duration=0.05)

        def f(w):
            w.background_normal = image

        Animation(color=color, duration=0.06).start(self.title)
        Animation(color=color, duration=0.06).start(self.subtitle)

        a = Animation(duration=0.0)
        a.on_complete = functools.partial(f)

        image_animate += a

        image_animate.start(self)

    def resize_self(self, *args):

        # Title and description
        padding = 2.17
        self.title.pos = (self.x + (self.title.text_size[0] / padding) - 6, self.y + 31)
        self.subtitle.pos = (self.x + (self.subtitle.text_size[0] / padding) - 1, self.y)
        self.hover_text.pos = (self.x + (self.size[0] / padding) - 30, self.y + 15)

        # Type Banner
        if self.disabled_banner:
            self.disabled_banner.pos_hint = {"center_x": None, "center_y": None}
            self.disabled_banner.pos = (self.width + self.x - self.disabled_banner.width - 18, self.y + 38.5)

        # Delete button
        self.delete_layout.size_hint_max = (self.size_hint_max[0], self.size_hint_max[1])
        self.delete_layout.pos = (self.pos[0] + self.width - (self.delete_button.width / 1.33), self.pos[1] + 13)

        # Reposition highlight border
        self.highlight_layout.pos = self.pos

    def highlight(self):
        def next_frame(*args):
            Animation.stop_all(self.highlight_border)
            self.highlight_border.opacity = 1
            Animation(opacity=0, duration=0.7).start(self.highlight_border)

        Clock.schedule_once(next_frame, 0)

    def __init__(self, properties, click_function=None, enabled=False, fade_in=0.0, highlight=False, **kwargs):
        super().__init__(**kwargs)

        self.enabled = enabled
        self.properties = properties
        self.border = (-5, -5, -5, -5)
        self.color_id = [(0.05, 0.05, 0.1, 1), (0.65, 0.65, 1, 1)] if self.enabled else [(0.05, 0.1, 0.1, 1), (1, 0.6, 0.7, 1)]
        self.pos_hint = {"center_x": 0.5, "center_y": 0.6}
        self.size_hint_max = (580, 80)
        self.id = "addon_button"
        self.background_normal = os.path.join(constants.gui_assets, f'{self.id}.png')
        self.background_down = self.background_normal
        self.disabled_banner = None


        # Delete button
        def delete_hover(*args):
            def change_color(*args):
                if self.hovered:
                    self.hover_text.text = 'UNINSTALL ADD-ON'
                    self.background_normal = os.path.join(constants.gui_assets, "server_button_favorite_hover.png")
            Clock.schedule_once(change_color, 0.07)
            Animation.stop_all(self.delete_button)
            Animation(opacity=1, duration=0.25).start(self.delete_button)
        def delete_on_leave(*args):
            def change_color(*args):
                self.hover_text.text = ('DISABLE ADD-ON' if self.enabled else 'ENABLE ADD-ON')
                if self.hovered:
                    self.background_normal = os.path.join(constants.gui_assets, f'{self.id}_hover_{"dis" if self.enabled else "en"}abled.png')
                    self.background_down = self.background_normal
            Clock.schedule_once(change_color, 0.07)
            Animation.stop_all(self.delete_button)
            Animation(opacity=0.65, duration=0.25).start(self.delete_button)
        def delete_click(*args):
            # Delete addon and reload list
            def reprocess_page(*args):
                addon_manager = constants.server_manager.current_server.addon
                addon_manager.delete_addon(self.properties)
                addon_screen = screen_manager.current_screen
                new_list = [addon for addon in addon_manager.return_single_list() if not addons.is_geyser_addon(addon)]
                addon_screen.gen_search_results(new_list, fade_in=True)
                Clock.schedule_once(functools.partial(addon_screen.search_bar.execute_search, addon_screen.search_bar.previous_search), 0)

                # Show banner if server is running
                if addon_manager._hash_changed():
                    Clock.schedule_once(
                        functools.partial(
                            screen_manager.current_screen.show_banner,
                            (0.937, 0.831, 0.62, 1),
                            f"A server restart is required to apply changes",
                            "sync.png",
                            3,
                            {"center_x": 0.5, "center_y": 0.965}
                        ), 0
                    )

                else:
                    Clock.schedule_once(
                        functools.partial(
                            screen_manager.current_screen.show_banner,
                            (1, 0.5, 0.65, 1),
                            f"'${self.properties.name}$' was uninstalled",
                            "trash-sharp.png",
                            2.5,
                            {"center_x": 0.5, "center_y": 0.965}
                        ), 0.25
                    )

                # Switch pages if page is empty
                if (len(addon_screen.scroll_layout.children) == 0) and (len(new_list) > 0):
                    addon_screen.switch_page("left")


            Clock.schedule_once(
                functools.partial(
                    screen_manager.current_screen.show_popup,
                    "warning_query",
                    f'Uninstall ${self.properties.name}$',
                    "Do you want to permanently uninstall this add-on?\n\nYou'll need to re-import or download it again",
                    (None, functools.partial(reprocess_page))
                ),
                0
            )
        self.delete_layout = RelativeLayout(opacity=0)
        self.delete_button = IconButton('', {}, (0, 0), (None, None), 'trash-sharp.png', clickable=True, force_color=[[(0.05, 0.05, 0.1, 1), (0.01, 0.01, 0.01, 1)], 'pink'], anchor='right', click_func=delete_click)
        self.delete_button.opacity = 0.65
        self.delete_button.button.bind(on_enter=delete_hover)
        self.delete_button.button.bind(on_leave=delete_on_leave)
        self.delete_layout.add_widget(self.delete_button)
        self.add_widget(self.delete_layout)


        # Hover text
        self.hover_text = Label()
        self.hover_text.id = 'hover_text'
        self.hover_text.size_hint = (None, None)
        self.hover_text.pos_hint = {"center_x": 0.5, "center_y": 0.5}
        self.hover_text.text = ('DISABLE ADD-ON' if self.enabled else 'ENABLE ADD-ON')
        self.hover_text.font_size = sp(23)
        self.hover_text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["bold"]}.ttf')
        self.hover_text.color = (0.1, 0.1, 0.1, 1)
        self.hover_text.halign = "center"
        self.hover_text.text_size = (self.size_hint_max[0] * 0.94, self.size_hint_max[1])
        self.hover_text.opacity = 0
        self.add_widget(self.hover_text)


        # Loading stuffs
        self.original_subtitle = self.properties.subtitle if self.properties.subtitle else "Description unavailable"
        self.original_font = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["regular"]}.ttf')


        # Title of Addon
        self.title = Label()
        self.title.__translate__ = False
        self.title.id = "title"
        self.title.halign = "left"
        self.title.color = self.color_id[1]
        self.title.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
        self.title.font_size = sp(25)
        self.title.text_size = (self.size_hint_max[0] * (0.7), self.size_hint_max[1])
        self.title.shorten = True
        self.title.markup = True
        self.title.shorten_from = "right"
        self.title.max_lines = 1
        self.title.text = f"{self.properties.name}  [color=#434368]-[/color]  {self.properties.author if self.properties.author else 'Unknown'}"
        self.add_widget(self.title)
        Clock.schedule_once(self.toggle_enabled, 0)


        # Description of Addon
        self.subtitle = Label()
        self.subtitle.__translate__ = False
        self.subtitle.id = "subtitle"
        self.subtitle.halign = "left"
        self.subtitle.color = self.color_id[1]
        self.subtitle.font_name = self.original_font
        self.subtitle.font_size = sp(21)
        self.default_subtitle_opacity = 0.56
        self.subtitle.opacity = self.default_subtitle_opacity
        self.subtitle.text_size = (self.size_hint_max[0] * 0.91, self.size_hint_max[1])
        self.subtitle.shorten = True
        self.subtitle.shorten_from = "right"
        self.subtitle.max_lines = 1
        self.subtitle.text = self.original_subtitle
        self.add_widget(self.subtitle)


        # Highlight border
        self.highlight_layout = RelativeLayout()
        self.highlight_border = Image()
        self.highlight_border.keep_ratio = False
        self.highlight_border.allow_stretch = True
        self.highlight_border.color = constants.brighten_color(self.color_id[1], 0.1)
        self.highlight_border.opacity = 0
        self.highlight_border.source = os.path.join(constants.gui_assets, 'server_button_highlight.png')
        self.highlight_layout.add_widget(self.highlight_border)
        self.highlight_layout.width = self.size_hint_max[0]
        self.highlight_layout.height = self.size_hint_max[1]
        self.add_widget(self.highlight_layout)

        if highlight:
            self.highlight()

        # If self.enabled is false, and self.properties.version, display version where "enabled" logo is
        self.bind(pos=self.resize_self)
        self.resize_self()

        # If click_function
        if click_function:
            self.bind(on_press=click_function)

        # Animate opacity
        if fade_in > 0:
            self.opacity = 0
            self.title.opacity = 0

            Animation(opacity=1, duration=fade_in).start(self)
            Animation(opacity=1, duration=fade_in).start(self.title)
            Animation(opacity=0.56, duration=fade_in).start(self.subtitle)

    def on_enter(self, *args):
        if not self.ignore_hover:

            # Hide disabled banner if it exists
            if self.disabled_banner:
                Animation.stop_all(self.disabled_banner)
                Animation(opacity=0, duration=0.13).start(self.disabled_banner)

            # Fade button to hover state
            if not self.delete_button.button.hovered:
                self.animate_addon(image=os.path.join(constants.gui_assets, f'{self.id}_hover_{"dis" if self.enabled else "en"}abled.png'), color=self.color_id[0], hover_action=True)

            # Show delete button
            Animation.stop_all(self.delete_layout)
            Animation(opacity=1, duration=0.13).start(self.delete_layout)

            # Hide text
            Animation(opacity=0, duration=0.13).start(self.title)
            Animation(opacity=0, duration=0.13).start(self.subtitle)
            Animation(opacity=1, duration=0.13).start(self.hover_text)

    def on_leave(self, *args):
        if not self.ignore_hover:

            # Hide disabled banner if it exists
            if self.disabled_banner:
                Animation.stop_all(self.disabled_banner)
                Animation(opacity=1, duration=0.13).start(self.disabled_banner)

            # Fade button to default state
            self.animate_addon(image=os.path.join(constants.gui_assets, f'{self.id}{"" if self.enabled else "_disabled"}.png'), color=self.color_id[1], hover_action=False)

            # Hide delete button
            Animation.stop_all(self.delete_layout)
            Animation(opacity=0, duration=0.13).start(self.delete_layout)

            # Show text
            Animation(opacity=1, duration=0.13).start(self.title)
            Animation(opacity=self.default_subtitle_opacity, duration=0.13).start(self.subtitle)
            Animation(opacity=0, duration=0.13).start(self.hover_text)

    def loading(self, load_state, *args):
        if load_state:
            self.subtitle.text = "Loading add-on info..."
            self.subtitle.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
        else:
            self.subtitle.text = self.original_subtitle
            self.subtitle.font_name = self.original_font

class ServerAddonUpdateScreen(ProgressScreen):

    # Only replace this function when making a child screen
    # Set fail message in child functions to trigger an error
    def contents(self):
        server_obj = constants.server_manager.current_server
        icons = os.path.join(constants.gui_assets, 'fonts', constants.fonts['icons'])
        desc_text = "Updating"
        final_text = "Updated"

        def before_func(*args):

            if not constants.app_online:
                self.execute_error("An internet connection is required to continue\n\nVerify connectivity and try again")

            elif not constants.check_free_space(telepath_data=server_obj._telepath_data):
                self.execute_error("Your primary disk is almost full\n\nFree up space and try again")

            else:
                constants.pre_addon_update()

        def after_func(*args):
            self.steps.label_2.text = "Updates complete!" + f"   [font={icons}]Ã¥[/font]"

            constants.post_addon_update()
            if self.telepath:
                server_obj._clear_all_cache()

            if server_obj.running:
                Clock.schedule_once(
                    functools.partial(
                        screen_manager.current_screen.show_banner,
                        (0.937, 0.831, 0.62, 1),
                        f"A server restart is required to apply changes",
                        "sync.png",
                        3,
                        {"center_x": 0.5, "center_y": 0.965}
                    ), 1
                )

            else:
                Clock.schedule_once(
                    functools.partial(
                        screen_manager.current_screen.show_banner,
                        (0.553, 0.902, 0.675, 1),
                        f"{final_text} add-ons successfully",
                        "checkmark-circle-sharp.png",
                        3,
                        {"center_x": 0.5, "center_y": 0.965}
                    ), 1
                )

            constants.screen_tree = ['MainMenuScreen', 'ServerManagerScreen']

        # Original is percentage before this function, adjusted is a percent of hooked value
        def adjust_percentage(*args):
            original = self.last_progress
            adjusted = args[0]
            total = args[1] * 0.01
            final = original + round(adjusted * total)
            if final < 0:
                final = original

            if self.telepath:
                completed_count = addon_count = len(server_obj.addon.return_single_list())
            else:
                addon_count = len(constants.new_server_info['addon_objects'])
                completed_count = round(len(constants.new_server_info['addon_objects']) * (final * 0.01))
            self.steps.label_2.text = "Updating Add-ons" + f"   ({completed_count}/{addon_count})"

            self.progress_bar.update_progress(final)

        self.page_contents = {

            # Page name
            'title': f"{desc_text} add-ons",

            # Header text
            'header': "Sit back and relax, it's automation time...",

            # Tuple of tuples for steps (label, function, percent)
            # Percent of all functions must total 100
            # Functions must return True, or default error will be executed
            'default_error': 'There was an issue, please try again later',

            'function_list': (
                (f'{desc_text} Add-ons...', functools.partial(constants.iter_addons, functools.partial(adjust_percentage, 100), True), 0),
            ),

            # Function to run before steps (like checking for an internet connection)
            'before_function': before_func,

            # Function to run after everything is complete (like cleaning up the screen tree) will only run if no error
            'after_function': after_func,

            # Screen to go to after complete
            'next_screen': 'ServerAddonScreen'
        }

class ServerAddonScreen(MenuBackground):

    def switch_page(self, direction):

        if self.max_pages == 1:
            return

        if direction == "right":
            if self.current_page == self.max_pages:
                self.current_page = 1
            else:
                self.current_page += 1

        else:
            if self.current_page == 1:
                self.current_page = self.max_pages
            else:
                self.current_page -= 1

        self.page_switcher.update_index(self.current_page, self.max_pages)
        self.gen_search_results(self.last_results)

    def gen_search_results(self, results, new_search=False, fade_in=True, highlight=None, animate_scroll=True, last_scroll=None, *args):

        # Update page counter
        # results = list(sorted(results, key=lambda d: d.name.lower()))
        # Set to proper page on toggle

        addon_manager = constants.server_manager.current_server.addon
        default_scroll = 1
        if highlight:
            def divide_chunks(l, n):
                final_list = []

                for i in range(0, len(l), n):
                    final_list.append(l[i:i + n])

                return final_list

            for x, l in enumerate(divide_chunks([x.hash for x in results], self.page_size), 1):
                if highlight in l:
                    if self.current_page != x:
                        self.current_page = x

                    # Update scroll when page is bigger than list
                    if Window.height < self.scroll_layout.height * 1.7:
                        default_scroll = 1 - round(l.index(highlight) / len(l), 2)
                        if default_scroll < 0.21:
                            default_scroll = 0
                        if default_scroll > 0.97:
                            default_scroll = 1
                    break


        self.last_results = results
        self.max_pages = (len(results) / self.page_size).__ceil__()
        self.current_page = 1 if self.current_page == 0 or new_search else self.current_page

        self.page_switcher.update_index(self.current_page, self.max_pages)
        page_list = results[(self.page_size * self.current_page) - self.page_size:self.page_size * self.current_page]

        self.scroll_layout.clear_widgets()


        # Animate scrolling
        def set_scroll(*args):
            Animation.stop_all(self.scroll_layout.parent.parent)
            if animate_scroll:
                Animation(scroll_y=default_scroll, duration=0.1).start(self.scroll_layout.parent.parent)
            else:
                self.scroll_layout.parent.parent.scroll_y = default_scroll
        Clock.schedule_once(set_scroll, 0)


        # Generate header
        addon_count = len(results)
        enabled_count = len([addon for addon in addon_manager.installed_addons['enabled'] if not addons.is_geyser_addon(addon)])
        disabled_count = len(addon_manager.installed_addons['disabled'])
        very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["very-bold"])
        header_content = f"{constants.translate('Installed Add-ons')}  [color=#494977]-[/color]  " + (f'[color=#6A6ABA]{constants.translate("No items")}[/color]' if addon_count == 0 else f'[font={very_bold_font}]1[/font] {constants.translate("item")}' if addon_count == 1 else f'[font={very_bold_font}]{enabled_count:,}{("/[color=#FF8793]" + str(disabled_count) + "[/color]") if disabled_count > 0 else ""}[/font] {constants.translate("items")}')

        if addon_manager._hash_changed():
            icons = os.path.join(constants.gui_assets, 'fonts', constants.fonts['icons'])
            header_content = f"[color=#EFD49E][font={icons}]y[/font] " + header_content + "[/color]"


        for child in self.header.children:
            if child.id == "text":
                child.text = header_content
                break


        # If there are no addons, say as much with a label
        if addon_count == 0:
            self.blank_label.text = "Import or Download add-ons below"
            constants.hide_widget(self.blank_label, False)
            self.blank_label.opacity = 0
            Animation(opacity=1, duration=0.2).start(self.blank_label)
            self.max_pages = 0
            self.current_page = 0

        # If there are addons, display them here
        else:
            constants.hide_widget(self.blank_label, True)

            # Clear and add all addons
            for x, addon_object in enumerate(page_list, 1):
                if addons.is_geyser_addon(addon_object):
                    continue

                # Activated when addon is clicked
                def toggle_addon(index, *args):
                    addon = index

                    if len(addon.name) < 26:
                        addon_name = addon.name
                    else:
                        addon_name = addon.name[:23] + "..."


                    # Toggle addon state
                    success = addon_manager.addon_state(addon, enabled=not addon.enabled)
                    if not success:
                        Clock.schedule_once(
                            functools.partial(
                                self.show_banner,
                                (0.937, 0.831, 0.62, 1),
                                f"can't disable while the server is running",
                                "alert-circle-sharp.png",
                                3,
                                {"center_x": 0.5, "center_y": 0.965}
                            ), 0
                        )
                        return False
                    addon_list = [addon for addon in addon_manager.return_single_list() if not addons.is_geyser_addon(addon)]
                    self.gen_search_results(addon_list, fade_in=False, highlight=addon.hash, animate_scroll=True)


                    # Show banner if server is running
                    if addon_manager._hash_changed():
                        Clock.schedule_once(
                            functools.partial(
                                self.show_banner,
                                (0.937, 0.831, 0.62, 1),
                                f"A server restart is required to apply changes",
                                "sync.png",
                                3,
                                {"center_x": 0.5, "center_y": 0.965}
                            ), 0
                        )

                    else:
                        if addon.enabled:
                            banner_text = f"'${addon_name}$' is now disabled"
                        else:
                            banner_text = f"'${addon_name}$' is now enabled"

                        Clock.schedule_once(
                            functools.partial(
                                self.show_banner,
                                (1, 0.5, 0.65, 1) if addon.enabled else (0.553, 0.902, 0.675, 1),
                                banner_text,
                                "close-circle-sharp.png" if addon.enabled else "checkmark-circle-sharp.png",
                                2.5,
                                {"center_x": 0.5, "center_y": 0.965}
                            ), 0
                        )


                # Add-on button click function
                self.scroll_layout.add_widget(
                    ScrollItem(
                        widget = AddonListButton(
                            properties = addon_object,
                            enabled = addon_object.enabled,
                            fade_in = ((x if x <= 8 else 8) / self.anim_speed) if fade_in else 0,
                            highlight = (highlight == addon_object.hash),
                            click_function = functools.partial(
                                toggle_addon,
                                addon_object,
                                x
                            )
                        )
                    )
                )

            self.resize_bind()
            # self.scroll_layout.parent.parent.scroll_y = 1

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.header = None
        self.scroll_layout = None
        self.blank_label = None
        self.search_bar = None
        self.page_switcher = None
        self.menu_taskbar = None
        self.update_button = None

        self.last_results = []
        self.page_size = 20
        self.current_page = 0
        self.max_pages = 0
        self.anim_speed = 10

        self.server = None

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        super()._on_keyboard_down(keyboard, keycode, text, modifiers)

        # Press arrow keys to switch pages
        if keycode[1] in ['right', 'left'] and self.name == screen_manager.current_screen.name:
            self.switch_page(keycode[1])

    def generate_menu(self, **kwargs):
        self.server = constants.server_manager.current_server

        # Return if no free space
        if disk_popup('ServerViewScreen', telepath_data=self.server._telepath_data):
            return

        # Scroll list
        scroll_widget = ScrollViewWidget(position=(0.5, 0.5))
        scroll_anchor = AnchorLayout()
        self.scroll_layout = GridLayout(cols=1, spacing=15, size_hint_max_x=1250, size_hint_y=None, padding=[0, 30, 0, 30])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 1.85
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1
            self.anim_speed = 13 if Window.width > grid_layout.size_hint_max_x else 10

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, self.scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        self.scroll_layout.bind(minimum_height=self.scroll_layout.setter('height'))
        self.scroll_layout.id = 'scroll_content'


        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.775}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.25}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60))

        # Generate buttons on page load
        addon_count = len(self.server.addon.return_single_list())
        very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["very-bold"])
        header_content = f"{constants.translate('Installed Add-ons')}  [color=#494977]-[/color]  " + (f'[color=#6A6ABA]{constants.translate("No items")}[/color]' if addon_count == 0 else f'[font={very_bold_font}]1[/font] {constants.translate("item")}' if addon_count == 1 else f'[font={very_bold_font}]{addon_count}[/font] {constants.translate("items")}')
        self.header = HeaderText(header_content, '', (0, 0.9), __translate__ = (False, True), no_line=True)

        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(self.header)


        # Add blank label to the center, then load self.gen_search_results()
        self.blank_label = Label()
        self.blank_label.text = "Import or Download add-ons below"
        self.blank_label.font_name = os.path.join(constants.gui_assets, 'fonts', constants.fonts['italic'])
        self.blank_label.pos_hint = {"center_x": 0.5, "center_y": 0.55}
        self.blank_label.font_size = sp(24)
        self.blank_label.color = (0.6, 0.6, 1, 0.35)
        float_layout.add_widget(self.blank_label)

        search_function = self.server.addon.filter_addons
        self.search_bar = search_input(return_function=search_function, server_info=None, pos_hint={"center_x": 0.5, "center_y": 0.845}, allow_empty=True)
        self.page_switcher = PageSwitcher(0, 0, (0.5, 0.86), self.switch_page)


        # Append scroll view items
        scroll_anchor.add_widget(self.scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)
        float_layout.add_widget(self.search_bar)
        float_layout.add_widget(self.page_switcher)

        bottom_buttons = RelativeLayout()
        bottom_buttons.size_hint_max_x = 312
        bottom_buttons.pos_hint = {"center_x": 0.5, "center_y": 0.5}
        bottom_buttons.add_widget(MainButton('Import', (0, 0.202), 'download-outline.png', width=300, icon_offset=-115, auto_adjust_icon=True))
        bottom_buttons.add_widget(MainButton('Download', (1, 0.202), 'cloud-download-outline.png', width=300, icon_offset=-115, auto_adjust_icon=True))
        buttons.append(ExitButton('Back', (0.5, -1), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)
        float_layout.add_widget(bottom_buttons)

        menu_name = f"{self.server.name}, Add-ons"
        float_layout.add_widget(generate_title(f"Add-on Manager: '{self.server.name}'"))
        float_layout.add_widget(generate_footer(menu_name))


        # Buttons in the top right corner
        def update_addons(*a):
            screen_manager.current = 'ServerAddonUpdateScreen'

        if addon_count > 0:
            position = (70 if self.server._telepath_data else 125, 110)
            vertical_offset = 0 if self.server._telepath_data else 50
            if not self.server.addon.update_required:
                self.server._view_notif('add-ons', False)
                float_layout.add_widget(IconButton('up to date', {}, position, (None, None), 'checkmark-sharp.png', clickable=False, anchor='right', click_func=update_addons, text_offset=(0, vertical_offset)))
            else:
                self.server._view_notif('add-ons', viewed='update')
                float_layout.add_widget(IconButton('update add-ons', {}, position, (None, None), 'arrow-update.png', clickable=True, anchor='right', click_func=update_addons, force_color=[[(0.05, 0.08, 0.07, 1), (0.5, 0.9, 0.7, 1)], 'green'], text_offset=(12, vertical_offset)))

        if not self.server._telepath_data:
            def open_dir(*a):
                constants.folder_check(self.server.addon.addon_path)
                constants.open_folder(self.server.addon.addon_path)
            float_layout.add_widget(IconButton('open directory', {}, (70, 110), (None, None), 'folder.png', anchor='right', click_func=open_dir, text_offset=(10, 0)))


        self.add_widget(float_layout)


        # Add ManuTaskbar
        self.menu_taskbar = MenuTaskbar(selected_item='add-ons')
        self.add_widget(self.menu_taskbar)


        # Automatically generate results (installed add-ons) on page load
        addon_manager = constants.server_manager.current_server.addon
        addon_list = [addon for addon in addon_manager.return_single_list() if not addons.is_geyser_addon(addon)]

        self.gen_search_results(addon_list)

        # Show banner if server is running
        if addon_manager._hash_changed():
            Clock.schedule_once(
                functools.partial(
                    self.show_banner,
                    (0.937, 0.831, 0.62, 1),
                    f"A server restart is required to apply changes",
                    "sync.png",
                    3,
                    {"center_x": 0.5, "center_y": 0.965}
                ), 0
            )

        # Show banner if updates are available
        elif constants.server_manager.current_server.addon.update_required and not constants.server_manager.current_server.addon._update_notified:
            constants.server_manager.current_server.addon._update_notified = True
            Clock.schedule_once(
                functools.partial(
                    self.show_banner,
                    (0.553, 0.902, 0.675, 1),
                    f"Add-on updates are available",
                    "arrow-up-circle-sharp.png",
                    2.5,
                    {"center_x": 0.5, "center_y": 0.965}
                ), 0
            )

class ServerAddonSearchScreen(MenuBackground):

    def switch_page(self, direction):

        if self.max_pages == 1:
            return

        if direction == "right":
            if self.current_page == self.max_pages:
                self.current_page = 1
            else:
                self.current_page += 1

        else:
            if self.current_page == 1:
                self.current_page = self.max_pages
            else:
                self.current_page -= 1

        self.page_switcher.update_index(self.current_page, self.max_pages)
        self.gen_search_results(self.last_results)

    def gen_search_results(self, results, new_search=False, *args):
        addon_manager = constants.server_manager.current_server.addon

        # Error on failure
        if not results and isinstance(results, bool):
            self.show_popup(
                "warning",
                "Server Error",
                "There was an issue reaching the add-on repository\n\nPlease try again later",
                None
            )
            self.max_pages = 0
            self.current_page = 0

        # On success, rebuild results
        else:

            # Update page counter
            self.last_results = results
            self.max_pages = (len(results) / self.page_size).__ceil__()
            self.current_page = 1 if self.current_page == 0 or new_search else self.current_page

            self.page_switcher.update_index(self.current_page, self.max_pages)
            page_list = results[(self.page_size * self.current_page) - self.page_size:self.page_size * self.current_page]

            self.scroll_layout.clear_widgets()


            # Generate header
            addon_count = len(results)
            very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["very-bold"])
            search_text = self.search_bar.previous_search if (len(self.search_bar.previous_search) <= 25) else self.search_bar.previous_search[:22] + "..."
            header_content = f"{constants.translate('Search for')} '{search_text}'  [color=#494977]-[/color]  " + (f'[color=#6A6ABA]{constants.translate("No results")}[/color]' if addon_count == 0 else f'[font={very_bold_font}]1[/font] {constants.translate("item")}' if addon_count == 1 else f'[font={very_bold_font}]{addon_count:,}[/font] {constants.translate("items")}')

            for child in self.header.children:
                if child.id == "text":
                    child.text = header_content
                    break


            # If there are no addons, say as much with a label
            if addon_count == 0:
                self.blank_label.text = "there are no items to display"
                constants.hide_widget(self.blank_label, False)
                self.blank_label.opacity = 0
                Animation(opacity=1, duration=0.2).start(self.blank_label)
                self.max_pages = 0
                self.current_page = 0

            # If there are addons, display them here
            else:
                constants.hide_widget(self.blank_label, True)

                # Create list of addon names
                installed_addon_names = [addon.name for addon in addon_manager.return_single_list()]

                # Clear and add all addons
                for x, addon_object in enumerate(page_list, 1):


                    # Function to download addon info
                    def load_addon(addon, index):
                        try:
                            selected_button = [item for item in self.scroll_layout.walk() if item.__class__.__name__ == "AddonButton"][index-1]

                            # Cache updated addon info into button, or skip if it's already cached
                            if selected_button.properties:
                                if not selected_button.properties.versions or not selected_button.properties.description:
                                    new_addon_info = addons.get_addon_info(addon, constants.server_manager.current_server.properties_dict())
                                    selected_button.properties = new_addon_info

                            Clock.schedule_once(functools.partial(selected_button.loading, False), 1)

                            return selected_button.properties, selected_button.installed

                        # Don't crash if add-on failed to load
                        except:
                            Clock.schedule_once(
                                functools.partial(
                                    screen_manager.current_screen.show_banner,
                                    (1, 0.5, 0.65, 1),
                                    f"Failed to load add-on",
                                    "close-circle-sharp.png",
                                    2.5,
                                    {"center_x": 0.5, "center_y": 0.965}
                                ), 0
                            )


                    # Function to install addon
                    def install_addon(index):

                        selected_button = [item for item in self.scroll_layout.walk() if item.__class__.__name__ == "AddonButton"][index-1]
                        addon = selected_button.properties
                        selected_button.toggle_installed(not selected_button.installed)

                        if len(addon.name) < 26:
                            addon_name = addon.name
                        else:
                            addon_name = addon.name[:23] + "..."

                        # Install
                        if selected_button.installed:
                            threading.Timer(0, functools.partial(addon_manager.download_addon, addon)).start()

                            # Show banner if server is running
                            if addon_manager._hash_changed():
                                Clock.schedule_once(
                                    functools.partial(
                                        self.show_banner,
                                        (0.937, 0.831, 0.62, 1),
                                        f"A server restart is required to apply changes",
                                        "sync.png",
                                        3,
                                        {"center_x": 0.5, "center_y": 0.965}
                                    ), 0
                                )

                            else:
                                Clock.schedule_once(
                                    functools.partial(
                                        self.show_banner,
                                        (0.553, 0.902, 0.675, 1),
                                        f"Installed '${addon_name}$'",
                                        "checkmark-circle-sharp.png",
                                        2.5,
                                        {"center_x": 0.5, "center_y": 0.965}
                                    ), 0.25
                                )

                        # Uninstall
                        else:
                            for installed_addon in addon_manager.return_single_list():
                                if installed_addon.name == addon.name:
                                    addon_manager.delete_addon(installed_addon)

                                    # Show banner if server is running
                                    if addon_manager._hash_changed():
                                        Clock.schedule_once(
                                            functools.partial(
                                                self.show_banner,
                                                (0.937, 0.831, 0.62, 1),
                                                f"A server restart is required to apply changes",
                                                "sync.png",
                                                3,
                                                {"center_x": 0.5, "center_y": 0.965}
                                            ), 0
                                        )

                                    else:
                                        Clock.schedule_once(
                                            functools.partial(
                                                self.show_banner,
                                                (1, 0.5, 0.65, 1),
                                                f"'${addon_name}$' was uninstalled",
                                                "trash-sharp.png",
                                                2.5,
                                                {"center_x": 0.5, "center_y": 0.965}
                                            ), 0.25
                                        )

                                    break

                        return addon, selected_button.installed


                    # Activated when addon is clicked
                    def view_addon(addon, index, *args):
                        selected_button = [item for item in self.scroll_layout.walk() if item.__class__.__name__ == "AddonButton"][index - 1]

                        selected_button.loading(True)

                        Clock.schedule_once(
                            functools.partial(
                                self.show_popup,
                                "addon",
                                " ",
                                " ",
                                (None, functools.partial(install_addon, index)),
                                functools.partial(load_addon, addon, index)
                            ),
                            0
                        )


                    # Add-on button click function
                    self.scroll_layout.add_widget(
                        ScrollItem(
                            widget = AddonButton(
                                properties = addon_object,
                                installed = addon_object.name in installed_addon_names,
                                fade_in = ((x if x <= 8 else 8) / self.anim_speed),
                                click_function = functools.partial(
                                    view_addon,
                                    addon_object,
                                    x
                                )
                            )
                        )
                    )

                self.resize_bind()
                self.scroll_layout.parent.parent.scroll_y = 1

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.header = None
        self.scroll_layout = None
        self.blank_label = None
        self.search_bar = None
        self.page_switcher = None

        self.last_results = []
        self.page_size = 20
        self.current_page = 0
        self.max_pages = 0
        self.anim_speed = 10

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        super()._on_keyboard_down(keyboard, keycode, text, modifiers)

        # Press arrow keys to switch pages
        if keycode[1] in ['right', 'left'] and self.name == screen_manager.current_screen.name:
            self.switch_page(keycode[1])
        elif keycode[1] == "tab" and self.name == screen_manager.current_screen.name:
            for widget in self.search_bar.children:
                try:
                    if widget.id == "search_input":
                        widget.grab_focus()
                        break
                except AttributeError:
                    pass

    def generate_menu(self, **kwargs):

        # Scroll list
        scroll_widget = ScrollViewWidget(position=(0.5, 0.437))
        scroll_anchor = AnchorLayout()
        self.scroll_layout = GridLayout(cols=1, spacing=15, size_hint_max_x=1250, size_hint_y=None, padding=[0, 30, 0, 30])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 1.79
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1
            self.anim_speed = 13 if Window.width > grid_layout.size_hint_max_x else 10

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, self.scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        self.scroll_layout.bind(minimum_height=self.scroll_layout.setter('height'))
        self.scroll_layout.id = 'scroll_content'

        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.715}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.17}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60))

        # Generate buttons on page load
        addon_count = 0
        very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["very-bold"])
        header_content = constants.translate("Add-on Search")
        self.header = HeaderText(header_content, '', (0, 0.89), __translate__ = (False, True))

        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(self.header)

        # Add blank label to the center
        self.blank_label = Label()
        self.blank_label.text = "search for add-ons above"
        self.blank_label.font_name = os.path.join(constants.gui_assets, 'fonts', constants.fonts['italic'])
        self.blank_label.pos_hint = {"center_x": 0.5, "center_y": 0.48}
        self.blank_label.font_size = sp(24)
        self.blank_label.color = (0.6, 0.6, 1, 0.35)
        float_layout.add_widget(self.blank_label)

        server_obj = constants.server_manager.current_server
        search_function = server_obj.addon.search_addons
        self.search_bar = search_input(return_function=search_function, server_info=server_obj.properties_dict(), pos_hint={"center_x": 0.5, "center_y": 0.795})
        self.page_switcher = PageSwitcher(0, 0, (0.5, 0.805), self.switch_page)


        # Append scroll view items
        scroll_anchor.add_widget(self.scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)
        float_layout.add_widget(self.search_bar)
        float_layout.add_widget(self.page_switcher)

        buttons.append(ExitButton('Back', (0.5, 0.12), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        server_name = constants.server_manager.current_server.name
        menu_name = f"{server_name}, Add-ons, Download"
        float_layout.add_widget(generate_title(f"Add-on Manager: '{server_name}'"))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)

        # Autofocus search bar
        for widget in self.search_bar.children:
            try:
                if widget.id == "search_input":
                    widget.grab_focus()
                    break
            except AttributeError:
                pass



# amscript Manager ------------------------------------------------------------------------------------------------

constants.script_obj = amscript.ScriptObject()
def edit_script(edit_button, server_obj, script_path, download=True):
    "amscript-icon.png"

    # Override to download locally
    telepath_data = None
    telepath_script_dir = constants.telepathScriptDir
    if server_obj._telepath_data:
        telepath_data = constants.deepcopy(server_obj._telepath_data)
        telepath_data['headers'] = constants.api_manager._get_headers(telepath_data['host'], True)
        if download:
            script_path = constants.telepath_download(server_obj._telepath_data, script_path, os.path.join(constants.telepathScriptDir, server_obj._telepath_data['host']))

    # Update Discord rich presence
    constants.discord_presence.update_presence(f"amscript IDE > Editing '{os.path.basename(script_path)}'")

    constants.app_config.load_config()

    # Passed to child IDE window
    data_dict = {
        '_telepath_data': telepath_data,
        'app_title': constants.app_title,
        'ams_version': constants.ams_version,
        'gui_assets': constants.gui_assets,
        'cache_dir': constants.cacheDir,
        'background_color': constants.background_color,
        'app_config': constants.app_config,
        'script_obj': {
            'syntax_func': constants.script_obj.is_valid,
            'protected': constants.script_obj.protected_variables,
            'events': constants.script_obj.valid_events
        },
        'suggestions': server_obj._retrieve_suggestions(),
        'os_name': constants.os_name,
        'translate': constants.translate,
        'telepath_script_dir': telepath_script_dir,
    }

    # Passed to parent IPC receiver
    ipc_functions = {
        'api_manager': constants.api_manager,
        'telepath_upload': constants.telepath_upload
    }

    Clock.schedule_once(functools.partial(amseditor.edit_script, script_path, data_dict, ipc_functions), 0.1)
    if edit_button:
        edit_button.on_leave()
        edit_button.on_release()

class ScriptButton(HoverButton):

    def toggle_installed(self, installed, *args):
        self.installed = installed
        self.install_image.opacity = 1 if installed and not self.show_type else 0
        self.install_label.opacity = 1 if installed and not self.show_type else 0
        self.title.text_size = (self.size_hint_max[0] * (0.7 if installed else 0.94), self.size_hint_max[1])
        self.background_normal = os.path.join(constants.gui_assets, f'{self.id}{"_installed" if self.installed and not self.show_type else ""}.png')
        self.resize_self()

    def animate_addon(self, image, color, **kwargs):
        image_animate = Animation(duration=0.05)

        def f(w):
            w.background_normal = image

        Animation(color=color, duration=0.06).start(self.title)
        Animation(color=color, duration=0.06).start(self.subtitle)

        a = Animation(duration=0.0)
        a.on_complete = functools.partial(f)

        image_animate += a

        image_animate.start(self)

    def resize_self(self, *args):

        # Title and description
        padding = 2.17
        self.title.pos = (self.x + (self.title.text_size[0] / padding) - (6 if self.installed else 0), self.y + 31)
        self.subtitle.pos = (self.x + (self.subtitle.text_size[0] / padding) - 1, self.y)

        # Install label
        self.install_image.pos = (self.width + self.x - self.install_label.width - 28, self.y + 38.5)
        self.install_label.pos = (self.width + self.x - self.install_label.width - 30, self.y + 5)

        # Type Banner
        if self.show_type:
            self.type_banner.pos_hint = {"center_x": None, "center_y": None}
            self.type_banner.pos = (self.width + self.x - self.type_banner.width - 18, self.y + 38.5)

        # self.version_label.x = self.width+self.x-(self.padding_x[0]*offset)
        # self.version_label.y = self.y-(self.padding_y[0]*0.85)

    def __init__(self, properties, click_function=None, installed=False, show_type=False, fade_in=0.0, **kwargs):
        properties.name = properties.title
        properties.subtitle = properties.description

        super().__init__(**kwargs)

        self.installed = False
        self.show_type = show_type
        self.properties = properties
        self.border = (-5, -5, -5, -5)
        self.color_id = [(0.05, 0.05, 0.1, 1), (0.65, 0.65, 1, 1)]
        self.pos_hint = {"center_x": 0.5, "center_y": 0.6}
        self.size_hint_max = (580, 80)
        self.id = "addon_button"
        self.background_normal = os.path.join(constants.gui_assets, f'{self.id}.png')
        self.background_down = os.path.join(constants.gui_assets, f'{self.id}_click.png')


        # Loading stuffs
        self.original_subtitle = self.properties.subtitle if self.properties.subtitle else "Description unavailable"
        if "\n" in self.original_subtitle:
            self.original_subtitle = self.original_subtitle.split("\n", 1)[0].strip()
        self.original_font = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["regular"]}.ttf')


        # Title of Script
        self.title = Label()
        self.title.__translate__ = False
        self.title.id = "title"
        self.title.halign = "left"
        self.title.color = self.color_id[1]
        self.title.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
        self.title.font_size = sp(25)
        self.title.text_size = (self.size_hint_max[0] * 0.94, self.size_hint_max[1])
        self.title.shorten = True
        self.title.markup = True
        self.title.shorten_from = "right"
        self.title.max_lines = 1
        self.title.text = f"{self.properties.name}  [color=#434368]-[/color]  {self.properties.author if self.properties.author else 'Unknown'}"
        self.add_widget(self.title)


        # Description of Script
        self.subtitle = Label()
        self.subtitle.__translate__ = False
        self.subtitle.id = "subtitle"
        self.subtitle.halign = "left"
        self.subtitle.color = self.color_id[1]
        self.subtitle.font_name = self.original_font
        self.subtitle.font_size = sp(21)
        self.subtitle.opacity = 0.56
        self.subtitle.text_size = (self.size_hint_max[0] * 0.91, self.size_hint_max[1])
        self.subtitle.shorten = True
        self.subtitle.shorten_from = "right"
        self.subtitle.max_lines = 1
        self.subtitle.text = self.original_subtitle
        self.add_widget(self.subtitle)


        # Installed layout
        self.install_image = Image()
        self.install_image.size = (110, 30)
        self.install_image.keep_ratio = False
        self.install_image.allow_stretch = True
        self.install_image.source = os.path.join(constants.gui_assets, 'installed.png')
        self.install_image.opacity = 0
        self.add_widget(self.install_image)

        self.install_label = AlignLabel()
        self.install_label.halign = "right"
        self.install_label.valign = "middle"
        self.install_label.font_size = sp(18)
        self.install_label.color = self.color_id[1]
        self.install_label.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
        self.install_label.width = 100
        self.install_label.color = (0.05, 0.08, 0.07, 1)
        self.install_label.text = 'installed'
        self.install_label.opacity = 0
        self.add_widget(self.install_label)


        # Type Banner
        if show_type:
            self.type_banner = show_type
            self.add_widget(self.type_banner)


        # If self.installed is false, and self.properties.version, display version where "installed" logo is
        self.bind(pos=self.resize_self)
        if installed:
            self.toggle_installed(installed)

        # If click_function
        if click_function:
            self.bind(on_press=click_function)

        # Animate opacity
        if fade_in > 0:
            self.opacity = 0
            self.install_label.opacity = 0
            self.install_image.opacity = 0
            self.title.opacity = 0

            Animation(opacity=1, duration=fade_in).start(self)
            Animation(opacity=1, duration=fade_in).start(self.title)
            Animation(opacity=0.56, duration=fade_in).start(self.subtitle)

            if installed and not self.show_type:
                Animation(opacity=1, duration=fade_in).start(self.install_label)
                Animation(opacity=1, duration=fade_in).start(self.install_image)

    def on_enter(self, *args):
        if not self.ignore_hover:
            self.animate_addon(image=os.path.join(constants.gui_assets, f'{self.id}_hover.png'), color=self.color_id[0], hover_action=True)

    def on_leave(self, *args):
        if not self.ignore_hover:
            self.animate_addon(image=os.path.join(constants.gui_assets, f'{self.id}{"_installed" if self.installed and not self.show_type else ""}.png'), color=self.color_id[1], hover_action=False)

    def loading(self, load_state, *args):
        if load_state:
            self.subtitle.text = "Loading script info..."
            self.subtitle.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
        else:
            self.subtitle.text = self.original_subtitle
            self.subtitle.font_name = self.original_font

class AmscriptListButton(HoverButton):

    def toggle_enabled(self, *args):
        self.title.text_size = (self.size_hint_max[0] * (0.94 if self.enabled else 0.7), self.size_hint_max[1])
        self.background_normal = os.path.join(constants.gui_assets, f'{self.id}{"" if self.enabled else "_disabled"}.png')

        # If disabled, add banner as such
        if not self.enabled:
            self.disabled_banner = BannerObject(
                pos_hint = {"center_x": 0.5, "center_y": 0.5},
                size = (125, 32),
                color = (1, 0.53, 0.58, 1),
                text = "disabled",
                icon = "close-circle.png",
                icon_side = "right"
            )
            self.add_widget(self.disabled_banner)

        self.resize_self()

    def animate_script(self, image, color, **kwargs):
        image_animate = Animation(duration=0.05)

        def f(w):
            w.background_normal = image

        Animation(color=color, duration=0.06).start(self.title)
        Animation(color=color, duration=0.06).start(self.subtitle)

        a = Animation(duration=0.0)
        a.on_complete = functools.partial(f)

        image_animate += a

        image_animate.start(self)

    def resize_self(self, *args):

        # Title and description
        padding = 2.17
        self.title.pos = (self.x + (self.title.text_size[0] / padding) - (6 if self.disabled_banner else 0), self.y + 31)
        self.subtitle.pos = (self.x + (self.subtitle.text_size[0] / padding) - 1, self.y)
        self.hover_text.pos = (self.x + (self.size[0] / padding) - 30, self.y + 15)

        # Type Banner
        if self.disabled_banner:
            self.disabled_banner.pos_hint = {"center_x": None, "center_y": None}
            self.disabled_banner.pos = (self.width + self.x - self.disabled_banner.width - 18, self.y + 38.5)

        # Delete button
        self.delete_layout.size_hint_max = (self.size_hint_max[0], self.size_hint_max[1])
        self.delete_layout.pos = (self.pos[0] + self.width - (self.delete_button.width / 1.33), self.pos[1] + 13)

        # Reposition highlight border
        self.highlight_layout.pos = self.pos

    def highlight(self):
        def next_frame(*args):
            Animation.stop_all(self.highlight_border)
            self.highlight_border.opacity = 1
            Animation(opacity=0, duration=0.7).start(self.highlight_border)

        Clock.schedule_once(next_frame, 0)

    def on_enter(self, *args):
        if not self.ignore_hover:

            # Hide disabled banner if it exists
            if self.disabled_banner:
                Animation.stop_all(self.disabled_banner)
                Animation(opacity=0, duration=0.13).start(self.disabled_banner)

            # Fade button to hover state
            if not self.delete_button.button.hovered:
                self.animate_script(image=os.path.join(constants.gui_assets, f'{self.id}_hover_{"dis" if self.enabled else "en"}abled.png'), color=self.color_id[0], hover_action=True)

            # Show delete button
            Animation.stop_all(self.delete_layout)
            Animation(opacity=1, duration=0.13).start(self.delete_layout)

            # Hide text
            Animation(opacity=0, duration=0.13).start(self.title)
            Animation(opacity=0, duration=0.13).start(self.subtitle)
            Animation(opacity=1, duration=0.13).start(self.hover_text)

    def on_leave(self, *args):
        if not self.ignore_hover:

            # Hide disabled banner if it exists
            if self.disabled_banner:
                Animation.stop_all(self.disabled_banner)
                Animation(opacity=1, duration=0.13).start(self.disabled_banner)

            # Fade button to default state
            self.animate_script(image=os.path.join(constants.gui_assets, f'{self.id}{"" if self.enabled else "_disabled"}.png'), color=self.color_id[1], hover_action=False)

            # Hide delete button
            Animation.stop_all(self.delete_layout)
            Animation(opacity=0, duration=0.13).start(self.delete_layout)

            # Show text
            Animation(opacity=1, duration=0.13).start(self.title)
            Animation(opacity=self.default_subtitle_opacity, duration=0.13).start(self.subtitle)
            Animation(opacity=0, duration=0.13).start(self.hover_text)

    def loading(self, load_state, *args):
        if load_state:
            self.subtitle.text = "Loading script info..."
            self.subtitle.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
        else:
            self.subtitle.text = self.original_subtitle
            self.subtitle.font_name = self.original_font

    def __init__(self, properties, click_function=None, enabled=False, fade_in=0.0, highlight=False, **kwargs):

        properties.name = properties.title
        properties.subtitle = properties.description

        super().__init__(**kwargs)

        self.enabled = enabled
        self.properties = properties
        self.border = (-5, -5, -5, -5)
        self.color_id = [(0.05, 0.05, 0.1, 1), (0.65, 0.65, 1, 1)] if self.enabled else [(0.05, 0.1, 0.1, 1), (1, 0.6, 0.7, 1)]
        self.pos_hint = {"center_x": 0.5, "center_y": 0.6}
        self.size_hint_max = (580, 80)
        self.id = "addon_button"
        self.background_normal = os.path.join(constants.gui_assets, f'{self.id}.png')
        self.background_down = self.background_normal
        self.disabled_banner = None


        if self.enabled:

            # Edit button
            def edit_hover(*args):
                def change_color(*args):
                    if self.hovered:
                        self.hover_text.text = 'EDIT SCRIPT'
                        self.background_normal = os.path.join(constants.gui_assets, "server_button_hover.png")
                Clock.schedule_once(change_color, 0.07)
                Animation.stop_all(self.delete_button)
                Animation(opacity=1, duration=0.25).start(self.delete_button)
            def edit_on_leave(*args):
                def change_color(*args):
                    self.hover_text.text = ('DISABLE SCRIPT' if self.enabled else 'ENABLE SCRIPT')
                    if self.hovered:
                        self.background_normal = os.path.join(constants.gui_assets, f'{self.id}_hover_{"dis" if self.enabled else "en"}abled.png')
                        self.background_down = self.background_normal
                Clock.schedule_once(change_color, 0.07)
                Animation.stop_all(self.delete_button)
                Animation(opacity=0.65, duration=0.25).start(self.delete_button)
            def edit_click(*args):
                # Delete addon and reload list
                def reprocess_page(*args):
                    server_obj = constants.server_manager.current_server
                    script_manager = server_obj.script_manager
                    edit_script(self, server_obj, self.properties.path)


                    # Show banner if server is running
                    if script_manager._hash_changed():
                        Clock.schedule_once(
                            functools.partial(
                                screen_manager.current_screen.show_banner,
                                (0.937, 0.831, 0.62, 1),
                                "An amscript reload is required to apply changes",
                                "sync.png",
                                3,
                                {"center_x": 0.5, "center_y": 0.965}
                            ), 0
                        )

                Clock.schedule_once(functools.partial(reprocess_page), 0)
            self.delete_layout = RelativeLayout(opacity=0)
            self.delete_button = IconButton('', {}, (0, 0), (None, None), 'edit-sharp.png', clickable=True, force_color=[[(0.05, 0.05, 0.1, 1), (0.01, 0.01, 0.01, 1)], ''], anchor='right', click_func=edit_click)
            self.delete_button.opacity = 0.65
            self.delete_button.button.bind(on_enter=edit_hover)
            self.delete_button.button.bind(on_leave=edit_on_leave)
            self.delete_layout.add_widget(self.delete_button)
            self.add_widget(self.delete_layout)

        else:

            # Delete button
            def delete_hover(*args):
                def change_color(*args):
                    if self.hovered:
                        self.hover_text.text = 'UNINSTALL SCRIPT'
                        self.background_normal = os.path.join(constants.gui_assets, "server_button_favorite_hover.png")
                Clock.schedule_once(change_color, 0.07)
                Animation.stop_all(self.delete_button)
                Animation(opacity=1, duration=0.25).start(self.delete_button)
            def delete_on_leave(*args):
                def change_color(*args):
                    self.hover_text.text = ('DISABLE SCRIPT' if self.enabled else 'ENABLE SCRIPT')
                    if self.hovered:
                        self.background_normal = os.path.join(constants.gui_assets, f'{self.id}_hover_{"dis" if self.enabled else "en"}abled.png')
                        self.background_down = self.background_normal
                Clock.schedule_once(change_color, 0.07)
                Animation.stop_all(self.delete_button)
                Animation(opacity=0.65, duration=0.25).start(self.delete_button)
            def delete_click(*args):
                # Delete addon and reload list
                def reprocess_page(*args):
                    script_manager = constants.server_manager.current_server.script_manager
                    script_manager.delete_script(self.properties)
                    constants.clear_script_cache(self.properties.path)
                    script_screen = screen_manager.current_screen
                    new_list = script_manager.return_single_list()
                    script_screen.gen_search_results(new_list, fade_in=True)
                    Clock.schedule_once(functools.partial(script_screen.search_bar.execute_search, script_screen.search_bar.previous_search), 0)

                    # Show banner if server is running
                    if script_manager._hash_changed():
                        Clock.schedule_once(
                            functools.partial(
                                screen_manager.current_screen.show_banner,
                                (0.937, 0.831, 0.62, 1),
                                "An amscript reload is required to apply changes",
                                "sync.png",
                                3,
                                {"center_x": 0.5, "center_y": 0.965}
                            ), 0
                        )

                    else:
                        Clock.schedule_once(
                            functools.partial(
                                screen_manager.current_screen.show_banner,
                                (1, 0.5, 0.65, 1),
                                f"'${self.properties.name}$' was uninstalled",
                                "trash-sharp.png",
                                2.5,
                                {"center_x": 0.5, "center_y": 0.965}
                            ), 0
                        )

                    # Switch pages if page is empty
                    if (len(script_screen.scroll_layout.children) == 0) and (len(new_list) > 0):
                        script_screen.switch_page("left")

                Clock.schedule_once(
                    functools.partial(
                        screen_manager.current_screen.show_popup,
                        "warning_query",
                        f'Uninstall ${self.properties.name}$',
                        "Uninstalling this script will render it unavailable for every server.\n\nDo you want to permanently uninstall this script?",
                        (None, functools.partial(reprocess_page))
                    ),
                    0
                )
            self.delete_layout = RelativeLayout(opacity=0)
            self.delete_button = IconButton('', {}, (0, 0), (None, None), 'trash-sharp.png', clickable=True, force_color=[[(0.05, 0.05, 0.1, 1), (0.01, 0.01, 0.01, 1)], 'pink'], anchor='right', click_func=delete_click)
            self.delete_button.opacity = 0.65
            self.delete_button.button.bind(on_enter=delete_hover)
            self.delete_button.button.bind(on_leave=delete_on_leave)
            self.delete_layout.add_widget(self.delete_button)
            self.add_widget(self.delete_layout)


        # Hover text
        self.hover_text = Label()
        self.hover_text.id = 'hover_text'
        self.hover_text.size_hint = (None, None)
        self.hover_text.pos_hint = {"center_x": 0.5, "center_y": 0.5}
        self.hover_text.text = ('DISABLE SCRIPT' if self.enabled else 'ENABLE SCRIPT')
        self.hover_text.font_size = sp(23)
        self.hover_text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["bold"]}.ttf')
        self.hover_text.color = (0.1, 0.1, 0.1, 1)
        self.hover_text.halign = "center"
        self.hover_text.text_size = (self.size_hint_max[0] * 0.94, self.size_hint_max[1])
        self.hover_text.opacity = 0
        self.add_widget(self.hover_text)


        # Loading stuffs
        self.original_subtitle = self.properties.subtitle if self.properties.subtitle else "Description unavailable"
        self.original_font = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["regular"]}.ttf')


        # Title of Script
        self.title = Label()
        self.title.__translate__ = False
        self.title.id = "title"
        self.title.halign = "left"
        self.title.color = self.color_id[1]
        self.title.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
        self.title.font_size = sp(25)
        self.title.text_size = (self.size_hint_max[0] * (0.94), self.size_hint_max[1])
        self.title.shorten = True
        self.title.markup = True
        self.title.shorten_from = "right"
        self.title.max_lines = 1
        self.title.text = f"{self.properties.name}{('  [color=#434368]-[/color]  ' + self.properties.author) if self.properties.author.lower().strip() != 'unknown' else ''}"
        self.add_widget(self.title)
        Clock.schedule_once(self.toggle_enabled, 0)


        # Description of Addon
        self.subtitle = Label()
        self.subtitle.__translate__ = False
        self.subtitle.id = "subtitle"
        self.subtitle.halign = "left"
        self.subtitle.color = self.color_id[1]
        self.subtitle.font_name = self.original_font
        self.subtitle.font_size = sp(21)
        self.default_subtitle_opacity = 0.56
        self.subtitle.opacity = self.default_subtitle_opacity
        self.subtitle.text_size = (self.size_hint_max[0] * 0.91, self.size_hint_max[1])
        self.subtitle.shorten = True
        self.subtitle.shorten_from = "right"
        self.subtitle.max_lines = 1
        self.subtitle.text = self.original_subtitle
        self.add_widget(self.subtitle)


        # Highlight border
        self.highlight_layout = RelativeLayout()
        self.highlight_border = Image()
        self.highlight_border.keep_ratio = False
        self.highlight_border.allow_stretch = True
        self.highlight_border.color = constants.brighten_color(self.color_id[1], 0.1)
        self.highlight_border.opacity = 0
        self.highlight_border.source = os.path.join(constants.gui_assets, 'server_button_highlight.png')
        self.highlight_layout.add_widget(self.highlight_border)
        self.highlight_layout.width = self.size_hint_max[0]
        self.highlight_layout.height = self.size_hint_max[1]
        self.add_widget(self.highlight_layout)

        if highlight:
            self.highlight()

        # If self.enabled is false, and self.properties.version, display version where "enabled" logo is
        self.bind(pos=self.resize_self)
        self.resize_self()

        # If click_function
        if click_function:
            self.bind(on_press=click_function)

        # Animate opacity
        if fade_in > 0:
            self.opacity = 0
            self.title.opacity = 0

            Animation(opacity=1, duration=fade_in).start(self)
            Animation(opacity=1, duration=fade_in).start(self.title)
            Animation(opacity=0.56, duration=fade_in).start(self.subtitle)

class CreateAmscriptScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.name_input = None
        self.create_button = None

    def generate_menu(self, **kwargs):
        # Generate buttons on page load
        server_obj = constants.server_manager.current_server

        def on_click(*a):
            script_name = self.name_input.convert_name(self.name_input.text)
            script_title = self.name_input.text.strip()

            if server_obj._telepath_data:
                script_path = os.path.join(constants.telepathScriptDir, script_name)
                constants.folder_check(constants.telepathScriptDir)
            else:
                script_path = os.path.join(constants.scriptDir, script_name)
                constants.folder_check(constants.scriptDir)

            contents = f"""#!
# title: {script_title}
# author: {constants.username.title()}
# version: 1.0
# description: 
#!



# {constants.translate('Welcome to the amscript IDE!')}
# {constants.translate('Right-click > Help to learn more about the capabilities of amscript')}

@player.on_join(player, message):
    if player not in server.usercache:
        player.log(f"{constants.translate('Welcome to')} {{server}} {{player}}!")
"""

            with open(script_path, 'w+', encoding='utf-8', errors='ignore') as f:
                f.write(contents)

            # Upload and import if it's remote
            if server_obj._telepath_data:
                server_obj.script_manager.import_script(script_path)

            for s in server_obj.script_manager.return_single_list():
                if s.file_name == script_name:
                    server_obj.script_manager.script_state(s, enabled=True)
                    break

            def later(*_):
                edit_script(None, server_obj, script_path, download=False)
            threading.Timer(1, later).start()

            previous_screen()
            del constants.screen_tree[-1]

            if server_obj.running:
                Clock.schedule_once(
                    functools.partial(
                        self.show_banner,
                        (0.937, 0.831, 0.62, 1),
                        "An amscript reload is required to apply changes",
                        "sync.png",
                        3,
                        {"center_x": 0.5, "center_y": 0.965}
                    ), 0
                )
            else:
                Clock.schedule_once(
                    functools.partial(
                        self.show_banner,
                        (0.553, 0.902, 0.675, 1),
                        f"'{script_name}' has been created",
                        "checkmark-circle-sharp.png",
                        2.5,
                        {"center_x": 0.5, "center_y": 0.965}
                    ), 0
                )

        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'

        float_layout.add_widget(InputLabel(pos_hint={"center_x": 0.5, "center_y": 0.58}))
        float_layout.add_widget(HeaderText("What would you like to name your script?", '', (0, 0.76)))
        self.name_input = ScriptNameInput(pos_hint={"center_x": 0.5, "center_y": 0.5})
        float_layout.add_widget(self.name_input)
        self.name_input.update_script_list(server_obj.script_manager.return_single_list())
        self.create_button = WaitButton('Create in IDE', (0.5, 0.24), 'amscript.png', width=370, icon_offset=-150, disabled=True, click_func=on_click)
        buttons.append(self.create_button)
        buttons.append(ExitButton('Back', (0.5, 0.14), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        menu_name = f"{server_obj.name}, amscript, Create script"
        float_layout.add_widget(generate_title(f"Script Manager: '{server_obj.name}'"))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)
        self.name_input.grab_focus()

class ServerAmscriptScreen(MenuBackground):

    def switch_page(self, direction):

        if self.max_pages == 1:
            return

        if direction == "right":
            if self.current_page == self.max_pages:
                self.current_page = 1
            else:
                self.current_page += 1

        else:
            if self.current_page == 1:
                self.current_page = self.max_pages
            else:
                self.current_page -= 1

        self.page_switcher.update_index(self.current_page, self.max_pages)
        self.gen_search_results(self.last_results)

    def gen_search_results(self, results, new_search=False, fade_in=True, highlight=None, animate_scroll=True, last_scroll=None, *args):

        # Update page counter
        # results = list(sorted(results, key=lambda d: d.name.lower()))
        # Set to proper page on toggle

        script_manager = constants.server_manager.current_server.script_manager
        default_scroll = 1
        if highlight:
            def divide_chunks(l, n):
                final_list = []

                for i in range(0, len(l), n):
                    final_list.append(l[i:i + n])

                return final_list

            for x, l in enumerate(divide_chunks([x.hash for x in results], self.page_size), 1):
                if highlight in l:
                    if self.current_page != x:
                        self.current_page = x

                    # Update scroll when page is bigger than list
                    if Window.height < self.scroll_layout.height * 1.7:
                        default_scroll = 1 - round(l.index(highlight) / len(l), 2)
                        if default_scroll < 0.21:
                            default_scroll = 0
                        if default_scroll > 0.97:
                            default_scroll = 1
                    break


        self.last_results = results
        self.max_pages = (len(results) / self.page_size).__ceil__()
        self.current_page = 1 if self.current_page == 0 or new_search else self.current_page

        self.page_switcher.update_index(self.current_page, self.max_pages)
        page_list = results[(self.page_size * self.current_page) - self.page_size:self.page_size * self.current_page]

        self.scroll_layout.clear_widgets()


        # Animate scrolling
        def set_scroll(*args):
            Animation.stop_all(self.scroll_layout.parent.parent)
            if animate_scroll:
                Animation(scroll_y=default_scroll, duration=0.1).start(self.scroll_layout.parent.parent)
            else:
                self.scroll_layout.parent.parent.scroll_y = default_scroll
        Clock.schedule_once(set_scroll, 0)


        # Generate header
        script_count = len(results)
        enabled_count = len(script_manager.installed_scripts['enabled'])
        disabled_count = len(script_manager.installed_scripts['disabled'])
        very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["very-bold"])
        header_content = f"{constants.translate('Installed Scripts')}  [color=#494977]-[/color]  " + (f'[color=#6A6ABA]{constants.translate("No items")}[/color]' if script_count == 0 else f'[font={very_bold_font}]1[/font] {constants.translate("item")}' if script_count == 1 else f'[font={very_bold_font}]{enabled_count:,}{("/[color=#FF8793]" + str(disabled_count) + "[/color]") if disabled_count > 0 else ""}[/font] {constants.translate("items")}')

        if script_manager._hash_changed():
            icons = os.path.join(constants.gui_assets, 'fonts', constants.fonts['icons'])
            header_content = f"[color=#EFD49E][font={icons}]y[/font] " + header_content + "[/color]"


        for child in self.header.children:
            if child.id == "text":
                child.text = header_content
                break


        # If there are no scripts, say as much with a label
        if script_count == 0:
            self.blank_label.text = "Import or Download Scripts Below"
            constants.hide_widget(self.blank_label, False)
            self.blank_label.opacity = 0
            Animation(opacity=1, duration=0.2).start(self.blank_label)
            self.max_pages = 0
            self.current_page = 0

        # If there are scripts, display them here
        else:
            constants.hide_widget(self.blank_label, True)

            # Clear and add all scripts
            for x, script_object in enumerate(page_list, 1):

                # Activated when script is clicked
                def toggle_script(index, *args):
                    script = index

                    if len(script.title) < 26:
                        script_name = script.title
                    else:
                        script_name = script.title[:23] + "..."


                    # Toggle script state
                    script_manager.script_state(script, enabled=not script.enabled)
                    self.gen_search_results(script_manager.return_single_list(), fade_in=False, highlight=script.hash, animate_scroll=True)

                    if constants.server_manager.current_server.script_manager._hash_changed():
                        Clock.schedule_once(
                            functools.partial(
                                self.show_banner,
                                (0.937, 0.831, 0.62, 1),
                                "An amscript reload is required to apply changes",
                                "sync.png",
                                3,
                                {"center_x": 0.5, "center_y": 0.965}
                            ), 0
                        )
                    else:
                        if script.enabled:
                            banner_text = f"'${script_name}$' is now disabled"
                        else:
                            banner_text = f"'${script_name}$' is now enabled"

                        Clock.schedule_once(
                            functools.partial(
                                self.show_banner,
                                (1, 0.5, 0.65, 1) if script.enabled else (0.553, 0.902, 0.675, 1),
                                banner_text,
                                "close-circle-sharp.png" if script.enabled else "checkmark-circle-sharp.png",
                                2.5,
                                {"center_x": 0.5, "center_y": 0.965}
                            ), 0
                        )


                # Script button click function
                self.scroll_layout.add_widget(
                    ScrollItem(
                        widget = AmscriptListButton(
                            properties = script_object,
                            enabled = script_object.enabled,
                            fade_in = ((x if x <= 8 else 8) / self.anim_speed) if fade_in else 0,
                            highlight = (highlight == script_object.hash),
                            click_function = functools.partial(
                                toggle_script,
                                script_object,
                                x
                            )
                        )
                    )
                )

            self.resize_bind()
            # self.scroll_layout.parent.parent.scroll_y = 1

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.header = None
        self.scroll_layout = None
        self.blank_label = None
        self.search_bar = None
        self.page_switcher = None
        self.menu_taskbar = None

        self.last_results = []
        self.page_size = 20
        self.current_page = 0
        self.max_pages = 0
        self.anim_speed = 10

        self.server = None
        self.reload_button = None
        self.directory_button = None
        self.path_button = None

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        super()._on_keyboard_down(keyboard, keycode, text, modifiers)

        # Press arrow keys to switch pages
        if keycode[1] in ['right', 'left'] and self.name == screen_manager.current_screen.name:
            self.switch_page(keycode[1])

    def generate_menu(self, **kwargs):
        self.server = constants.server_manager.current_server

        # Return if no free space
        if disk_popup('ServerViewScreen', telepath_data=self.server._telepath_data):
            return


        # Scroll list
        scroll_widget = ScrollViewWidget(position=(0.5, 0.5))
        scroll_anchor = AnchorLayout()
        self.scroll_layout = GridLayout(cols=1, spacing=15, size_hint_max_x=1250, size_hint_y=None, padding=[0, 30, 0, 30])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 1.85
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1
            self.anim_speed = 13 if Window.width > grid_layout.size_hint_max_x else 10

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, self.scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        self.scroll_layout.bind(minimum_height=self.scroll_layout.setter('height'))
        self.scroll_layout.id = 'scroll_content'


        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.775}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.25}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60))

        # Generate buttons on page load
        script_count = len(self.server.script_manager.return_single_list())
        very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["very-bold"])
        header_content = f"{constants.translate('Installed Scripts')}  [color=#494977]-[/color]  " + (f'[color=#6A6ABA]{constants.translate("No items")}[/color]' if script_count == 0 else f'[font={very_bold_font}]1[/font] {constants.translate("item")}' if script_count == 1 else f'[font={very_bold_font}]{script_count}[/font] {constants.translate("items")}')
        self.header = HeaderText(header_content, '', (0, 0.9), __translate__ = (False, True), no_line=True)

        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(self.header)


        # Add blank label to the center, then load self.gen_search_results()
        self.blank_label = Label()
        self.blank_label.text = "Manage scripts below"
        self.blank_label.font_name = os.path.join(constants.gui_assets, 'fonts', constants.fonts['italic'])
        self.blank_label.pos_hint = {"center_x": 0.5, "center_y": 0.55}
        self.blank_label.font_size = sp(24)
        self.blank_label.color = (0.6, 0.6, 1, 0.35)
        float_layout.add_widget(self.blank_label)

        search_function = self.server.script_manager.filter_scripts
        self.search_bar = search_input(return_function=search_function, server_info=None, pos_hint={"center_x": 0.5, "center_y": 0.845}, allow_empty=True)
        self.page_switcher = PageSwitcher(0, 0, (0.5, 0.86), self.switch_page)

        # Append scroll view items
        scroll_anchor.add_widget(self.scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)
        float_layout.add_widget(self.search_bar)
        float_layout.add_widget(self.page_switcher)

        bottom_buttons = RelativeLayout()
        bottom_buttons.size_hint_max_x = 512
        bottom_buttons.pos_hint = {"center_x": 0.5, "center_y": 0.5}
        bottom_buttons.add_widget(MainButton('Import', (0, 0.202), 'download-outline.png', width=245, icon_offset=-115, auto_adjust_icon=True))
        bottom_buttons.add_widget(MainButton('Create New', (0.5, 0.202), '', width=245, icon_offset=-115, auto_adjust_icon=False))
        bottom_buttons.add_widget(MainButton('Download', (1, 0.202), 'cloud-download-outline.png', width=245, icon_offset=-115, auto_adjust_icon=True))
        buttons.append(ExitButton('Back', (0.5, -1), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)
        float_layout.add_widget(bottom_buttons)

        menu_name = f"{self.server.name}, amscript"
        float_layout.add_widget(generate_title(f"Script Manager: '{self.server.name}'"))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)


        # Add ManuTaskbar
        self.menu_taskbar = MenuTaskbar(selected_item='amscript')
        self.add_widget(self.menu_taskbar)


        # Buttons in the top right corner
        def open_dir(*a):
            constants.folder_check(constants.scriptDir)
            constants.open_folder(constants.scriptDir)
        self.directory_button = IconButton('open directory', {}, (70, 110), (None, None), 'folder.png', anchor='right', click_func=open_dir, text_offset=(10, 0))
        float_layout.add_widget(self.directory_button)

        if self.server.running:
            def reload_scripts(*a):
                def timer():
                    self.server.reload_scripts()
                    Clock.schedule_once(
                        functools.partial(
                            self.show_banner,
                            (0.553, 0.902, 0.675, 1),
                            f"amscript engine was restarted successfully",
                            "checkmark-circle-sharp.png",
                            2.5,
                            {"center_x": 0.5, "center_y": 0.965}
                        ), 0
                    )
                    Clock.schedule_once(functools.partial(self.gen_search_results, self.server.script_manager.return_single_list()), 0)
                threading.Timer(0, timer).start()
            self.reload_button = IconButton('reload scripts', {}, (125, 110), (None, None), 'reload-sharp.png', clickable=self.server.running, anchor='right', click_func=reload_scripts, text_offset=(10, 50))
            float_layout.add_widget(self.reload_button)


        # Automatically generate results (installed scripts) on page load
        self.gen_search_results(self.server.script_manager.return_single_list())

        # Show banner if server is running
        if constants.server_manager.current_server.script_manager._hash_changed():
            Clock.schedule_once(
                functools.partial(
                    self.show_banner,
                    (0.937, 0.831, 0.62, 1),
                    "An amscript reload is required to apply changes",
                    "sync.png",
                    3,
                    {"center_x": 0.5, "center_y": 0.965}
                ), 0
            )

class ServerAmscriptSearchScreen(MenuBackground):

    def switch_page(self, direction):

        if self.max_pages == 1:
            return

        if direction == "right":
            if self.current_page == self.max_pages:
                self.current_page = 1
            else:
                self.current_page += 1

        else:
            if self.current_page == 1:
                self.current_page = self.max_pages
            else:
                self.current_page -= 1

        self.page_switcher.update_index(self.current_page, self.max_pages)
        self.gen_search_results(self.last_results)

    def gen_search_results(self, results, new_search=False, *args):
        script_manager = constants.server_manager.current_server.script_manager

        # Error on failure
        if not results and isinstance(results, bool):
            self.show_popup(
                "warning",
                "Server Error",
                "There was an issue reaching the add-on repository\n\nPlease try again later",
                None
            )
            self.max_pages = 0
            self.current_page = 0

        # On success, rebuild results
        else:

            # Update page counter
            self.last_results = results
            self.max_pages = (len(results) / self.page_size).__ceil__()
            self.current_page = 1 if self.current_page == 0 or new_search else self.current_page

            self.page_switcher.update_index(self.current_page, self.max_pages)
            page_list = results[(self.page_size * self.current_page) - self.page_size:self.page_size * self.current_page]

            self.scroll_layout.clear_widgets()


            # Generate header
            script_count = len(results)
            very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["very-bold"])
            search_text = self.search_bar.previous_search if (len(self.search_bar.previous_search) <= 25) else self.search_bar.previous_search[:22] + "..."
            if isinstance(search_text, str) and not search_text:
                header_content = f"{constants.translate('Available Scripts')}  [color=#494977]-[/color]  " + (f'[color=#6A6ABA]{constants.translate("No results")}[/color]' if script_count == 0 else f'[font={very_bold_font}]1[/font] {constants.translate("item")}' if script_count == 1 else f'[font={very_bold_font}]{script_count:,}[/font] {constants.translate("items")}')
            else:
                header_content = f"{constants.translate('Search for')} '{search_text}'  [color=#494977]-[/color]  " + (f'[color=#6A6ABA]{constants.translate("No results")}[/color]' if script_count == 0 else f'[font={very_bold_font}]1[/font] {constants.translate("item")}' if script_count == 1 else f'[font={very_bold_font}]{script_count:,}[/font] {constants.translate("items")}')

            for child in self.header.children:
                if child.id == "text":
                    child.text = header_content
                    break


            # If there are no scripts, say as much with a label
            if script_count == 0:
                self.blank_label.text = "there are no items to display"
                constants.hide_widget(self.blank_label, False)
                self.blank_label.opacity = 0
                Animation(opacity=1, duration=0.2).start(self.blank_label)
                self.max_pages = 0
                self.current_page = 0

            # If there are scripts, display them here
            else:
                constants.hide_widget(self.blank_label, True)

                # Clear and add all scripts
                for x, script_object in enumerate(page_list, 1):


                    # Function to install script
                    def install_script(index):

                        selected_button = [item for item in self.scroll_layout.walk() if item.__class__.__name__ == "ScriptButton"][index-1]
                        script = selected_button.properties
                        selected_button.toggle_installed(not selected_button.installed)

                        if len(script.name) < 26:
                            script_name = script.name
                        else:
                            script_name = script.name[:23] + "..."

                        # Install
                        if selected_button.installed:
                            threading.Timer(0, functools.partial(script_manager.download_script, script)).start()
                            # Show banner if server is running
                            if script_manager._hash_changed():
                                Clock.schedule_once(
                                    functools.partial(
                                        self.show_banner,
                                        (0.937, 0.831, 0.62, 1),
                                        "An amscript reload is required to apply changes",
                                        "sync.png",
                                        3,
                                        {"center_x": 0.5, "center_y": 0.965}
                                    ), 0
                                )

                            else:
                                Clock.schedule_once(
                                    functools.partial(
                                        self.show_banner,
                                        (0.553, 0.902, 0.675, 1),
                                        f"Installed '${script_name}$'",
                                        "checkmark-circle-sharp.png",
                                        2.5,
                                        {"center_x": 0.5, "center_y": 0.965}
                                    ), 0.25
                                )

                        # Uninstall
                        else:
                            for installed_script in script_manager.return_single_list():
                                if installed_script.title == script.title:
                                    script_manager.delete_script(installed_script)
                                    constants.clear_script_cache(installed_script.path)

                                    # Show banner if server is running
                                    if script_manager._hash_changed():
                                        Clock.schedule_once(
                                            functools.partial(
                                                self.show_banner,
                                                (0.937, 0.831, 0.62, 1),
                                                "An amscript reload is required to apply changes",
                                                "sync.png",
                                                3,
                                                {"center_x": 0.5, "center_y": 0.965}
                                            ), 0
                                        )

                                    else:
                                        Clock.schedule_once(
                                            functools.partial(
                                                self.show_banner,
                                                (1, 0.5, 0.65, 1),
                                                f"'${script_name}$' was uninstalled",
                                                "trash-sharp.png",
                                                2.5,
                                                {"center_x": 0.5, "center_y": 0.965}
                                            ), 0.25
                                        )

                                    break

                        return script, selected_button.installed


                    # Activated when script is clicked
                    def view_script(script, index, *args):
                        selected_button = [item for item in self.scroll_layout.walk() if item.__class__.__name__ == "ScriptButton"][index - 1]
                        # selected_button.loading(True)

                        Clock.schedule_once(
                            functools.partial(
                                self.show_popup,
                                "script",
                                " ",
                                " ",
                                (None, functools.partial(install_script, index)),
                                (selected_button.installed, script)
                            ),
                            0
                        )


                    # Add-on button click function
                    self.scroll_layout.add_widget(
                        ScrollItem(
                            widget = ScriptButton(
                                properties = script_object,
                                installed = script_object.installed,
                                fade_in = ((x if x <= 8 else 8) / self.anim_speed),
                                click_function = functools.partial(
                                    view_script,
                                    script_object,
                                    x
                                )
                            )
                        )
                    )

                self.resize_bind()
                self.scroll_layout.parent.parent.scroll_y = 1

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.header = None
        self.scroll_layout = None
        self.blank_label = None
        self.search_bar = None
        self.page_switcher = None

        self.last_results = []
        self.page_size = 20
        self.current_page = 0
        self.max_pages = 0
        self.anim_speed = 10

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        super()._on_keyboard_down(keyboard, keycode, text, modifiers)

        # Press arrow keys to switch pages
        if keycode[1] in ['right', 'left'] and self.name == screen_manager.current_screen.name:
            self.switch_page(keycode[1])
        elif keycode[1] == "tab" and self.name == screen_manager.current_screen.name:
            for widget in self.search_bar.children:
                try:
                    if widget.id == "search_input":
                        widget.grab_focus()
                        break
                except AttributeError:
                    pass

    def generate_menu(self, **kwargs):
        server_obj = constants.server_manager.current_server
        script_manager = server_obj.script_manager

        # Scroll list
        scroll_widget = ScrollViewWidget(position=(0.5, 0.437))
        scroll_anchor = AnchorLayout()
        self.scroll_layout = GridLayout(cols=1, spacing=15, size_hint_max_x=1250, size_hint_y=None, padding=[0, 30, 0, 30])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 1.79
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1
            self.anim_speed = 13 if Window.width > grid_layout.size_hint_max_x else 10

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, self.scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        self.scroll_layout.bind(minimum_height=self.scroll_layout.setter('height'))
        self.scroll_layout.id = 'scroll_content'

        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.715}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.17}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60))

        # Generate buttons on page load
        script_count = 0
        very_bold_font = os.path.join(constants.gui_assets, 'fonts', constants.fonts["very-bold"])
        header_content = constants.translate("Script Search")
        self.header = HeaderText(header_content, '', (0, 0.89), __translate__ = (False, True))

        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(self.header)

        # Add blank label to the center
        self.blank_label = Label()
        self.blank_label.text = "search for scripts above"
        self.blank_label.font_name = os.path.join(constants.gui_assets, 'fonts', constants.fonts['italic'])
        self.blank_label.pos_hint = {"center_x": 0.5, "center_y": 0.48}
        self.blank_label.font_size = sp(24)
        self.blank_label.color = (0.6, 0.6, 1, 0.35)
        float_layout.add_widget(self.blank_label)

        search_function = script_manager.search_scripts
        self.search_bar = search_input(return_function=search_function, pos_hint={"center_x": 0.5, "center_y": 0.795})
        self.page_switcher = PageSwitcher(0, 0, (0.5, 0.805), self.switch_page)


        # Append scroll view items
        scroll_anchor.add_widget(self.scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)
        float_layout.add_widget(self.search_bar)
        float_layout.add_widget(self.page_switcher)

        buttons.append(ExitButton('Back', (0.5, 0.12), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        server_name = constants.server_manager.current_server.name
        menu_name = f"{server_name}, amscript, Download"
        float_layout.add_widget(generate_title(f"Script Manager: '{server_name}'"))
        float_layout.add_widget(generate_footer(menu_name))

        self.add_widget(float_layout)

        # # Autofocus search bar
        # for widget in self.search_bar.children:
        #     try:
        #         if widget.id == "search_input":
        #             widget.grab_focus()
        #             break
        #     except AttributeError:
        #         pass
        Clock.schedule_once(functools.partial(self.search_bar.execute_search, ""), 0)


# Edit Config Screens ------------------------------------------------------------------------------------------------

# Determines the type of config file and open in the proper editor
def open_config_file(path: str, *a):
    config_data = {
        'path': path,
        'remote_path': None,
        '_telepath_data': None
    }

    try:
        server_obj = constants.server_manager.current_server
        ext = path.split('.')[-1]

        # First check if file is compatible
        if ext not in constants.valid_config_formats:
            return False
    except:
        return False

    # If this file is via Telepath, download it first prior to editing
    config_data['_telepath_data'] = server_obj._telepath_data
    if server_obj._telepath_data:
        config_data['remote_path'] = path
        config_data['path'] = constants.telepath_download(server_obj._telepath_data, path)

    # Check if file exits and pick the correct editor for the format
    if config_data['path'] and os.path.isfile(config_data['path']):
        editor_screen = None

        if ext in ['properties', 'ini']:
            editor_screen = 'ServerPropertiesEditScreen'

        elif ext in ['tml', 'toml']:
            editor_screen = 'ServerTomlEditScreen'

        elif ext in ['yml', 'yaml']:
            editor_screen = 'ServerYamlEditScreen'

        elif ext == 'json':
            editor_screen = 'ServerJsonEditScreen'

        elif ext == 'json5':
            editor_screen = 'ServerJson5EditScreen'

        else:
            editor_screen = 'ServerTextEditScreen'

        screen_manager.get_screen(editor_screen).update_path(config_data)
        screen_manager.current = editor_screen

    return False

def save_config_file(data: dict, content: str):

    # Write content to disk
    with open(data['path'], 'w', encoding='utf-8', errors='ignore') as f:
        f.write(content)

    # Upload via Telepath if remote
    if data['_telepath_data'] and data['remote_path']:
        telepath_data = data['_telepath_data']
        upload_path = constants.telepath_upload(telepath_data, data['path'])['path']

        test = constants.api_manager.request(
            endpoint='/main/update_config_file',
            host=telepath_data['host'],
            port=telepath_data['port'],
            args={
                'server_name': constants.server_manager.current_server.name,
                'upload_path': upload_path,
                'destination_path': data['remote_path']
            }
        )


# Controller for ConfigFiles containers
class ConfigFolder(RelativeLayout):

    def __init__(self, path: str, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # Internal properties
        self.path = path
        self.files = None
        self.folded = True

        # Widget properties
        self.size_hint_max_y = 50
        self.pos_hint = {'center_y': 1}
        self.color = (0.6, 0.6, 1, 1)
        self.original_opacity = 0.7
        self.hover_delay = 0.1
        self.opacity = self.original_opacity

        # Click behavior
        self.button = HoverButton()
        self.button.opacity = 0
        self.button.y = -15
        self.button.on_enter = self.on_enter
        self.button.on_leave = self.on_leave
        self.button.on_press = self.on_click
        self.add_widget(self.button)

        # Folder icon
        self.icon = Image()
        self.icon.color = self.color
        self.icon.opacity = 1
        self.icon.allow_stretch = True
        self.icon.keep_ratio = False
        self.icon.size_hint_max = (35, 35)
        self.icon.y = 5
        self.icon.source = os.path.join(constants.gui_assets, 'icons', 'folder.png')
        self.add_widget(self.icon)

        # Folder text
        self.text = AlignLabel()
        self.text.__translate__ = False
        self.text.halign = "left"
        self.text.valign = "middle"
        self.text.color = self.color
        self.text.markup = True
        self.text.shorten = True
        self.text.shorten_from = 'left'
        self.text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
        self.text.text = self.generate_name()
        depth = 1 if self.path.endswith(constants.server_manager.current_server.name) else 2
        text = constants.cross_platform_path(self.path, depth=depth)
        self.text.font_size = sp(25 - (0 if len(text) < 25 else (len(text) // 8)))
        self.text.max_lines = 1
        self.text.x = 55
        self.add_widget(self.text)

    def generate_name(self, color='#555599'):
        depth = 1 if self.path.endswith(constants.server_manager.current_server.name) else 2
        text = constants.cross_platform_path(self.path, depth=depth)
        if '/' in text:
            parent, child = text.rsplit('/', 1)
            return f'[color={color}]{parent}/[/color]{child}'
        elif '\\' in text:
            parent, child = text.rsplit('\\', 1)
            return f'[color={color}]{parent}\[/color]{child}'
        else:
            return text.strip()

    def toggle_fold(self, fold=True, *a):
        self.folded = fold
        self.files.hide(fold)

        # Capture old scroll data
        screen = screen_manager.current_screen
        old_scroll_ratio = screen.scroll_widget.scroll_y
        old_content_height = screen.scroll_layout.height
        viewport_height = screen.scroll_widget.height

        # Adjust folder height
        new_height = 0 if fold else len(self.files.file_list) * 50
        self.files.size_hint_min_y = new_height

        # Update icon and text
        self.icon.source = os.path.join(constants.gui_assets, 'icons', 'folder.png' if self.folded else 'folder-outline.png')
        Animation(opacity=0.7 if self.folded else 1, duration=0.1).start(self)

        # Force update so the scroll_layout adjusts its height and update scroll position
        def after_layout(*_):
            screen.scroll_anchor.do_layout()
            screen.scroll_layout.do_layout()
            screen.scroll_anchor.size_hint_min_y = screen.scroll_layout.height

            # Convert old pixel offset to the new scroll ratio
            new_content_height = screen.scroll_layout.height
            scrollable = new_content_height - viewport_height
            if scrollable > 0:
                # distance from top in pixels
                old_offset_from_top = (1 - old_scroll_ratio) * (old_content_height - viewport_height)
                new_ratio = 1 - (old_offset_from_top / scrollable)
                new_ratio = min(max(new_ratio, 0), 1)
                screen.scroll_widget.scroll_y = new_ratio

            # No scrolling needed if content < viewport
            else:
                screen.scroll_widget.scroll_y = 1

        Clock.schedule_once(after_layout, -1)

    def on_click(self, *a):

        # Open folder on right-click
        if not constants.server_manager.current_server._telepath_data:
            try:
                if self.button.last_touch.button == 'right':
                    return constants.open_folder(self.path)
            except:
                pass

        self.toggle_fold(not self.folded)

    def on_enter(self):
        Animation.stop_all(self)
        Animation(opacity=1, duration=self.hover_delay / 2).start(self)

    def on_leave(self):
        Animation.stop_all(self)
        Animation(opacity=self.original_opacity if self.folded else 1, duration=self.hover_delay).start(self)


# A container for ConfigFile objects that is controlled by ConfigFolder
class ConfigFiles(GridLayout):

    # A single file representation inside the parent
    class ConfigFile(RelativeLayout):

        def __init__(self, path: str, *args, **kwargs):
            super().__init__(*args, **kwargs)

            # Internal properties
            self.path = path

            # Widget properties
            self.size_hint_min_y = 50
            self.size_hint_max_y = 50
            self.pos_hint = {'center_y': 1}
            self.color = (0.6, 0.6, 1, 1)
            self.original_opacity = 0.5
            self.hover_delay = 0.15
            self.padding = 0

            # Background button
            self.button = HoverButton()
            self.button.opacity = 0
            self.button.y = -15
            self.button.on_enter = self.on_enter
            self.button.on_leave = self.on_leave
            self.button.on_press = self.on_click
            self.button.x = self.padding
            self.add_widget(self.button)

            # File icon
            self.icon = Image()
            self.icon.color = self.color
            self.icon.opacity = self.original_opacity
            self.icon.allow_stretch = True
            self.icon.keep_ratio = False
            self.icon.size_hint_max = (35, 35)
            self.icon.source = os.path.join(constants.gui_assets, 'icons', 'document-text-sharp.png')
            self.icon.y = -5
            self.icon.x = self.padding
            self.add_widget(self.icon)

            # File text
            self.text = AlignLabel()
            self.text.__translate__ = False
            self.text.halign = "left"
            self.text.valign = "bottom"
            self.text.color = self.color
            self.text.opacity = self.original_opacity
            self.text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["regular"]}.ttf')
            self.text.text = constants.cross_platform_path(self.path)
            self.text.shorten = True
            self.text.shorten_from = 'left'
            self.text.font_size = sp(25 - (0 if len(self.text.text) < 20 else (len(self.text.text) // 8)))
            self.text.max_lines = 1
            self.text.x = 48 + self.padding
            self.add_widget(self.text)

        def resize(self, *a):
            self.padding = 10 if Window.width < 900 else 100
            self.button.x = self.padding
            self.icon.x = self.padding
            self.text.x = 48 + self.padding

        def on_click(self):
            new_color = (0.75, 0.75, 1, 1)
            self.text.color = new_color
            self.icon.color = new_color
            Animation(color=self.color, duration=self.hover_delay).start(self.text)
            Animation(color=self.color, duration=self.hover_delay).start(self.icon)
            Clock.schedule_once(functools.partial(open_config_file, self.path), 0)

        def on_enter(self):
            Animation.stop_all(self.text)
            Animation.stop_all(self.icon)
            Animation(opacity=1, duration=self.hover_delay / 2).start(self.text)
            Animation(opacity=1, duration=self.hover_delay / 2).start(self.icon)

        def on_leave(self):
            Animation.stop_all(self.text)
            Animation.stop_all(self.icon)
            Animation(opacity=self.original_opacity, duration=self.hover_delay).start(self.text)
            Animation(opacity=self.original_opacity, duration=self.hover_delay).start(self.icon)

    def resize_files(self, *a):
        for file in self.children:
            file.resize()

        self.folder.parent.background.size_hint_min_x = screen_manager.current_screen.max_width + (10 if Window.width < 900 else 60)
        Animation.stop_all(self.folder.parent.background)
        Animation(opacity=(0 if self.folder.folded else 1), duration=0.15).start(self.folder.parent.background)

    # Pretty animation :)
    def hide(self, hide: bool = True):
        constants.hide_widget(self, hide)
        if not hide:
            def animate(c, *a):
                Animation.stop_all(c)
                Animation(opacity=1, duration=0.15).start(c)
            for child in self.children:
                child.opacity = 0
            for x, child in enumerate(reversed(self.children), 1):
                if x > 10:
                    x = 10
                Clock.schedule_once(functools.partial(animate, child), x*0.03)

    def __init__(self, folder: ConfigFolder, files: list, fold: bool = True, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # Internal properties
        self.folder = folder
        self.file_list = files
        folder.files = self

        # Widget properties
        self.pos_hint = {'center_y': 1}
        self.cols = 1
        self.padding = [0, -35.5, 0, 0]

        # Add files to self
        for file in self.file_list:
            self.add_widget(self.ConfigFile(file))

        self.bind(size=self.resize_files, pos=self.resize_files)
        Clock.schedule_once(self.resize_files, 0)
        Clock.schedule_once(functools.partial(self.folder.toggle_fold, fold), 0)

# Abstracted file manager to display folders and config files
class ServerConfigScreen(MenuBackground):
    class Background(RelativeLayout):
        def resize(self, *args):
            self.rectangle1.pos = self.pos
            self.rectangle1.size = self.size
            self.rectangle2.pos = self.pos
            self.rectangle2.size = self.size

        def __init__(self, **kwargs):
            super().__init__(**kwargs)
            image = os.path.join(constants.gui_assets, 'head_highlight.png')
            radius = 25

            with self.canvas:
                Color(0, 0, 0.05, 0.12)
                self.rectangle1 = kivy.graphics.RoundedRectangle(source=image, radius=[radius]*4)
                self.rectangle2 = kivy.graphics.RoundedRectangle(radius=[radius]*4)

            self.bind(pos=self.resize, size=self.resize)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'

        self.server_obj = None
        self.scroll_widget = None
        self.scroll_anchor = None
        self.scroll_layout = None
        self.header = None
        self.filter_text = ''
        self.search_bar = None
        self.search_label = None
        self.back_button = None
        self._cached = None
    
    def on_pre_enter(self, *args):
        if self.back_button:
            self.back_button.button.on_leave()
            self.back_button.button.background_normal = os.path.join(constants.gui_assets, 'exit_button.png')
        super().on_pre_enter(*args)
    
    def filter_files(self, query: str = None):
        self.filter_text = query

        if not query:
            return self.server_obj.config_paths

        # Filter by file name matches
        else:
            filtered = {}
            for folder, files in self.server_obj.config_paths.items():
                for file in files:
                    if query.lower() in constants.cross_platform_path(file).lower():
                        if folder not in filtered:
                            filtered[folder] = []
                        filtered[folder].append(file)

            return filtered

    def gen_search_results(self, results: dict = None, *a):
        if results is None:
            results = self.filter_files()
        else:
            self.scroll_layout.opacity = 0
            self.scroll_layout.clear_widgets()


        if results:

            # Hide "no results"
            if self.search_label.opacity > 0:
                Animation(opacity=0, duration=0.05).start(self.search_label)


            # Create two linked widgets for the folder and the items
            for folder, files in results.items():

                # Create expand filter
                expand_filter = False
                if self.server_obj.config_paths == results:
                    expand_filter = constants.cross_platform_path(folder) != self.server_obj.name

                folder_obj = ConfigFolder(folder)
                files_obj = ConfigFiles(folder_obj, files, expand_filter)

                folder_layout = RelativeLayout(size_hint_min_y=50)
                folder_layout.pos_hint = {'center_y': 1}

                padding = 10
                folder_layout.background = self.Background()
                folder_layout.background.size_hint_min_x = self.max_width + (padding * 2)
                folder_layout.background.pos = (-padding, 11)
                folder_layout.add_widget(folder_layout.background)

                folder_layout.add_widget(folder_obj)

                self.scroll_layout.add_widget(folder_layout)
                self.scroll_layout.add_widget(files_obj)


        # Show "no results"
        else:
            Animation.stop_all(self.search_label)
            self.search_label.text = f"No results for '{self.filter_text}'"
            Animation(opacity=1, duration=0.2).start(self.search_label)


        # Refresh screen
        if self.scroll_layout.opacity < 1:
            def reset_layout(*a):
                Animation.stop_all(self.scroll_layout)
                Animation(opacity=1, duration=0.3).start(self.scroll_layout)
            Clock.schedule_once(reset_layout, 0.1)

    def generate_menu(self, **kwargs):
        self.server_obj = constants.server_manager.current_server

        # Re-use previously generated widget if the server and language is the same
        if self._cached and self._cached['server_obj'] == self.server_obj and self._cached['locale'] == constants.app_config.locale:
            return self.add_widget(self._cached['layout'])

        # Ignore screen if there are no config paths in the current server
        if not self.server_obj.config_paths:
            if not self.server_obj.reload_config_paths():
                return previous_screen()

        # Scroll list
        self.max_width = 750
        self.scroll_widget = ScrollViewWidget()
        self.scroll_widget.pos_hint = {'center_y': 0.485, 'center_x': 0.5}
        self.scroll_anchor = AnchorLayout()
        self.scroll_layout = GridLayout(
            cols=2,
            spacing=10,
            size_hint_max_x=self.max_width,
            size_hint_y=None,
            padding=[0, 80, 0, 60]
        )


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 1.5
            grid_layout.cols = 2

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, self.scroll_widget, self.scroll_layout, self.scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        self.scroll_layout.bind(minimum_height=self.scroll_layout.setter('height'))
        self.scroll_layout.id = 'scroll_content'

        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.79}, pos=self.scroll_widget.pos, size=(self.scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.18}, pos=self.scroll_widget.pos, size=(self.scroll_widget.width // 1.5, -60))

        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'

        # Create header/search bar
        self.header = HeaderText("Select a configuration file to edit", '', (0, 0.9), no_line=True)
        self.search_bar = search_input(return_function=self.filter_files, server_info=None, pos_hint={"center_x": 0.5, "center_y": 0.84}, allow_empty=True)

        # Lol search label idek
        self.search_label = Label()
        self.search_label.__translate__ = False
        self.search_label.text = ""
        self.search_label.halign = "center"
        self.search_label.valign = "center"
        self.search_label.font_name = os.path.join(constants.gui_assets, 'fonts', constants.fonts['italic'])
        self.search_label.pos_hint = {"center_x": 0.5, "center_y": 0.5}
        self.search_label.font_size = sp(25)
        self.search_label.color = (0.6, 0.6, 1, 0.35)
        float_layout.add_widget(self.search_label)


        # Append scroll view items
        self.scroll_anchor.add_widget(self.scroll_layout)
        self.scroll_widget.add_widget(self.scroll_anchor)
        float_layout.add_widget(self.scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)
        float_layout.add_widget(self.header)
        float_layout.add_widget(self.search_bar)

        self.back_button = ExitButton('Back', (0.5, 0.12), cycle=True)
        buttons.append(self.back_button)

        for button in buttons:
            float_layout.add_widget(button)

        float_layout.add_widget(generate_title(f"Server Settings: '{self.server_obj.name}'"))
        float_layout.add_widget(generate_footer(f"{self.server_obj.name}, Settings, Edit config"))

        self._cached = {'server_obj': self.server_obj, 'locale': constants.app_config.locale, 'layout': float_layout}
        self.add_widget(float_layout)

        self.gen_search_results()


# Config file editor
class EditorRoot(MenuBackground):

    # Base functionality for EditorLines
    class EditorLine(RelativeLayout):
        class EditorInput(TextInput):

            class OverflowLabel(RelativeLayout):
                def show(self, show=True):
                    self.opacity = 1 if show else 0
                    self.background.opacity = 1 if show else 0
                    self.text.opacity = 1 if show else 0
                def __init__(self, side='left', *args, **kwargs):
                    super().__init__(*args, **kwargs)
                    self.size_hint_max_x = 30
                    self.side = side

                    self.background = Image(source=os.path.join(constants.gui_assets, 'scroll_overflow.png'))
                    self.background.color = constants.brighten_color(constants.background_color, -0.1)
                    self.background.allow_stretch = True
                    self.background.keep_ratio = False
                    self.background.size_hint_max_x = (self.size_hint_max_x + 10) * (1 if self.side == 'left' else -1)
                    self.background.x = (0 if self.side == 'left' else self.size_hint_max_x - 5)

                    self.add_widget(self.background)

                    self.text = Label()
                    self.text.text = 'â€¦'
                    self.text.color = (0.6, 0.6, 1, 0.6)
                    self.text.markup = True
                    self.text.size_hint_max_x = self.size_hint_max_x
                    self.add_widget(self.text)

                    self.show(False)

            def _update_overflow(self):
                try:
                    if self.text:
                        text_width = self._get_text_width(str(self.text), self.tab_width, self._label_cached)
                        self.scrollable = text_width > self.width

                        if self.scrollable:

                            # Update text properties
                            self.ovf_left.text.font_name = self.ovf_right.text.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["mono-medium"]}.otf')
                            self.ovf_left.text.font_size = self.ovf_right.text.font_size = self.font_size + 6
                            self.ovf_left.height = self.ovf_right.height = self.height

                            # Update positions
                            y_pos = self.y + 7
                            self.ovf_left.pos = (self.x + 3, y_pos)
                            self.ovf_right.pos = (Window.width - self._line.input_padding - 16, y_pos)

                            # Update opacity
                            self.ovf_left.show(self.scroll_x > 0)
                            self.ovf_right.show(self.scroll_x + self.width <= text_width)

                            return

                except AttributeError:
                    pass

                self.scrollable = False
                self.ovf_left.show(False)
                self.ovf_right.show(False)

            def grab_focus(self, *a):
                def focus_later(*args):
                    try:
                        self.focus = True
                    except:
                        return
                Clock.schedule_once(focus_later, 0)

            def on_focus(self, *args):
                try:
                    if self._line.inactive:
                        self.focused = False
                        return
                except:
                    return

                Animation.stop_all(self._line.eq_label)
                Animation(opacity=(1 if self.focused else 0.5), duration=0.15).start(self._line.eq_label)
                try:
                    Animation(opacity=(1 if self.focused or self._line.line_matched else 0.35), duration=0.15).start(self._line.line_number)
                except AttributeError:
                    pass

                if self.focused:
                    # Use 1-based line index
                    self._line._screen.current_line = self._line.line

                    # If there's a function to set the editor's index, pass our 1-based line
                    if self._line.index_func:
                        # The parent's 0-based index + 1 => 1-based
                        self._line.index_func(self._line.index + 1)

                    if self._get_text_width(str(self.text), self.tab_width, self._label_cached) > self.width:
                        self.cursor = (len(self.text), self.cursor[1])
                        self.scroll_x = self._get_text_width(str(self.text), self.tab_width, self._label_cached) - self.width + 1
                        Clock.schedule_once(lambda *_: self.do_cursor_movement("cursor_end"), -1)

                        def select_error_handler(*a):
                            try:
                                self.select_text(0)
                            except:
                                pass
                        Clock.schedule_once(select_error_handler, 0.01)
                else:
                    self.do_cursor_movement("cursor_home")
                    self.scroll_x = 0

                self._update_overflow()

            # Type color and prediction
            @staticmethod
            def _input_validation(text: str):

                # Escape newlines and tabs from pasting
                if '\n' in text:
                    text = text.replace('\n', '\\n')
                if '\r' in text:
                    text = text.replace('\r', '\\r')
                if '\t' in text:
                    text = text.replace('\t', '    ')

                return text

            def on_text(self, *args):

                # Update text in memory
                if self._line._data:
                    self._line._data['value'] = self.text

                Animation.stop_all(self)
                Animation.stop_all(self.search)

                self.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["mono-medium"]}.otf')
                self.font_size = dp(25)
                self.foreground_color = (0.408, 0.889, 1, 1)
                self.cursor_color = (0.358, 0.839, 1, 1)
                self.selection_color = (0.308, 0.789, 1, 0.4)

                # Structured data detection
                if self.get_type(self.text) in (list, tuple, dict):
                    self.foreground_color = (0.2, 1, 0.5, 1)
                    self.cursor_color = (0.2, 1, 0.5, 1)
                    self.selection_color = (0.2, 1, 0.5, 0.4)

                # Boolean detection
                elif self.get_type(self.text.lower()) == bool:
                    self.text = self.text.lower()
                    self.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["mono-italic"]}')
                    self.foreground_color = (1, 0.451, 1, 1)
                    self.cursor_color = (1, 0.401, 1, 1)
                    self.selection_color = (0.955, 0.351, 1, 0.4)
                    self.font_size = dp(23.8)

                # Numeric detection (int or float)
                elif self.get_type(self.text) in (float, int):
                    self.foreground_color = (0.989, 0.591, 0.254, 1)
                    self.cursor_color = (0.939, 0.541, 0.254, 1)
                    self.selection_color = (0.889, 0.511, 0.254, 0.4)

                # Plain-text detection
                elif self.get_type(self.text) is None:
                    self.foreground_color = (0.7, 0.7, 1, 1)
                    self.cursor_color = (0.7, 0.7, 1, 1)
                    self.selection_color = (0.7, 0.7, 1, 0.4)

                self.last_color = self.foreground_color
                self.original_text = str(self.text)
                self.search.text = str(self.text)
                self.search.color = self.foreground_color
                self.search.font_size = self.font_size
                self.search.font_name = self.font_name
                self.search.text_size = self.search.size

                if self.search.opacity == 1:
                    self.foreground_color = (0, 0, 0, 0)

                def highlight(*args):
                    self._original_text = self.text
                    try:
                        self._line._screen.check_match(self._line._data, self._line._screen.search_bar.text)
                        self._line.highlight_text(self._line.last_search)
                    except AttributeError:
                        pass

                Clock.schedule_once(highlight, 0)

            def insert_text(self, substring, from_undo=False):

                # Ignore all key presses if search bar is highlighted or not selected line
                # Check 1-based line vs current_line
                if self._line._screen.search_bar.focused or self._line.line != self._line._screen.current_line:
                    self.focused = False
                    return None

                if self._line._screen.popup_widget:
                    return None

                substring = self._input_validation(substring)

                super().insert_text(substring, from_undo=from_undo)

            # Add in special key presses
            def keyboard_on_key_down(self, window, keycode, text, modifiers):
                if self._line._screen.popup_widget:
                    return None

                # Ignore all key presses if search bar is highlighted or not selected line
                if self._line._screen.search_bar.focused or self._line.line != self._line._screen.current_line:
                    self.focused = False
                    return None

                # Ignore undo and redo for global effect
                if (keycode[1] in ['r', 'z', 'y', 'c'] and control in modifiers) or keycode[1] == 'escape':
                    return None

                # Ignore pressing certain keys
                elif (keycode[1] == 'super' and control in modifiers) or (control in modifiers and keycode[1] in ['s', 'f']):
                    pass

                # Undo functionality
                elif (((not modifiers or bool([m for m in modifiers if m not in keycode[1]])) and (text or keycode[1] in ['backspace', 'delete', 'spacebar'])) or
                      (keycode[1] in ['v', 'x'] and control in modifiers) or
                      (keycode[1] == 'backspace' and control in modifiers)):
                    self.undo_func(save=True)

                # Toggle boolean values with space
                def replace_text(val, *args):
                    self.text = val

                if keycode[1] == "spacebar" and self.text == 'true':
                    Clock.schedule_once(functools.partial(replace_text, 'false'), 0)

                elif keycode[1] == "spacebar" and self.text == 'false':
                    Clock.schedule_once(functools.partial(replace_text, 'true'), 0)

                if keycode[1] == "backspace" and control in modifiers:
                    original_index = self.cursor_col
                    new_text, index = constants.control_backspace(self.text, original_index)
                    self.select_text(original_index - index, original_index)
                    self.delete_selection()
                else:
                    super().keyboard_on_key_down(window, keycode, text, modifiers)

                # Process override defined behavior
                override_result = self._line.keyboard_overrides(self, window, keycode, text, modifiers)


                # Fix scrolling issues with text input after text updates
                def fix_scroll(*a):
                    # Fix overscroll (cursor X pos is less than input position
                    if self.cursor_pos[0] < (self.x):
                        self.scroll_x = 0

                    # Fix underscroll (cursor X pos is greater than max width, and cursor is at the end of text)
                    if (self.cursor_pos[0] >= Window.width - self._line.input_padding) and len(self.text) == self.cursor[0]:
                        self.scroll_x = self._get_text_width(self.text, self.tab_width, self._label_cached) - self.width + 12

                    # Update ellipses for content that's off-screen
                    self._update_overflow()
                Clock.schedule_once(fix_scroll, 0)


                if override_result:
                    return override_result

            def scroll_search(self, *a):
                offset = 12
                if self.cursor_offset() - self.width + offset > 0 and self.scroll_x > 0:
                    offset = self.cursor_offset() - self.width + offset
                else:
                    offset = 0

                self.search.x = (self.x + 5.3) - offset

                def highlight(*args):
                    try:
                        self._line.highlight_text(self._line.last_search)
                    except AttributeError:
                        pass

                Clock.schedule_once(highlight, 0)

            def on_touch_down(self, touch):
                if self._line._screen.popup_widget:
                    return
                else:
                    return super().on_touch_down(touch)

            def _update_data(self, data: dict):
                default_value = str(data['value'])
                self.index_func = self._line.index_func
                self.undo_func = self._line.undo_func
                self.get_type = self._line.get_type
                self.eq = self._line.eq_label

                self.text = self._input_validation(default_value)
                self.original_text = str(self.text)

                # This was formerly: self.line = self._line.line_number
                # Renamed to indicate itâ€™s the label widget for the line number
                self.line_number = self._line.line_number

                # Instead of self.index, rely on self._line.index (0-based)
                # Instead of self.line, rely on self._line.line (1-based)

                if self._line.line == self._line._screen.current_line:
                    self.grab_focus()
                else:
                    def unfocus_later(*a):
                        self.focused = False
                        self.do_cursor_movement("cursor_home")
                        self.scroll_x = 0
                        # This seems to have problems with not actually updating when scrolling
                        self._update_overflow()
                    Clock.schedule_once(unfocus_later, 0)

            def __init__(self, line, **kwargs):
                super().__init__(**kwargs)
                self._line = line
                self._line._original_text = ''

                with self.canvas.after:
                    self.search = AlignLabel()
                    self.search.halign = "left"
                    self.search.color = (1, 1, 1, 1)
                    self.search.markup = True
                    self.search.font_name = self.font_name
                    self.search.font_size = self.font_size
                    self.search.text_size = self.search.size
                    self.search.width = 10000
                    self.search.font_kerning = False

                    self.ovf_left = self.OverflowLabel('left')
                    self.ovf_right = self.OverflowLabel('right')

                self.bind(scroll_x=self.scroll_search)
                self.__translate__ = False
                self.font_kerning = False
                self.index_func = None
                self.undo_func = None
                self.get_type = None
                self.text = ''
                self.original_text = ''
                self.multiline = False
                self.background_color = (0, 0, 0, 0)
                self.cursor_width = dp(3)
                self.eq = None
                self.scrollable = False

                # Holds the label widget for the line number, not the numeric index
                self.line_number = None

                self.last_color = (0, 0, 0, 0)
                self.valign = 'center'

                self.bind(text=self.on_text)
                self.bind(focused=self.on_focus)
                Clock.schedule_once(self.on_text, 0)

                self.size_hint_max = (None, None)
                self.size_hint_min_y = 40

        class CommentLabel(AlignLabel, HoverBehavior):
            # Hover stuffies
            def on_enter(self, *args):

                if self.copyable:
                    if '[u]' in self.text and '[/u]' in self.text and self.color_tag not in self.text:
                        self.text = self.text.replace('[u]', f'{self.color_tag}[u]')
                        self.text = self.text.replace('[/u]', '[/u][/color]')

            def on_leave(self, *args):

                if self.copyable:
                    if '[u]' in self.text and '[/u]' in self.text and self.color_tag in self.text:
                        self.text = self.text.replace(f'{self.color_tag}[u]', '[u]')
                        self.text = self.text.replace('[/u][/color]', '[/u]')

            # Normal stuffies
            def on_ref_press(self, *args):
                if not self.disabled:
                    def click(*a):
                        webbrowser.open_new_tab(self.url)

                    Clock.schedule_once(click, 0)

            def ref_text(self, *args):
                if 'http://' in self.text or 'https://' in self.text:
                    self.copyable = True

                    if '[ref=' not in self.text and '[/ref]' not in self.text and self.copyable:
                        self.original_text = self.text
                        url_pattern = r'(https?://[^\s]+)'

                        def replace_url(match):
                            url = match.group(1)
                            self.url = url
                            return f'[u]{url}[/u]'

                        # Use re.sub with the pattern
                        self.text = '[ref=none]' + re.sub(url_pattern, replace_url, self.text, count=1) + '[/ref]'

            def __init__(self, **kwargs):
                super().__init__(**kwargs)
                self.markup = True
                self.copyable = False
                self.url = None
                self.original_text = ''
                self.color_tag = '[color=#8F8F8F]'
                self.bind(text=self.ref_text)

        def __setattr__(self, attr, value):
            if attr == "data" and value:
                return self._update_data(value)

            super().__setattr__(attr, value)

        def on_index_update(self):
            # Custom behavior when the index is updated
            # self.index is 0-based, so line_number text is index+1 for display
            self.line_number.text = str(self.index + 1)
            self.value_label._line.index = self.index  # Keep input's parent index in sync
            self.line_number.size_hint_max_x = (self.spacing * len(str(self.max_line_count)))

        def on_resize(self, *args):
            self.key_label.size_hint_max = self.key_label.texture_size
            self.eq_label.size_hint_max = self.eq_label.texture_size

            self.key_label.x = self.line_number.x + self.line_number.size_hint_max[0] + (self.spacing * 1.4) + 10 + self.indent_space
            self.eq_label.x = self.key_label.x + self.key_label.size_hint_max[0] + (self.spacing * self.eq_spacing[0])
            self.value_label.x = self.eq_label.x + self.eq_label.size_hint_max[0] + (self.spacing * self.eq_spacing[1])
            self.value_label.y = -6


            # Properly position comments
            if self.is_comment:
                self.key_label.size_hint_max_y = self.eq_label.size_hint_max_y
                self.key_label.size_hint_max_x = Window.width


            # Properly position all other inputs to just before the edge of the screen
            else:
                self.value_label.size_hint_max_x = self.value_label.size_hint_min_x = Window.width - self.value_label.x - self.input_padding
                self.value_label._update_overflow()


            # Properly position search text
            vl = self.value_label
            vl.search.x = vl.x + 6
            vl.search.y = vl.y + (5 if 'italic' in vl.font_name.lower() else 7) + 10

            # Additional cover elements for ghosting or blocking touches
            try:
                self.ghost_cover_left.x = -10
                self.ghost_cover_left.size_hint_max_x = self.value_label.x + 14
                self.ghost_cover_right.x = Window.width - 33
                self.ghost_cover_right.size_hint_max_x = 33
            except AttributeError:
                pass

        def highlight_text(self, text, animate=True, *a):
            # Attempt to highlight text in both key and value for searching.
            self.last_search = text
            self.key_label.text = self.key_label.original_text
            self.line_matched = self._data['line_matched']

            if not animate:
                Animation.stop_all(self.line_number)

            def draw_highlight_box(label, *args):
                label.canvas.before.clear()
                if self.key_label.url:
                    return

                def get_x(lb, ref_x):
                    return lb.center_x - lb.texture_size[0] * 0.5 + ref_x

                def get_y(lb, ref_y):
                    return lb.center_y + lb.texture_size[1] * 0.5 - ref_y

                for name, boxes in label.refs.items():
                    for box in boxes:
                        with label.canvas.before:
                            Color(*self.select_color)
                            Rectangle(pos=(get_x(label, box[0]), get_y(label, box[1])), size=(box[2] - box[0], box[1] - box[3]))

            text = text.strip()

            if text and not self.key_label.url and self.line_matched:

                # Check if search matches in key label
                if self.line_matched['key']:
                    self.key_label.text = self.line_matched['key']
                else:
                    Clock.schedule_once(functools.partial(draw_highlight_box, self.key_label), 0)

                # Check if search matches in value input/ghost label
                if self.line_matched['value']:
                    self.value_label.search.text = self.line_matched['value']
                else:
                    self.value_label.search.text = self.value_label.text
                    Clock.schedule_once(functools.partial(draw_highlight_box, self.value_label.search), 0)

            # Highlight matches if line matched
            if self.line_matched and self._screen.search_bar.text:
                self.line_number.text = f'[color=#4CFF99]{self.line}[/color]'
                self.line_number.opacity = 1
                self.on_resize()

                Clock.schedule_once(functools.partial(draw_highlight_box, self.value_label.search), 0)
                Clock.schedule_once(functools.partial(draw_highlight_box, self.key_label), 0)

                self.value_label.foreground_color = (0, 0, 0, 0)
                self.value_label.search.opacity = 1

            else:
                # Reset visuals
                self.line_number.text = str(self.line)
                self.line_number.opacity = (1 if self.value_label.focused else 0.35)

                self.value_label.search.opacity = 0
                self.value_label.foreground_color = self.value_label.last_color

                Clock.schedule_once(functools.partial(draw_highlight_box, self.value_label.search), 0)
                Clock.schedule_once(functools.partial(draw_highlight_box, self.key_label), 0)

                self.value_label.search.text = self.value_label.text
                self.key_label.text = self.key_label.original_text

            return self.line_matched

        def _update_data(self, data: dict):

            # Remove all widgets to be added in 'self.render_line'
            self.clear_widgets()

            # First set self.index (0-based), then self.line (1-based)
            idx = self._screen.line_list.index({'data': data})
            self.index = idx
            self.line = idx + 1

            # Add global 'data' parsing here
            self._data = data

            # Render line as defined in override
            self.render_line(data)

            # Internally update the value label
            self.value_label._update_data(data)

            # Update widget sizes
            Clock.schedule_once(self.on_resize, -1)
            Clock.schedule_once(functools.partial(self.highlight_text, self._screen.search_bar.text), -1)

        def __init__(self, *args, **kwargs):
            super().__init__(**kwargs)
            background_color = constants.brighten_color(constants.background_color, -0.1)
            self._screen = screen_manager.current_screen
            self.index_func = self._screen.set_index
            self.undo_func = self._screen.undo

            # Store the 1-based line here
            self.line = None
            # Store the 0-based index here
            self.index = None

            self.last_search = None
            self.font_size = dp(25)
            self.line_matched = False
            self._data = None

            # Overridable attributes
            self.eq_character = '='
            self.eq_spacing = (0.75, 0.75)
            self.indent_space = 0
            self.input_padding = 100

            # Line number
            self.line_number = AlignLabel()
            self.line_number.__translate__ = False
            self.line_number.text = ''
            self.line_number.halign = 'right'
            self.line_number.markup = True
            self.line_number.opacity = 0
            self.line_number.color = (0.7, 0.7, 1, 1)
            self.line_number.pos_hint = {'center_y': 0.7}
            self.line_number.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["mono-medium"]}.otf')
            self.line_number.font_size = self.font_size

            # Read-only key label
            self._key_labels = {'comment': self.CommentLabel(halign='left'), 'normal': Label()}
            self.key_label = self._key_labels['normal']

            # Equals label (for key/value pairs)
            self.eq_label = Label()
            self.eq_label.__translate__ = False
            self.eq_label.halign = 'left'
            self.eq_label.opacity = 0
            self.eq_label.pos_hint = {'center_y': 0.5}

            # Editable value label (EditorInput)
            self.value_label = self.EditorInput(self)

            # Ghost covers for left / right
            self.ghost_cover_left = Image(color=background_color)
            self.ghost_cover_right = Image(color=background_color)


        # Methods available to override
        def configure(self):

            # This method is meant to be overridden to specify configuration options

            self.eq_character = '='
            self.eq_spacing = (0.75, 0.75)

        def render_line(self, data: dict):
            self._data = data
            max_line_count = len(self._screen.line_list)

            # Determines if the line is skip-able when scrolling
            self.is_comment = data['is_comment']
            self.inactive = data['inactive']
            self.line_matched = data['line_matched']
            self._finished_rendering = False
            self._comment_padding = None

            # Defaults
            font_name = 'mono-medium'
            self.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts[font_name]}.otf')
            self.spacing = dp(16)
            self.size_hint_min_y = 50
            self.last_search = ''
            self.line_matched = False
            self.select_color = (0.3, 1, 0.6, 1)
            self.animate = False

            # Line number
            self.line_number.text = str(self.line)
            self.line_number.size_hint_max_x = (self.spacing * len(str(max_line_count)))
            self.line_number.opacity = 0.35

            # Key label
            self.key_label.url = None
            self.key_label.__translate__ = False
            self.key_label.max_lines = 1
            self.key_label.markup = True
            self.key_label.text = ''
            self.key_label.original_text = ''
            self.key_label.font_name = self.font_name
            self.key_label.font_size = self.font_size
            self.key_label.default_color = "#5E6BFF"
            self.key_label.color = self.key_label.default_color
            self.key_label.size_hint_max_y = 50
            self.key_label.pos_hint = {'center_y': 0.5}
            self.key_label.text_size[0] = 0
            self.key_label.opacity = 1

            # Show eq character
            self.eq_label.text = self.eq_character
            self.eq_label.font_name = self.font_name
            self.eq_label.font_size = self.font_size
            self.eq_label.color = (0, 0, 0, 0)
            self.eq_label.opacity = 0.5
            self.eq_label.pos_hint = {'center_y': 0.5}

            # Re-add all widgets in order of Z layer (bottom to top)
            self.add_widget(self.value_label)

            # Ghost covers for left / right
            self.add_widget(self.ghost_cover_left)
            self.add_widget(self.ghost_cover_right)

            # Add remaining widgets
            self.add_widget(self.eq_label)
            self.add_widget(self.line_number)
            self.add_widget(self.key_label)

        @staticmethod
        def get_type(value: str):
            data_type = str

            # Define custom behavior for determining data types

            # Structured data detection
            if ((value.strip().startswith('{') and value.strip().endswith('}'))
            or (value.strip().startswith('[') and value.strip().endswith(']'))
            or (value.strip().startswith('(') and value.strip().endswith(')'))):
                data_type = dict

            # Boolean detection
            elif value.lower() in ['true', 'false']:
                data_type = bool

            # Numeric detection (int or float)
            elif value.replace(".", "").replace("-", "").isdigit():
                data_type = float

            return data_type

        @staticmethod
        def keyboard_overrides(self, window, keycode, text, modifiers):

            # Define more keyboard processing behavior for input

            pass

    # Search bar for editor content
    class SearchInput(TextInput):

        def __init__(self, **kwargs):
            super().__init__(**kwargs)
            self._screen = screen_manager.current_screen

            self.original_text = ''
            self.history_index = 0

            self.size_hint_max_y = 50
            self.multiline = False
            self.halign = "left"
            self.hint_text = "search for text..."
            self.hint_text_color = (0.6, 0.6, 1, 0.4)
            self.foreground_color = (0.6, 0.6, 1, 1)
            self.background_color = (0, 0, 0, 0)
            self.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["mono-bold"]}.otf')
            self.font_size = sp(24)
            self.padding_y = (12, 12)
            self.padding_x = (70, 12)
            self.cursor_color = (0.55, 0.55, 1, 1)
            self.cursor_width = dp(3)
            self.selection_color = (0.5, 0.5, 1, 0.4)

            self.bind(on_text_validate=self.on_enter)

        def _on_focus(self, instance, value, *largs):
            def update_focus(*args):
                self._screen._input_focused = self.focus
            Clock.schedule_once(update_focus, 0)

            super(type(self), self)._on_focus(instance, value)
            Animation.stop_all(self.parent.input_background)
            Animation(opacity=0.9 if self.focus else 0.35, duration=0.2, step=0).start(self.parent.input_background)

        def grab_focus(self, *a):
            def focus_later(*args):
                self.focus = True
            Clock.schedule_once(focus_later, 0)

        def on_enter(self, value):
            self.grab_focus()

        def insert_text(self, substring, from_undo=False):
            if self._screen.popup_widget:
                return None
            substring = substring.replace("\n", "").replace("\r", "")
            return super().insert_text(substring, from_undo=from_undo)

        def keyboard_on_key_down(self, window, keycode, text, modifiers):
            if self.parent.popup_widget:
                return None

            if keycode[1] == 'escape' and self.focused:
                self.focused = False
                if self.parent:
                    self.parent.focus_input()
                return True

            if keycode[1] in ['r', 'z', 'y'] and control in modifiers:
                return None

            if keycode[1] == "backspace" and control in modifiers:
                original_index = self.cursor_col
                new_text, idx = constants.control_backspace(self.text, original_index)
                self.select_text(original_index - idx, original_index)
                self.delete_selection()
            else:
                super().keyboard_on_key_down(window, keycode, text, modifiers)

            # Fix overscroll
            if self.cursor_pos[0] > (self.x + self.width) - (self.width * 0.05):
                self.scroll_x += self.cursor_pos[0] - ((self.x + self.width) - (self.width * 0.05))

            if self.cursor_pos[0] < (self.x):
                self.scroll_x = 0

        def fix_overscroll(self, *args):
            if self.cursor_pos[0] < (self.x):
                self.scroll_x = 0

        def on_touch_down(self, touch):
            if self._screen.popup_widget:
                return
            else:
                return super().on_touch_down(touch)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'

        self._config_data = None
        self.path = None
        self.file_name = None

        self.server_obj = None
        self.header = None
        self.search_bar = None
        self.scroll_widget = None
        self.scroll_layout = None
        self.input_background = None
        self.fullscreen_shadow = None
        self.match_label = None
        self.controls_button = None

        self.undo_history = []
        self.redo_history = []
        self.last_search = ''
        self.match_list = []
        self.modified = False

        # EditorRoot.current_line is now consistently 1-based
        self.current_line = None

        self.line_list = []

        self.background_color = constants.brighten_color(constants.background_color, -0.1)

        # Background
        with self.canvas.before:
            self.color = Color(*self.background_color, mode='rgba')
            self.rect = Rectangle(pos=self.pos, size=self.size)

    # Update current file loaded in editor
    def update_path(self, data: dict):
        self._config_data = data
        self.path = self._config_data['path']
        self.file_name = os.path.basename(self.path)

    # Set current line as 1-based index
    def set_index(self, index, **kwargs):
        self.current_line = index

    # Highlight specific input
    def focus_input(self, new_input=None, highlight=False, force_end=True, grab_focus=False):
        if not new_input:
            if self.current_line:
                return self.scroll_to_line(self.current_line, highlight=highlight, grab_focus=grab_focus)
            else:
                return None

        if highlight:
            original_color = constants.convert_color(new_input.key_label.default_color)['rgb']
            new_input.key_label.color = constants.brighten_color(original_color, 0.2)
            Animation.stop_all(new_input.key_label)
            Animation(color=original_color, duration=0.5).start(new_input.key_label)

        if grab_focus:
            new_input.value_label.grab_focus()

        # Force cursor to the end of the line
        if force_end:
            Clock.schedule_once(lambda *_: new_input.value_label.do_cursor_movement('cursor_end', True), 0)

        self.set_index(new_input.line)

    # Scroll to any line in RecycleView
    def scroll_to_line(self, index: int, highlight=False, wrap_around=False, select=True, grab_focus=False):
        Animation.stop_all(self.scroll_widget, 'scroll_y')
        line_height = 50
        padding_lines = 5
        total_lines = len(self.line_list)
        content_height = total_lines * line_height
        viewport_height = self.scroll_widget.height - self.search_bar.height - self.header.height

        # If the content is smaller than or equal to the viewport, don't scroll.
        if content_height <= viewport_height:
            new_scroll_y = 1
        else:
            max_offset = content_height - viewport_height

            # Compute the top (in pixels) of the target line in the full content.
            target_line_top = (index - 1) * line_height

            # Set how many lines you want as padding.
            padding_pixels = padding_lines * line_height

            # Determine where in the viewport the target line should appear.
            # We choose a position opposite to the direction of travel:
            # - If scrolling downward (new index > current), position the target line
            #   near the bottom so that the extra padding appears above it.
            # - If scrolling upward (new index < current), position it near the top,
            #   leaving extra space (padding) below it.
            if self.current_line is not None:
                if index > self.current_line:
                    # Scrolling downward: target line should appear near the bottom.
                    desired_y = viewport_height - padding_pixels
                elif index < self.current_line:
                    # Scrolling upward: target line should appear near the top.
                    desired_y = padding_pixels
                else:
                    desired_y = viewport_height / 2
            else:
                desired_y = viewport_height / 2

            # Compute the new scroll offset (in pixels) so that the target lineâ€™s
            # position in the viewport becomes the desired_y value.
            target_offset = target_line_top - desired_y

            # Clamp to valid scroll range.
            target_offset = max(0, min(target_offset, max_offset))
            new_scroll_y = 1 - (target_offset / max_offset)

        def after_scroll(*a):
            [self.focus_input(line, highlight, True, grab_focus) for line in self.scroll_layout.children if line.line == index]

            # If a search term is active, update highlights.
            if self.search_bar.text:
                Clock.schedule_once(lambda *_: [line.highlight_text(self.search_bar.text, False) for line in self.scroll_layout.children], 0)

        # Only scroll when there is a scrollbar (i.e. not all lines are generated).
        if len(self.scroll_layout.children) < total_lines:
            if select:
                Animation(scroll_y=new_scroll_y, duration=0.1).start(self.scroll_widget)
                Clock.schedule_once(after_scroll, 0.4 if wrap_around else 0.11)
            else:
                self.scroll_widget.scroll_y = new_scroll_y
                self.set_index(index)
        else:
            if select:
                after_scroll()

    # Move between inputs with arrow keys
    def switch_input(self, position):
        if self.current_line is None:
            # Default to line 1 if current_line is unset
            self.set_index(1)

        found_input = False
        wrap_around = False

        # Keep the original increments to preserve userâ€™s existing navigation behavior
        index = 0
        if position == 'up':
            index = self.current_line - 2
        elif position == 'down':
            index = self.current_line
        elif position in ['pagedown', 'end']:
            position = 'pagedown'
            index = len(self.line_list) - 1
        elif position in ['pageup', 'home']:
            position = 'pageup'
            index = 0

        # Loop until full circle or input is found
        attempts = 0
        while not found_input and attempts <= len(self.line_list):
            if index >= len(self.line_list):
                index = 0
                wrap_around = True
            elif index < 0:
                index = len(self.line_list) - 1
                wrap_around = True

            new_input = self.line_list[index]['data']
            ignore_input = False
            if not new_input['inactive']:

                if self.match_list and self.last_search:
                    if not new_input['line_matched']:
                        ignore_input = True

                if not ignore_input:
                    try:
                        # scroll_to_line expects a 1-based index
                        self.scroll_to_line(index + 1, wrap_around=wrap_around, grab_focus=True)
                        break
                    except AttributeError:
                        pass

            if 'up' in position:
                index = index - 1
            else:
                index = index + 1

            attempts += 1

    # Generate search in background
    @staticmethod
    def _check_match_logic(data: dict, search_text: str):
        # Override logic here to parse search matches with delimiters like ":" or "=" differently

        key_text = ''
        value_text = ''

        return key_text, value_text

    def check_match(self, data: dict, search_text: str):
        line_matched = False
        key_matched = False
        value_matched = False

        if search_text:
            search_text = kivy.utils.escape_markup(search_text.strip())

            # Detect different types of key/value pairs
            key_text, value_text = self._check_match_logic(data, search_text)

            key_data = kivy.utils.escape_markup(str(data['key']))
            value_data = kivy.utils.escape_markup(str(data['value']))

            # Check if search matches in key label
            if search_text in key_data:
                key_matched = f'[color=#000000][ref=0]{search_text}[/ref][/color]'.join([x for x in key_data.split(search_text)])
            elif key_text and key_data.endswith(key_text) and value_text.startswith(value_text):
                key_matched = f'[color=#000000][ref=0]{key_text}[/ref][/color]'.join([x for x in key_data.rsplit(key_text, 1)])

            # Check if search matches in value input/ghost label
            if search_text in value_data:
                value_matched = f'[color=#000000][ref=0]{search_text}[/ref][/color]'.join([x for x in value_data.split(search_text)])
            elif value_text and value_data.startswith(value_text) and key_data.endswith(key_text):
                value_matched = f'[color=#000000][ref=0]{value_text}[/ref][/color]'.join([x for x in value_data.split(value_text, 1)])

            if key_matched or value_matched:
                line_matched = {'key': key_matched, 'value': value_matched}

        data['line_matched'] = line_matched
        return line_matched

    def search_text(self, obj, text, *args):
        self.last_search = text
        self.match_list = []
        first_match = None

        # Update search data in background
        for x, line in enumerate(self.line_list):
            result = self.check_match(line['data'], text)
            if result:
                self.match_list.append(line)
            if result and not first_match:
                first_match = line

        # Update all visible widgets
        if not text:
            self.scroll_widget.refresh_from_data()

        for line in self.scroll_layout.children:
            Clock.schedule_once(functools.partial(line.highlight_text, text), -1)

        # Scroll to first match
        if first_match:
            index = self.line_list.index(first_match)
            # scroll_to_line expects 1-based
            self.scroll_to_line(index + 1, select=False, grab_focus=True)

        # Dirty hack to force focus to search bar
        for x in range(30):
            Clock.schedule_once(self.search_bar.grab_focus, 0.01 * x)

        # Show match count
        try:
            Animation.stop_all(self.match_label)
            Animation(opacity=(1 if text and self.match_list else 0.35 if text else 0), duration=0.1).start(self.match_label)
            matches = 0
            search_str = text.strip()
            if search_str:
                for x in self.match_list:
                    total_str = str(x['data']['key']) + str(x['data']['value'])
                    matches += total_str.count(search_str)
            self.match_label.text = f'{matches} match{"es" if matches != 1 else ""}'
        except AttributeError:
            pass

    # Undo/redo behavior
    def _apply_action(self, action, undo=True):
        """
        Called to undo or redo a structural action:
          - 'insert_line': remove or re-insert
          - 'remove_line': re-insert or remove
        """
        a_type = action['type']
        line_data = action['data']  # either the dict or the (key,value,...) tuple
        idx = action['index']

        if a_type == 'insert_line':
            if undo:
                # Undo an insert => remove it
                self.remove_line(idx, refresh=True)
                self.scroll_to_line(idx, grab_focus=True)
            else:
                # Redo an insert => put it back
                self.insert_line(line_data, idx, refresh=True)
                self.scroll_to_line(idx + 1, highlight=True, grab_focus=True)

        elif a_type == 'remove_line':
            if undo:
                # Undo a remove => re-insert it
                self.insert_line(line_data, idx, refresh=True)
                self.scroll_to_line(idx + 1, highlight=True, grab_focus=True)
            else:
                # Redo a remove => remove again
                self.remove_line(idx, refresh=True)
                self.scroll_to_line(idx, grab_focus=True)

    def undo(self, save=False, undo=False, action=None):
        """
        Handles both structural (insert/remove line) and text changes,
        with exactly the one-step-per-line logic you had before.

        - `save=True, action=...` => record a *structural* action
        - `save=True, action=None` => record a *text-change* action
        - `undo=True` => perform undo
        - `undo=False` => perform redo
        """

        # 1) Save a *structural* action
        if save and action is not None:
            self.redo_history.clear()
            self.undo_history.append(action)
            return

        # 2) Save a *text-change* action
        if save and action is None:
            self.redo_history.clear()
            if self.current_line is not None and 1 <= self.current_line <= len(self.line_list):

                # We already store EditorRoot.current_line as 1-based
                line_num = self.current_line

                # Grab the current line's "original_value" from the data
                old_text = self.line_list[line_num - 1]['data']['original_value']

                # If the last undo entry is text for the *same line*, update it
                if self.undo_history and not isinstance(self.undo_history[-1], dict):
                    last = self.undo_history[-1]  # e.g. (line_num, old_text)
                    if last[0] == line_num:
                        # "Update existing action"
                        self.undo_history[-1] = (line_num, old_text)
                        return

                # Otherwise, create a new text-based action
                self.undo_history.append((line_num, old_text))

            return

        # 3) Actually perform Undo or Redo
        if undo:
            # UNDO
            if not self.undo_history:
                return
            last_action = self.undo_history.pop()

            if isinstance(last_action, dict):
                # structural
                self._apply_action(last_action, undo=True)
                self.redo_history.append(last_action)
            else:
                # text-based => (line_num, old_text)
                line_num, old_text = last_action
                if 1 <= line_num <= len(self.line_list):
                    # Before reverting, store the current text for Redo
                    current_text = self.line_list[line_num - 1]['data']['value']
                    self.redo_history.append((line_num, current_text))

                    # Revert to old_text in the data
                    self.line_list[line_num - 1]['data']['value'] = old_text

                    # Also revert 'original_value' if you want it fully consistent:
                    self.line_list[line_num - 1]['data']['original_value'] = old_text

                    # Refresh the RecycleView so the UI sees the change
                    self.scroll_widget.data = self.line_list
                    self.scroll_widget.refresh_from_data()

                    # Optionally scroll/focus that line
                    self.scroll_to_line(line_num, highlight=True, grab_focus=True)

        else:
            # REDO
            if not self.redo_history:
                return
            last_action = self.redo_history.pop()

            if isinstance(last_action, dict):
                # structural
                self._apply_action(last_action, undo=False)
                self.undo_history.append(last_action)
            else:
                # text-based => (line_num, old_text)
                line_num, old_text = last_action
                if 1 <= line_num <= len(self.line_list):
                    # store the current text in Undo before overwriting
                    current_text = self.line_list[line_num - 1]['data']['value']
                    self.undo_history.append((line_num, current_text))

                    # revert data
                    self.line_list[line_num - 1]['data']['value'] = old_text
                    self.line_list[line_num - 1]['data']['original_value'] = old_text

                    # refresh
                    self.scroll_widget.data = self.line_list
                    self.scroll_widget.refresh_from_data()
                    self.scroll_to_line(line_num, highlight=True, grab_focus=True)

    def _refresh_viewport(self):
        # Force refresh of all data in the viewport
        self.scroll_widget.data = self.line_list
        self.scroll_widget.refresh_from_data()

        # If the content is smaller than or equal to the viewport, don't allow overscroll
        total_lines = len(self.line_list)
        content_height = total_lines * 50
        viewport_height = self.scroll_widget.height - self.search_bar.height
        self.scroll_widget.always_overscroll = content_height > viewport_height

    # Line behavior
    def insert_line(self, data: (tuple, list, dict), index: int = None, refresh=True):

        # Override data parsing in child editors for specific line formats
        if 'data' not in data:
            data = {'data': data}

        if index is not None:
            self.line_list.insert(index, data)

        else:
            self.line_list.append(data)

        # Update layout with new data
        if refresh:
            self.current_line = None

            for line in self.scroll_layout.children:
                line.value_label.focused = False

            self._refresh_viewport()

        return data

    def remove_line(self, index: int, refresh=True):
        if index in range(len(self.line_list)):
            self.current_line = None

            for line in self.scroll_layout.children:
                line.value_label.focused = False

            data = self.line_list.pop(index)

            # Update layout with new data
            if refresh:
                self._refresh_viewport()

            return data

    # Load/save behavior
    def load_file(self):

        # Overrides need to open and read 'self.path' and parse it into a data structure for 'self.lines'

        self.line_list = []

        for line in self.read_from_disk():
            line = line.rstrip()

            data = {
                'key': '',
                'value': line,
                'original_value': line,
                'is_comment': False,
                'inactive': False,
                'line_matched': False
            }

            self.insert_line(data, refresh=False)

        return self.line_list

    def save_file(self):

        # Overrides need to convert 'self.lines' back to a multi-line string, and pass it into 'self.write_to_disk()'

        final_content = ''

        for line in self.line_list:
            line = line['data']
            key_str = ''
            val_str = str(line['value']).strip()

            final_content += str(f"{key_str}{val_str}".rstrip() + '\n')

        self.write_to_disk(final_content)

    def read_from_disk(self) -> list:
        with open(self.path, 'r', encoding='utf-8') as f:
            content = f.read().strip('\r\n')
            content = content.replace(r'\n', '\\n').replace(r'\r', '\\r')
            return content.splitlines()

    def write_to_disk(self, content: str):
        try:
            save_config_file(self._config_data, content)
        except Exception as e:
            if constants.debug:
                print("Error saving file:", e)
            return False

        def set_banner(*a):
            self.set_banner_status(False)

        Clock.schedule_once(set_banner, 0)

        if self.server_obj.running:
            Clock.schedule_once(
                functools.partial(
                    screen_manager.current_screen.show_banner,
                    (0.937, 0.831, 0.62, 1),
                    f"A server restart is required to apply changes",
                    "sync.png",
                    3,
                    {"center_x": 0.5, "center_y": 0.965}
                ), 0
            )
        else:
            Clock.schedule_once(
                functools.partial(
                    screen_manager.current_screen.show_banner,
                    (0.553, 0.902, 0.675, 1),
                    f"'${self.file_name}$' was saved successfully",
                    "checkmark-circle-sharp.png",
                    2.5,
                    {"center_x": 0.5, "center_y": 0.965}
                ), 0
            )

    # Menu navigation
    def quit_to_menu(self, *a):
        for button in self.walk():
            try:
                if button.id == "exit_button":
                    button.force_click()
                    break
            except AttributeError:
                continue

    def save_and_quit(self, *a):
        self.save_file()
        self.quit_to_menu()

    def reset_data(self):
        self.load_file()
        self.set_banner_status(False)

    def check_data(self):
        return not self.undo_history

    def set_banner_status(self, changed=False):
        if changed != self.modified:
            self.remove_widget(self.header)
            del self.header

            if changed:
                self.header = BannerObject(
                    pos_hint={"center_x": 0.5, "center_y": 0.9},
                    size=(250, 40),
                    color="#F3ED61",
                    text=f"Editing '${self.file_name}$'",
                    icon="pencil-sharp.png",
                    animate=True
                )
                self.add_widget(self.header)
            else:
                self.header = BannerObject(
                    pos_hint={"center_x": 0.5, "center_y": 0.9},
                    size=(250, 40),
                    color=(0.4, 0.682, 1, 1),
                    text=f"Viewing '${self.file_name}$'",
                    icon="eye-outline.png",
                    animate=True
                )
                self.add_widget(self.header)

        self.modified = changed

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):

        # Ignore key presses when popup is visible
        if self.popup_widget:

            # Override for PopupSearch
            if self.popup_widget.__class__.__name__ == 'PopupSearch':
                if keycode[1] == 'escape':
                    self.popup_widget.self_destruct(True)
                elif keycode[1] == 'backspace' or ('shift' in modifiers and text and not text.isalnum()):
                    self.popup_widget.resize_window()
                elif control not in modifiers and text and self.popup_widget.window_input.keyboard:

                    def insert_text(content):
                        col = self.popup_widget.window_input.cursor_col
                        start = self.popup_widget.window_input.text[:col]
                        end = self.popup_widget.window_input.text[col:]
                        self.popup_widget.window_input.text = start + content + end
                        for x in range(len(content)):
                            Clock.schedule_once(functools.partial(self.popup_widget.window_input.do_cursor_movement, 'cursor_right', True), 0)

                    new_str = self.popup_widget.window_input.keyboard.keycode_to_string(keycode[0])
                    if 'shift' in modifiers:
                        new_str = new_str.upper()
                    if len(new_str) == 1:
                        insert_text(new_str)
                    elif keycode[1] == 'spacebar':
                        insert_text(' ')
                    self.popup_widget.resize_window()
                else:
                    self.popup_widget.resize_window()
                return True

            if keycode[1] in ['escape', 'n']:
                try:
                    self.popup_widget.click_event(self.popup_widget, 'no')
                except AttributeError:
                    self.popup_widget.click_event(self.popup_widget, 'ok')

            elif keycode[1] in ['enter', 'return', 'y']:
                try:
                    self.popup_widget.click_event(self.popup_widget, 'yes')
                except AttributeError:
                    self.popup_widget.click_event(self.popup_widget, 'ok')
            return

        if (keycode[1] == 'q' and control in modifiers) or keycode[1] == 'escape':
            if self.modified:
                self.show_popup(
                    "query",
                    "Unsaved Changes",
                    f"There are unsaved changes in '${self.file_name}$'.\n\nWould you like to save before quitting?",
                    [functools.partial(Clock.schedule_once, self.quit_to_menu, 0.25),
                     functools.partial(Clock.schedule_once, self.save_and_quit, 0.25)]
                )
            else:
                self.quit_to_menu()
            return True

        if keycode[1] in ['down', 'up', 'pagedown', 'pageup']:
            return self.switch_input(keycode[1])

        if keycode[1] == 'f' and control in modifiers:
            if not self.search_bar.focused:
                self.search_bar.grab_focus()
            else:
                if self.current_line is not None:
                    self.focus_input()
            return True

        if keycode[1] == 's' and control in modifiers and self.modified:
            self.save_file()
            return None

        # Undo/Redo
        if keycode[1] == 'z' and control in modifiers and self.undo_history:
            self.undo(save=False, undo=True)
        elif keycode[1] == 'z' and control in modifiers and not self.undo_history:
            if not self.check_data():
                self.reset_data()

        if keycode[1] in ['r', 'y'] and control in modifiers and self.redo_history:
            self.undo(save=False, undo=False)

        # Trigger for showing search bar
        elif keycode[1] == 'shift':
            if not self._shift_held:
                self._shift_held = True
                self._shift_press_count += 1

                if self._shift_timer:
                    self._shift_timer.cancel()

                # Check for double tap
                if self._shift_press_count == 2:
                    self.show_search()
                    self._shift_press_count = 0

                # Otherwise, reset the timer
                else:
                    self._shift_timer = Clock.schedule_once(self._reset_shift_counter, 0.25)  # Adjust time as needed
            return True

        def set_banner(*a):
            self.set_banner_status(not self.check_data())
        Clock.schedule_once(set_banner, 0)

        return True

    def generate_menu(self, **kwargs):
        self.server_obj = constants.server_manager.current_server

        # Editor UI
        self.scroll_widget = RecycleViewWidget(position=(0.5, 0.5), view_class=self.EditorLine)
        self.scroll_widget.always_overscroll = False
        self.scroll_layout = RecycleGridLayout(cols=1, size_hint_max_x=1250, size_hint_y=None, padding=[10, 30, 0, 30], default_size=(1250, 50))
        self.scroll_layout.bind(minimum_height=self.scroll_layout.setter('height'))
        self.scroll_layout.id = 'scroll_content'

        def resize_scroll(call_widget, grid_layout, *args):
            call_widget.height = Window.height // 1.23
            self.fullscreen_shadow.y = self.height + self.x - 3 + 25
            self.fullscreen_shadow.width = Window.width
            search_pos = 47
            self.search_bar.pos = (self.x, search_pos)
            self.input_background.pos = (self.search_bar.pos[0] - 15, self.search_bar.pos[1] + 8)
            self.search_bar.size_hint_max_x = Window.width - self.search_bar.x - 200

        self.resize_bind = lambda *_: Clock.schedule_once(functools.partial(resize_scroll, self.scroll_widget, self.scroll_layout), 0)
        Window.bind(on_resize=self.resize_bind)
        self.resize_bind()

        self.scroll_widget.data = self.load_file()

        float_layout = FloatLayout()
        float_layout.id = 'content'
        self.scroll_widget.add_widget(self.scroll_layout)
        float_layout.add_widget(self.scroll_widget)

        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.9}, pos=self.scroll_widget.pos, size=(self.scroll_widget.width // 1.5, 60))
        scroll_top.color = self.background_color
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5}, pos=self.scroll_widget.pos, size=(self.scroll_widget.width // 1.5, -60))
        scroll_bottom.color = self.background_color
        scroll_bottom.y = 115

        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)

        self.fullscreen_shadow = Image()
        self.fullscreen_shadow.allow_stretch = True
        self.fullscreen_shadow.keep_ratio = False
        self.fullscreen_shadow.size_hint_max = (None, 25)
        self.fullscreen_shadow.color = self.background_color
        self.fullscreen_shadow.opacity = 0
        self.fullscreen_shadow.source = os.path.join(constants.gui_assets, 'control_fullscreen_gradient.png')
        float_layout.add_widget(self.fullscreen_shadow)

        buttons = []
        buttons.append(ExitButton('Back', (0.5, -1), cycle=True))
        for b in buttons:
            float_layout.add_widget(b)

        float_layout.add_widget(generate_title(f"Server Settings: '{self.server_obj.name}'"))
        float_layout.add_widget(generate_footer(f"{self.server_obj.name}, Settings, Edit '${self.file_name}$'"))
        self.add_widget(float_layout)

        self.search_bar = self.SearchInput()
        self.search_bar.bind(text=self.search_text)
        self.add_widget(self.search_bar)

        self.match_label = AlignLabel()
        self.match_label.text = '0 matches'
        self.match_label.halign = "right"
        self.match_label.color = (0.6, 0.6, 1, 1)
        self.match_label.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["mono-bold"]}.otf')
        self.match_label.font_size = sp(24)
        self.match_label.y = 60
        self.match_label.padding_x = 10
        self.match_label.opacity = 0
        self.add_widget(self.match_label)

        self.input_background = Image()
        self.input_background.default_opacity = 0.35
        self.input_background.color = self.search_bar.foreground_color
        self.input_background.opacity = self.input_background.default_opacity
        self.input_background.allow_stretch = True
        self.input_background.size_hint = (None, None)
        self.input_background.height = self.search_bar.size_hint_max_y / 1.45
        self.input_background.source = os.path.join(constants.gui_assets, 'icons', 'search.png')
        self.add_widget(self.input_background)

        def show_controls():
            controls_text = """This editor allows you to modify additional server configuration options. Shortcuts are provided for ease of use:


â€¢ Press 'CTRL+Z' to undo, and 'CTRL+R'/'CTRL+Y' to redo

â€¢ Press 'CTRL+S' to save modifications

â€¢ Press 'CTRL+Q' to quit the editor

â€¢ Press 'CTRL+F' to search for data

â€¢ Press 'SPACE' to toggle boolean values (e.g. true, false)""" if constants.os_name != 'macos' else """This editor allows you to modify additional server configuration options. Shortcuts are provided for ease of use:


â€¢ Press 'CMD+Z' to undo, and 'CMD+R'/'CMD+Y' to redo

â€¢ Press 'CMD+S' to save modifications

â€¢ Press 'CMD+Q' to quit the editor

â€¢ Press 'CMD+F' to search for data

â€¢ Press 'SPACE' to toggle boolean values (e.g. true, false)"""

            Clock.schedule_once(
                functools.partial(
                    self.show_popup,
                    "controls",
                    "Controls",
                    controls_text,
                    (None)
                ),
                0
            )

        self.controls_button = IconButton(
            'controls', {}, (70, 110), (None, None), 'question.png',
            clickable=True, anchor='right', click_func=show_controls
        )
        float_layout.add_widget(self.controls_button)

        self.header = BannerObject(
            pos_hint={"center_x": 0.5, "center_y": 0.9},
            size=(250, 40),
            color=(0.4, 0.682, 1, 1),
            text=f"Viewing '${self.file_name}$'",
            icon="eye-outline.png"
        )
        self.add_widget(self.header)

        self.controls_button = IconButton(
            'save & quit', {}, (120, 110), (None, None), 'save-sharp.png',
            clickable=True, anchor='right',
            click_func=self.save_and_quit,
            text_offset=(-5, 50)
        )
        float_layout.add_widget(self.controls_button)

# Edit in plain-text mode for fallback
class ServerTextEditScreen(EditorRoot):

    class EditorLine(EditorRoot.EditorLine):
        def configure(self):
            self.eq_character = ':'
            self.eq_spacing = (1.05, 0.67)

        @staticmethod
        def get_type(value: str):

            # Define custom behavior for determining data types

            return None

# Edit all *.properties/INI files
class ServerPropertiesEditScreen(EditorRoot):
    class EditorLine(EditorRoot.EditorLine):
        def configure(self):
            self.eq_character = '='
            self.eq_spacing = (1.05, 0.67)

        def render_line(self, data: dict):
            self._data = data
            key = data['key']
            is_header = data['is_header']
            is_comment = data['is_comment']
            is_blank_line = data['is_blank_line']
            indent_level = data['indent']
            max_line_count = len(self._screen.line_list)


            # Determines if the line is skip-able when scrolling
            self.is_header = is_header
            self.is_comment = is_comment
            self.is_blank_line = is_blank_line
            self.inactive = data['inactive']
            self.line_matched = data['line_matched']
            self._finished_rendering = False
            self._comment_padding = None

            # Indentation space
            self.indent_level = indent_level
            self.indent_space = dp(25) * self.indent_level

            # Defaults
            font_name = 'mono-bold' if is_header else 'mono-medium'
            self.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts[font_name]}.otf')
            self.spacing = dp(16)
            self.size_hint_min_y = 50
            self.last_search = ''
            self.line_matched = False
            self.select_color = (0.3, 1, 0.6, 1)
            self.animate = False

            # Line number
            self.line_number.text = str(self.line)
            self.line_number.size_hint_max_x = (self.spacing * len(str(max_line_count)))
            self.line_number.opacity = 0.35

            # Key label
            self.key_label = self._key_labels['comment' if self.is_comment else 'normal']
            self.key_label.url = None
            self.key_label.__translate__ = False
            self.key_label.max_lines = 1
            self.key_label.markup = True
            self.key_label.text = key
            self.key_label.original_text = key
            self.key_label.font_name = self.font_name
            self.key_label.font_size = self.font_size
            self.key_label.default_color = "#636363" if is_comment else (0.5, 0.5, 1, 1) if is_header else "#5E6BFF"
            self.key_label.color = self.key_label.default_color
            self.key_label.size_hint_max_y = 50
            self.key_label.pos_hint = {'center_y': 0.5}
            self.key_label.text_size[0] = 1000 if is_comment or is_header else 260
            self.key_label.opacity = 1

            # Show "=" for *.properties/INI
            self.eq_label.text = self.eq_character
            self.eq_label.font_name = self.font_name
            self.eq_label.font_size = self.font_size
            self.eq_label.color = (0.6, 0.6, 1, 1) if is_header else (1, 1, 1, 1)
            self.eq_label.opacity = 0.5
            self.eq_label.pos_hint = {'center_y': 0.5}


            # Dynamically add widgets back
            if not (is_blank_line or is_comment):
                if not is_header:
                    self.add_widget(self.value_label)

            # Ghost covers for left / right
            self.add_widget(self.ghost_cover_left)
            self.add_widget(self.ghost_cover_right)

            # Add remaining widgets
            if not (is_blank_line or is_comment or is_header):
                self.add_widget(self.eq_label)
            self.add_widget(self.line_number)
            self.add_widget(self.key_label)

    # Override logic to parse search matches
    @staticmethod
    def _check_match_logic(data: dict, search_text: str):
        if "=" in search_text:
            key_text, value_text = [x.strip() for x in search_text.split("=", 1)]
        else:
            key_text = ''
            value_text = ''

        return key_text, value_text

    # *.properties/INI specific features
    def insert_line(self, line: (tuple, list, dict), index: int = None, refresh=True):
        if not isinstance(line, dict):

            key, value, is_blank_line, is_comment, is_header = line

            inactive = is_blank_line or is_header or is_comment

            data = {'data': {
                '__hash__': constants.gen_rstring(4),
                'key': key,
                'value': value,
                'original_value': value,
                'is_header': is_header,
                'is_comment': is_comment,
                'is_blank_line': is_blank_line,
                'inactive': inactive,
                'line_matched': False
            }}

        else:
            data = line

        return super().insert_line(data, index, refresh)

    def load_file(self):
        self.line_list = []

        for raw_line in self.read_from_disk():
            line = raw_line.rstrip('\r\n')

            # Extract leading indentation
            match = re.match(r'^(\s*)', line)
            indent_str = match.group(1) if match else ''

            # Strip the indentation and parse the rest
            stripped_line = line[len(indent_str):]

            is_comment = False
            is_blank_line = False
            is_header = False
            key = ''
            value = ''

            # Line has no content
            if not stripped_line.strip():
                is_blank_line = True

            # Is INI/TOML header
            elif stripped_line.startswith('[') and stripped_line.endswith(']') and '=' not in stripped_line:
                key = stripped_line
                is_header = True

            # Line is a comment
            elif stripped_line.startswith('#'):
                key = '# ' + stripped_line.lstrip('#').strip()
                is_comment = True

            # Normal key=value pair
            elif '=' in stripped_line:
                key, value = [x.strip() for x in stripped_line.split('=', 1)]

            # Build the data object
            data = {
                '__hash__': constants.gen_rstring(4),
                'key': key,
                'value': value,
                'original_value': value,
                'is_header': is_header,
                'is_comment': is_comment,
                'is_blank_line': is_blank_line,
                'indent': len(indent_str),
                'inactive': (is_blank_line or is_header or is_comment),
                'line_matched': False
            }

            # Insert data into editor
            self.insert_line({'data': data}, refresh=False)

        return self.line_list

    def save_file(self):
        final_content = ''

        for line in self.line_list:
            line = line['data']
            indent = "    " * line['indent']
            key_str = str(line['key']).strip()
            val_str = str(line['value']).strip()

            if line['is_comment'] or line['is_blank_line']:
                final_content += str(f"{indent}{key_str}".rstrip() + '\n')

            elif line['is_header'] or not val_str:
                final_content += str(f"{indent}{key_str}".rstrip() + '\n')

            elif key_str and val_str:
                final_content += str(f"{indent}{key_str}={val_str}".rstrip() + '\n')

            elif key_str:
                final_content += str(f"{indent}{key_str}=".rstrip() + '\n')


        self.write_to_disk(final_content)

        # If "server.properties", reload config
        if self.file_name == 'server.properties':
            self.server_obj.reload_config()

# Edit all TOML/TML files
class ServerTomlEditScreen(ServerPropertiesEditScreen):

    def save_file(self):
        final_content = ''

        for line in self.line_list:
            line = line['data']
            indent = "    " * line['indent']
            key_str = str(line['key']).strip()
            val_str = str(line['value']).strip()

            if line['is_comment'] or line['is_blank_line']:
                final_content += str(f"{indent}{key_str}".rstrip() + '\n')

            elif line['is_header'] or not val_str:
                final_content += str(f"{indent}{key_str}".rstrip() + '\n')

            elif key_str and val_str:
                final_content += str(f"{indent}{key_str} = {val_str}".rstrip() + '\n')

            elif key_str:
                final_content += str(f"{indent}{key_str} = ".rstrip() + '\n')

        # return print(final_content)
        self.write_to_disk(final_content)

# Edit all YAML/YML files
class ServerYamlEditScreen(EditorRoot):
    class EditorLine(EditorRoot.EditorLine):
        def configure(self):
            self.eq_character = ':'
            self.eq_spacing = (1.05, 0.67)

        def render_line(self, data: dict):
            self._data = data
            line_list = self._screen.line_list
            key = data['key']
            indent_level = data['indent']
            is_header = data['is_header']
            is_list_header = data['is_list_header']
            is_multiline_string = data['is_multiline_string']
            is_list_item = data['is_list_item']
            is_comment = data['is_comment']
            is_blank_line = data['is_blank_line']
            max_line_count = len(line_list)


            # Determines if the line is skip-able when scrolling
            self.is_header = is_header
            self.is_list_header = is_list_header
            self.is_list_item = is_list_item
            self.is_comment = is_comment
            self.is_blank_line = is_blank_line
            self.is_multiline_string = is_multiline_string
            self.inactive = data['inactive']
            self.line_matched = data['line_matched']
            self._finished_rendering = False
            self._comment_padding = None

            # Defaults
            font_name = 'mono-bold' if is_header or is_list_header else 'mono-medium'
            self.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts[font_name]}.otf')
            self.spacing = dp(16)
            self.size_hint_min_y = 50
            self.last_search = ''
            self.line_matched = False
            self.select_color = (0.3, 1, 0.6, 1)
            self.animate = False

            # Indentation space
            self.indent_level = indent_level
            self.indent_space = dp(25) * self.indent_level


            # Line number
            self.line_number.text = str(self.line)
            self.line_number.size_hint_max_x = (self.spacing * len(str(max_line_count)))
            self.line_number.opacity = 0.35

            # Key label
            self.key_label = self._key_labels['comment' if self.is_comment else 'normal']
            self.key_label.url = None
            self.key_label.__translate__ = False
            self.key_label.max_lines = 1
            self.key_label.shorten = True
            self.key_label.shorten_from = 'right'
            self.key_label.markup = True
            self.key_label.text = key
            self.key_label.original_text = key
            self.key_label.font_name = self.font_name
            self.key_label.font_size = self.font_size
            self.key_label.default_color = "#636363" if is_comment else (0.5, 0.5, 1, 1) if is_header else "#5E6BFF"
            self.key_label.color = self.key_label.default_color
            self.key_label.size_hint_max_y = 50
            self.key_label.pos_hint = {'center_y': 0.5}
            self.key_label.opacity = 0 if is_list_item else 1

            # Show ":" for YAML
            self.eq_label.text = '-' if is_list_item else ':'
            self.eq_label.font_name = self.font_name
            self.eq_label.font_size = self.font_size
            self.eq_label.color = (0.6, 0.6, 1, 1) if is_header else (1, 1, 1, 1)
            self.eq_label.opacity = 0.5
            self.eq_label.pos_hint = {'center_y': 0.5}


            if not (is_blank_line or is_comment):
                if not is_header and not is_list_header:
                    self.add_widget(self.value_label)

            # Ghost covers for left / right
            self.add_widget(self.ghost_cover_left)
            self.add_widget(self.ghost_cover_right)

            # Add remaining widgets
            if not (is_blank_line or is_comment or is_multiline_string):
                self.add_widget(self.eq_label)
            if is_multiline_string:
                self.key_label.opacity = 0
            self.add_widget(self.line_number)
            self.add_widget(self.key_label)

        @staticmethod
        def get_type(value: str):
            data_type = str

            # Define custom behavior for determining data types

            # Structured data detection
            if ((value.strip().startswith('{') and value.strip().endswith('}'))
            or (value.strip().startswith('[') and value.strip().endswith(']'))
            or (value.strip().startswith('(') and value.strip().endswith(')'))):
                data_type = dict

            # Boolean detection
            elif value.lower() in ['true', 'false', 'yes', 'no']:
                data_type = bool

            # Numeric detection (int or float)
            elif value.replace(".", "").replace("-", "").isdigit():
                data_type = float


            return data_type

        @staticmethod
        def keyboard_overrides(self, window, keycode, text, modifiers):

            # Toggle boolean values with space
            def replace_text(val, *args):
                self.text = val

            if keycode[1] == "spacebar":
                if self.text == 'yes':
                    Clock.schedule_once(functools.partial(replace_text, 'no'), 0)
                    return
                elif self.text == 'no':
                    Clock.schedule_once(functools.partial(replace_text, 'yes'), 0)
                    return

            # Add a new multi-line string on pressing "enter" in a current string
            if ((not self._line.is_list_item and self.text) or (self._line.is_multiline_string and self.text)) and keycode[1] in ['enter', 'return']:
                parent = self._line.parent
                if not parent:
                    return

                data = (
                    '__string__',
                    '',
                    self._line.indent_level + (2 if self._line.is_multiline_string else 1),
                    False,
                    False
                )

                self._line._screen.insert_line(data, self._line.line)

                def deselect(*a):
                    self._line._screen.current_line = None
                    self.focused = False

                Clock.schedule_once(deselect, 0)

                # Record the insertion action for undo
                if self._line.undo_func:
                    self._line.undo_func(
                        save=True,
                        action={
                            'type': 'insert_line',
                            'data': data,
                            'index': self._line.line
                        }
                    )

                self._line._screen.scroll_to_line(self._line.line + 1, grab_focus=True)

            # Remove line on backspace if it's empty
            elif self._line.is_multiline_string and keycode[1] in ['delete', 'backspace'] and not self._original_text:
                parent = self._line.parent
                if not parent:
                    return

                # Attempt to gather last line
                try:
                    next_line = self._line._screen.line_list[self._line.line - 1]['data']
                except:
                    next_line = {'is_list_item': False, 'eof': True}
                eof = 'eof' in next_line

                # Record the removal action for undo
                if self._line.undo_func:
                    self._line.undo_func(
                        save=True,
                        action={
                            'type': 'remove_line',
                            'data': self._line._data,
                            'index': self._line.line - 1
                        }
                    )

                self._line._screen.remove_line(self._line.line - 1)
                self._line._screen.scroll_to_line(self._line.line - 1, grab_focus=not eof)


            # Add a new list item on pressing "enter" in a current list
            elif (not self._line.is_multiline_string) and (((self._line.is_list_item and self.text) or (not self._line.is_list_item and not self.text)) and keycode[1] in ['enter', 'return']):
                parent = self._line.parent
                if not parent:
                    return

                if not self.text and not self._line.is_list_item:
                    self._line._data['is_list_header'] = True
                    self._line._update_data(self._line._data)

                data = (
                    '__list__',
                    '',
                    self._line.indent_level,
                    False,
                    False
                )
                self._line._screen.insert_line(data, self._line.line)

                def deselect(*a):
                    self._line._screen.current_line = None
                    self.focused = False

                Clock.schedule_once(deselect, 0)

                # Record the insertion action for undo
                if self._line.undo_func:
                    self._line.undo_func(
                        save=True,
                        action={
                            'type': 'insert_line',
                            'data': data,
                            'index': self._line.line
                        }
                    )

                self._line._screen.scroll_to_line(self._line.line + 1, grab_focus=True)

            # Remove line on backspace if it's empty
            elif self._line.is_list_item and keycode[1] in ['delete', 'backspace'] and not self._original_text:
                parent = self._line.parent
                if not parent:
                    return

                # Record the removal action for undo
                if self._line.undo_func:
                    self._line.undo_func(
                        save=True,
                        action={
                            'type': 'remove_line',
                            'data': self._line._data,
                            'index': self._line.line - 1
                        }
                    )

                self._line._screen.remove_line(self._line.line - 1)

                # Existing focusing logic
                try:
                    previous_line = self._line._screen.line_list[self._line.line - 2]['data']
                    try:
                        next_line = self._line._screen.line_list[self._line.line - 1]['data']
                    except:
                        next_line = {'is_list_item': False, 'eof': True}
                    eof = 'eof' in next_line

                    if previous_line['is_list_item']:
                        self._line._screen.scroll_to_line(self._line.line - 1, grab_focus=True)

                    if not previous_line['is_list_item'] and previous_line['is_list_header'] and not next_line['is_list_item']:
                        previous_line['is_list_header'] = False
                        previous_line['inactive'] = False
                        self._line._screen.scroll_to_line(self._line.line - 1, grab_focus=not eof)
                        for line in self._line.scroll_layout.children:
                            line.value_label.focused = False
                        self._line.scroll_widget.data = self._line.line_list
                        self._line.scroll_widget.refresh_from_data()
                except:
                    pass

    # Override logic to parse search matches
    @staticmethod
    def _check_match_logic(data: dict, search_text: str):
        if "-" in search_text and data['is_list_item']:
            key_text, value_text = [x.strip() for x in search_text.split("-", 1)]
        elif ":" in search_text:
            key_text, value_text = [x.strip() for x in search_text.split(":", 1)]
        else:
            key_text = ''
            value_text = ''

        return key_text, value_text

    # YAML/YML specific features
    def insert_line(self, line: (tuple, list, dict), index: int = None, refresh=True):
        if not isinstance(line, dict):

            key, value, indent, is_header, is_list_header = line

            # Format empty values
            if value in ['""', "''", None]:
                value = ''

            # Format list_headers
            if is_list_header:
                is_header = False

            # Format list items
            is_list_item = key == '__list__'
            if is_list_item:
                key = '-'

            # Format multiline strings
            is_multiline_string = key == '__string__'
            if is_multiline_string:
                key = ''

            # Format multiline strings
            if is_multiline_string:
                indent = indent - 2
                key = 'âŽ'

            is_comment = key.strip().startswith('#')
            is_blank_line = not key.strip()
            inactive = is_header or is_list_header or is_comment or is_blank_line


            data = {'data': {
                '__hash__': constants.gen_rstring(4),
                'key': key,
                'value': value,
                'original_value': value,
                'indent': indent,
                'is_header': is_header,
                'is_list_header': is_list_header,
                'is_multiline_string': is_multiline_string,
                'is_comment': is_comment,
                'is_blank_line': is_blank_line,
                'is_list_item': is_list_item,
                'inactive': inactive,
                'line_matched': False
            }}

        else:
            data = line

        return super().insert_line(data, index, refresh)

    def load_file(self):

        def parse_yaml(lines: list):
            """
            Parses a YAML-like text line by line and returns a list of tuples in the form:
              (key, value, indent, is_header, is_list_header)

            Where:
              - Comments become (full_comment_text, '', indent, False, False)
              - Blank lines become ('', '', 0, False, False)
              - Multiline strings become ('__string__', full_line_text, indent, False, False)
              - List items become ('__list__', item_value, indent, False, False)
              - Normal key/value lines become (key, value, indent, is_header, is_list_header)
                * is_header = True if the line ends with a colon and no value,
                  and the next line is indented more deeply than this line.
                * is_list_header = True if the line ends with a colon and no value,
                  and the next non-comment, non-blank line is a list item.
            """

            # This list will hold dictionaries that we will later convert to tuples
            parsed_lines = []

            def get_indent(line):
                """
                Count leading spaces and convert to an integer "indent level".
                This example divides the number of leading spaces by 2, assuming 2 spaces = 1 indent level.
                Adjust if your YAML uses a different convention.
                """
                raw_leading_spaces = len(line) - len(line.lstrip(' '))
                return raw_leading_spaces // 2

            for line in lines:
                # 1) Identify indentation
                indent = get_indent(line)
                stripped = line.lstrip(' ')

                # 2) Check if blank line
                if not stripped.strip():
                    # Blank line (indent is forced to 0 in the final structure, per your example)
                    parsed_lines.append({
                        'key': '',
                        'value': '',
                        'indent': 0,
                        'is_header': False,
                        'is_list_header': False
                    })
                    continue

                # 3) Check if comment line
                if stripped.startswith('#'):
                    # Store the comment as key, no value
                    # Keep the "calculated" indentâ€”your examples show comments sometimes having >0 indent
                    parsed_lines.append({
                        'key': stripped,
                        'value': '',
                        'indent': indent,
                        'is_header': False,
                        'is_list_header': False
                    })
                    continue

                # 4) Check if list item (starts with '-')
                if stripped.startswith('-'):
                    # Everything after the dash is the item value
                    item_value = stripped[1:].strip()
                    current_line = {
                        'key': '__list__',
                        'value': item_value,
                        'indent': indent,
                        'is_header': False,
                        'is_list_header': False
                    }
                    parsed_lines.append(current_line)

                    # Check if the previous meaningful line should be flagged as a "multiline list header"
                    # Condition: the previous line has no value, is not blank or comment or __string__
                    if len(parsed_lines) > 1:
                        prev_line = parsed_lines[-2]
                        # "Meaningful" means not blank line, not comment, not string placeholder
                        if (
                                prev_line['value'] == '' and
                                prev_line['key'] not in ('', '__string__') and
                                not prev_line['key'].startswith('#')
                        ):
                            prev_line['is_list_header'] = True

                    continue

                # 5) Check if we have a proper "key: value"
                # If there's a colon, split on the first colon + space
                if ': ' in stripped:
                    key_part, value_part = stripped.split(': ', 1)
                    key_part = key_part.strip()
                    value_part = value_part.strip()

                    current_line = {
                        'key': key_part,
                        'value': value_part,
                        'indent': indent,
                        'is_header': False,
                        'is_list_header': False
                    }
                    parsed_lines.append(current_line)

                # 6) Check if we have a proper "key:" line
                elif stripped.endswith(':'):
                    current_line = {
                        'key': stripped.rstrip(':'),
                        'value': '',
                        'indent': indent,
                        'is_header': False,
                        'is_list_header': False
                    }
                    parsed_lines.append(current_line)

                else:
                    # 6) Possibly a multiline string line or a weird line with no colon at all
                    #    We'll interpret this as a multiline string if it is more indented than the previous line
                    #    and the previous line is not comment/blank/string
                    if parsed_lines:
                        prev_line = parsed_lines[-1]
                        if (
                                indent > prev_line['indent'] and
                                prev_line['key'] not in ('', '__string__') and
                                not prev_line['key'].startswith('#')
                        ):
                            # It's a multiline string line
                            parsed_lines.append({
                                'key': '__string__',
                                'value': stripped,
                                'indent': indent,
                                'is_header': False,
                                'is_list_header': False
                            })
                        else:
                            # Fallback: treat as a "header" with no value
                            parsed_lines.append({
                                'key': stripped,
                                'value': '',
                                'indent': indent,
                                'is_header': False,
                                'is_list_header': False
                            })
                    else:
                        # If it's the first line in the file and has no colon, treat as a header
                        parsed_lines.append({
                            'key': stripped,
                            'value': '',
                            'indent': indent,
                            'is_header': False,
                            'is_list_header': False
                        })

            # ----------------------------------------------------------------
            # SECOND PASS:
            # Mark any line as a 'header' if it has an empty value and the NEXT line is more indented.
            #
            # Mark it as a 'header' if:
            #    - key != '' (not blank)
            #    - key != '#' (not comment)
            #    - value = ''
            #    - next line is more indented
            #
            # We already handle list headers in the single pass,
            # so we only do "is_header" fix-up here.
            # ----------------------------------------------------------------
            for i in range(len(parsed_lines) - 1):
                current_line = parsed_lines[i]
                next_line = parsed_lines[i + 1]

                # Skip if it's blank, comment, string marker, or has a value
                if (
                        current_line['key'] not in ('', '__string__') and
                        not current_line['key'].startswith('#') and
                        current_line['value'] == '' and
                        next_line['indent'] > current_line['indent']
                ):
                    current_line['is_header'] = True

            # Finally, convert parsed_lines (list of dicts) to the list of tuples
            result = [
                (
                    d['key'],
                    d['value'],
                    d['indent'],
                    d['is_header'],
                    d['is_list_header']
                )
                for d in parsed_lines
            ]

            return result

        self.undo_history = []
        self.redo_history = []
        self.last_search = ''
        self.match_list = []
        self.modified = False
        self.current_line = None

        # Flatten and insert into the editor
        self.line_list = []
        [self.insert_line(line, refresh=False) for line in parse_yaml(self.read_from_disk())]

        return self.line_list

    def save_file(self):
        final_content = ''

        for line in self.line_list:
            line = line['data']
            key_str = str(line['key']).strip()
            val_str = str(line['value']).strip()
            base_indent = " " * 2


            # Format empty values
            if val_str in ['""', "''", None]:
                val_str = ''

            # Ignore empty list items or multiline strings
            if (line['is_multiline_string'] or line['is_list_item']) and not val_str:
                continue

            if line['is_comment'] or line['is_blank_line']:
                indent = base_indent * line['indent']
                final_content += str(f"{indent}{key_str}".rstrip() + '\n')

            elif line['is_list_item'] and val_str:
                indent = base_indent * line['indent']
                final_content += str(f"{indent}- {val_str}".rstrip() + '\n')

            elif line['is_multiline_string'] and val_str:
                indent = base_indent * (line['indent'] + 2)
                final_content += str(f"{indent}{val_str}".rstrip() + '\n')

            elif line['is_header'] or line['is_list_header'] or not val_str:
                indent = base_indent * line['indent']
                final_content += str(f"{indent}{key_str}:".rstrip() + '\n')

            elif key_str and val_str:
                indent = base_indent * line['indent']
                final_content += str(f"{indent}{key_str}: {val_str}".rstrip() + '\n')

            elif key_str:
                indent = base_indent * line['indent']
                final_content += str(f"{indent}{key_str}:".rstrip() + '\n')

        # return print(final_content)
        self.write_to_disk(final_content)

# Edit all JSON files
class ServerJsonEditScreen(ServerYamlEditScreen):

    # Internally convert JSON to YAML for ease of editing
    def read_from_disk(self) -> list:
        with open(self.path, 'r', encoding='utf-8') as f:
            raw_content = f.read()
            raw_content = raw_content.replace('\\n', '\\\\n').replace('\\r', '\\\\r')

            # Determine format features prior to parsing to preserve when saving
            self.minified = len(raw_content.splitlines()) <= 1

            json_data = json.loads(raw_content)
            content = yaml.dump(json_data, sort_keys=False, allow_unicode=True, width=float("inf"))

            content = content.strip('\r\n')
            return content.splitlines()

    def save_file(self):
        final_content = ''

        for line in self.line_list:
            line = line['data']
            key_str = str(line['key']).strip()
            val_str = str(line['value']).strip()
            base_indent = " " * 2


            # Format empty values
            if val_str in ['""', "''", None]:
                val_str = ''

            # Ignore empty list items or multiline strings
            if (line['is_multiline_string'] or line['is_list_item']) and not val_str:
                continue

            if line['is_comment'] or line['is_blank_line']:
                indent = base_indent * line['indent']
                final_content += str(f"{indent}{key_str}".rstrip() + '\n')

            elif line['is_list_item'] and val_str:
                indent = base_indent * line['indent']
                final_content += str(f"{indent}- {val_str}".rstrip() + '\n')

            elif line['is_multiline_string'] and val_str:
                indent = base_indent * (line['indent'] + 2)
                final_content += str(f"{indent}{val_str}".rstrip() + '\n')

            elif line['is_header'] or line['is_list_header'] or not val_str:
                indent = base_indent * line['indent']
                final_content += str(f"{indent}{key_str}:".rstrip() + '\n')

            elif key_str and val_str:
                indent = base_indent * line['indent']
                final_content += str(f"{indent}{key_str}: {val_str}".rstrip() + '\n')

            elif key_str:
                indent = base_indent * line['indent']
                final_content += str(f"{indent}{key_str}:".rstrip() + '\n')


        # Internally convert YAML back to JSON to retain original file format
        try:
            yaml_data = yaml.safe_load(final_content.strip())

            if self.minified:
                final_content = json.dumps(yaml_data, indent=None, separators=(',', ':')).strip()

            else:
                final_content = json.dumps(yaml_data, indent=4)

        except Exception as e:
            if constants.debug:
                print(f'Failed to save: {e}')
            return False

        # return print(final_content)
        self.write_to_disk(final_content)

# Edit all JSON5 files
class ServerJson5EditScreen(ServerYamlEditScreen):

    @staticmethod
    def json5_to_yaml(raw_content: str) -> str:
        """
        Convert JSON5 content to a YAML-like string preserving comments,
        blank lines, nesting, and indentation.

        The root scope is not indentedâ€”that is, one indent level is subtracted
        from every key compared to the raw JSON5. (When converting back to JSON5,
        that indent level is added back.)
        """
        lines = raw_content.splitlines()
        output_lines = []
        pending_comments = []
        base_indent = " " * 2  # two spaces per indent level
        indent_level = 0

        for line in lines:
            stripped = line.strip()

            # Check for opening or closing braces/brackets (ignoring trailing commas)
            if stripped.rstrip(",") in ("{", "["):
                indent_level += 1
                continue
            if stripped.rstrip(",") in ("}", "]"):
                indent_level = max(indent_level - 1, 0)
                continue

            # Preserve blank lines.
            if not stripped:
                output_lines.append("")
                continue

            # Process comments.
            if stripped.startswith("//"):
                comment_text = stripped[2:].strip()
                pending_comments.append(comment_text)
                continue
            if stripped.startswith("/*"):
                comment_text = stripped.lstrip("/*").rstrip("*/").strip()
                pending_comments.append(comment_text)
                continue

            # Process key/value lines.
            # (Assumes keys are quoted and each key/value is on its own line.)
            m = re.match(r'^\s*"([^"]+)"\s*:\s*(.+?)(,)?\s*$', line)
            if m:
                key = m.group(1)
                value = m.group(2).strip()
                # Remove surrounding quotes from a string value.
                if value.startswith('"') and value.endswith('"'):
                    value = value[1:-1]
                # Subtract one indent level for the YAML output.
                effective_indent = max(indent_level - 1, 0)
                current_indent = base_indent * effective_indent
                # Emit any pending comments.
                for comm in pending_comments:
                    output_lines.append(current_indent + "# " + comm)
                pending_comments.clear()
                # If the value indicates a nested object, output the key alone and increase indent.
                if value == "{" or value.startswith("{"):
                    output_lines.append(current_indent + f"{key}:")
                    indent_level += 1
                else:
                    output_lines.append(current_indent + f"{key}: {value}")
            else:
                current_indent = base_indent * max(indent_level - 1, 0)
                output_lines.append(current_indent + line.strip())
        while output_lines and output_lines[-1] == "":
            output_lines.pop()
        return "\n".join(output_lines)

    @staticmethod
    def yaml_to_json5(yaml_content: str) -> str:
        """
        Convert the YAML text (as produced above) back to JSON5, preserving comments,
        blank lines, nesting, and indentation.

        The YAML file is assumed to have no root indentation (i.e. one indent level was
        subtracted in the JSON5 â†’ YAML conversion). The build step below adds one indent
        level back so that JSON5 keys inside the braces are indented appropriately.
        """
        lines = yaml_content.splitlines()

        def parse_yaml(lines, start_index=0, current_indent=0):
            entries = []
            index = start_index
            pending_comments = []
            while index < len(lines):
                line = lines[index]
                # Determine the indentation level.
                line_indent = len(line) - len(line.lstrip(" "))
                if line_indent < current_indent:
                    break
                stripped_line = line.lstrip(" ")
                if not stripped_line:
                    index += 1
                    continue
                if stripped_line.startswith("#"):
                    # Collect comment.
                    comment_text = stripped_line[1:].strip()
                    pending_comments.append(comment_text)
                    index += 1
                    continue
                # Expect a line in the format: key: [value]
                m = re.match(r'^([\w\-]+)\s*:(.*)$', stripped_line)
                if m:
                    key = m.group(1)
                    value_str = m.group(2).strip()
                    index += 1
                    if value_str == "":
                        # No immediate value; assume a nested block.
                        nested_entries, new_index = parse_yaml(lines, index, current_indent + 2)
                        entry = (pending_comments.copy(), key, nested_entries)
                        pending_comments.clear()
                        entries.append(entry)
                        index = new_index
                    else:
                        # A leaf value.
                        entry = (pending_comments.copy(), key, value_str)
                        pending_comments.clear()
                        entries.append(entry)
                else:
                    index += 1
            return entries, index

        parsed_entries, _ = parse_yaml(lines, 0, 0)

        # Build JSON5 text from the parsed structure.
        json5_lines = []
        json5_lines.append("{")

        def build_json5(entries, indent_level):
            result_lines = []
            json_indent = " " * 4  # 4 spaces per indent level in JSON5 output.
            for i, (comments, key, value) in enumerate(entries):
                for comm in comments:
                    result_lines.append(json_indent * (indent_level + 1) + "// " + comm)
                if isinstance(value, list):
                    result_lines.append(json_indent * (indent_level + 1) + f'"{key}": ' + "{")
                    nested_lines = build_json5(value, indent_level + 1)
                    result_lines.extend(nested_lines)
                    closing_line = json_indent * (indent_level + 1) + "}"
                    comma = "," if i < len(entries) - 1 else ""
                    result_lines.append(closing_line + comma)
                else:
                    # Quote the value if it is not a boolean or numeric.
                    if not (value in ["true", "false"] or re.match(r'^-?\d+(\.\d+)?$', value)):
                        if not ((value.startswith('"') and value.endswith('"')) or
                                (value.startswith("'") and value.endswith("'"))):
                            value = f'"{value}"'
                    comma = "," if i < len(entries) - 1 else ""
                    result_lines.append(json_indent * (indent_level + 1) + f'"{key}": {value}{comma}')
            return result_lines

        # Start with indent_level 0; build_json5 will add one indent level to root keys.
        json5_lines.extend(build_json5(parsed_entries, 0))
        json5_lines.append("}")
        return "\n".join(json5_lines)

    # Internally convert JSON5 to YAML for ease of editing.
    def read_from_disk(self) -> list:
        with open(self.path, 'r', encoding='utf-8') as f:
            raw_content = f.read()
            raw_content = raw_content.replace(r'\n', '\\n').replace(r'\r', '\\r')

            # Convert JSON5 to YAML using our custom parser.
            content = self.json5_to_yaml(raw_content)
            return content.splitlines()

    def save_file(self):
        final_content = ''

        for line in self.line_list:
            line = line['data']
            key_str = str(line['key']).strip()
            val_str = str(line['value']).strip()
            base_indent = " " * 2


            # Format empty values
            if val_str in ['""', "''", None]:
                val_str = ''

            # Ignore empty list items or multiline strings
            if (line['is_multiline_string'] or line['is_list_item']) and not val_str:
                continue

            if line['is_comment'] or line['is_blank_line']:
                indent = base_indent * line['indent']
                final_content += str(f"{indent}{key_str}".rstrip() + '\n')

            elif line['is_list_item'] and val_str:
                indent = base_indent * line['indent']
                final_content += str(f"{indent}- {val_str}".rstrip() + '\n')

            elif line['is_multiline_string'] and val_str:
                indent = base_indent * (line['indent'] + 2)
                final_content += str(f"{indent}{val_str}".rstrip() + '\n')

            elif line['is_header'] or line['is_list_header'] or not val_str:
                indent = base_indent * line['indent']
                final_content += str(f"{indent}{key_str}:".rstrip() + '\n')

            elif key_str and val_str:
                indent = base_indent * line['indent']
                final_content += str(f"{indent}{key_str}: {val_str}".rstrip() + '\n')

            elif key_str:
                indent = base_indent * line['indent']
                final_content += str(f"{indent}{key_str}:".rstrip() + '\n')


        try:
            # Convert the assembled YAML back into JSON5.
            json5_content = self.yaml_to_json5(final_content.strip())
        except Exception as e:
            if constants.debug:
                print(f"Failed to save: {e}")
            return False

        # Write the JSON5 back to disk
        # return print(json5_content)
        return self.write_to_disk(json5_content)



# Server Settings Screen ---------------------------------------------------------------------------------------------

def toggle_proxy(boolean, *args):
    server_obj = constants.server_manager.current_server
    server_obj.enable_proxy(boolean)

    # Show banner if server is running
    def default_message(*a):
        Clock.schedule_once(
            functools.partial(
                screen_manager.current_screen.show_banner,
                (0.553, 0.902, 0.675, 1) if boolean else (0.937, 0.831, 0.62, 1),
                f"playit proxy is {'en' if boolean else 'dis'}abled",
                "checkmark-circle-outline.png" if boolean else "close-circle-outline.png",
                2.5,
                {"center_x": 0.5, "center_y": 0.965}
            ), 0
        )

    try:
        if screen_manager.current_screen.check_changes(server_obj):
            Clock.schedule_once(
                functools.partial(
                    screen_manager.current_screen.show_banner,
                    (0.937, 0.831, 0.62, 1),
                    f"A server restart is required to apply changes",
                    "sync.png",
                    3,
                    {"center_x": 0.5, "center_y": 0.965}
                ), 0
            )
        else:
            default_message()

    except AttributeError:
        default_message()

class ServerWorldScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'

        self.new_world = 'world'
        self.new_seed = ''
        self.new_type = 'default'

    def generate_menu(self, **kwargs):
        server_obj = constants.server_manager.current_server

        # Return if no free space
        if disk_popup('ServerSettingsScreen', telepath_data=server_obj._telepath_data):
            return

        self.new_world = 'world'
        self.new_seed = ''
        self.new_type = 'default'

        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(InputLabel(pos_hint={"center_x": 0.5, "center_y": 0.67}))
        float_layout.add_widget(HeaderText("What world would you like to use?", 'This action will automatically create a back-up', (0, 0.83)))
        float_layout.add_widget(ServerWorldInput(pos_hint={"center_x": 0.5, "center_y": 0.58}))
        float_layout.add_widget(ServerSeedInput(pos_hint={"center_x": 0.5, "center_y": 0.462}))
        buttons.append(input_button('Browse...', (0.5, 0.58), ('dir', constants.saveFolder if os.path.isdir(constants.saveFolder) else constants.userDownloads), input_name='ServerWorldInput', title='Select a World File'))

        def change_type(type_name):
            self.new_type = type_name

        server_version = server_obj.version
        if constants.version_check(server_version, '>=', "1.1"):
            options = ['normal', 'superflat']
            if constants.version_check(server_version, '>=', "1.3.1"):
                options.append('large biomes')
            if constants.version_check(server_version, '>=', "1.7.2"):
                options.append('amplified')
            default_name = self.new_type.replace("default", "normal").replace("flat", "superflat").replace("large_biomes", "large biomes")
            float_layout.add_widget(DropButton(default_name, (0.5, 0.462), options_list=options, input_name='ServerSettingsLevelTypeInput', x_offset=41, custom_func=change_type))

        def change_world(*a):

            # Ignore world if it's the current server world
            if os.path.join(server_obj.server_path, server_obj.world) == self.new_world:
                Clock.schedule_once(
                    functools.partial(
                        screen_manager.current_screen.show_banner,
                        (0.937, 0.831, 0.62, 1),
                        f"The destination world can't be the current world",
                        "close-circle-outline.png",
                        2.5,
                        {"center_x": 0.5, "center_y": 0.965}
                    ), 0
                )
                return

            def change_thread(*a):
                def update_button(*a):
                    try:
                        screen_manager.current_screen.world_button.loading(True)
                    except:
                        pass
                Clock.schedule_once(update_button, 0)

                # If telepath, upload world here and return path
                if server_obj._telepath_data:
                    telepath_data = server_obj._telepath_data
                    if self.new_world != 'world':
                        new_path = constants.telepath_upload(telepath_data, self.new_world)['path']
                    else:
                        new_path = 'world'
                    constants.api_manager.request(
                        endpoint='/main/update_world',
                        host=telepath_data['host'],
                        port=telepath_data['port'],
                        args={
                            'path': new_path,
                            'new_type': self.new_type,
                            'new_seed': self.new_seed,
                            'telepath_data': telepath_data
                        }
                    )
                    constants.api_manager.request(endpoint='/main/clear_uploads', host=telepath_data['host'], port=telepath_data['port'])

                # If local, update normally
                else:
                    constants.update_world(self.new_world, self.new_type, self.new_seed)

                def update_ui(*a):
                    try:
                        screen_manager.current_screen.world_button.loading(False)
                    except:
                        pass
                    screen_manager.current_screen.show_banner(
                        (0.553, 0.902, 0.675, 1),
                        f"The server world has been changed successfully",
                        "checkmark-circle-outline.png",
                        2.5,
                        {"center_x": 0.5, "center_y": 0.965}
                    )

                Clock.schedule_once(update_ui, 0)

            previous_screen()
            constants.screen_tree.pop(-1)
            try:
                delete_button = screen_manager.current_screen.delete_button
                screen_manager.current_screen.scroll_widget.scroll_to(delete_button, animate=False)
            except:
                pass
            threading.Timer(0, change_thread).start()

        buttons.append(next_button('Next', (0.5, 0.24), False, next_screen='ServerSettingsScreen', click_func=change_world))
        buttons.append(ExitButton('Back', (0.5, 0.14), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        float_layout.add_widget(generate_title(f"Server Settings: '{server_obj.name}'"))
        float_layout.add_widget(generate_footer(f"{server_obj.name}, Settings, Change world"))

        self.add_widget(float_layout)

    def on_pre_enter(self, *args):
        super().on_pre_enter()
        self.toggle_new(True)

    # Call this when world loaded, and when the 'create new world instead' button is clicked. Fix overlapping when added/removed multiple times
    def toggle_new(self, boolean_value):
        server_obj = constants.server_manager.current_server

        current_input = ''
        server_version = server_obj.version

        for child in self.children:
            try:
                if child.id == 'content':
                    for item in child.children:
                        try:
                            if item.__class__.__name__ == 'ServerSeedInput':
                                current_input = 'input'
                                if self.new_world != 'world':
                                    child.remove_widget(item)

                                    try:
                                        if constants.version_check(server_version, '>=', "1.1"):
                                            child.remove_widget([relative for relative in child.children if relative.__class__.__name__ == 'DropButton'][0])
                                    except IndexError:
                                        if constants.debug:
                                            print("Error: 'DropButton' does not exist, can't remove")

                            elif item.id == 'Create new world instead':
                                current_input = 'button'
                                if self.new_world == 'world':
                                    child.remove_widget(item)
                        except AttributeError:
                            continue

                    # Show button if true
                    if boolean_value and self.new_world != 'world' and current_input == 'input':
                        child.add_widget(MainButton('Create new world instead', (0.5, 0.442), 'add-circle-outline.png', width=530))

                    # Show seed input, and clear world text
                    elif self.new_world == 'world' and current_input == 'button':
                        child.add_widget(ServerSeedInput(pos_hint={"center_x": 0.5, "center_y": 0.442}))

                        if constants.version_check(server_version, '>=', "1.1"):
                            options = ['normal', 'superflat']
                            if constants.version_check(server_version, '>=', "1.3.1"):
                                options.append('large biomes')
                            if constants.version_check(server_version, '>=', "1.7.2"):
                                options.append('amplified')
                            default_name = self.new_type.replace("default", "normal").replace("flat", "superflat").replace("large_biomes", "large biomes")
                            child.add_widget(DropButton(default_name, (0.5, 0.442), options_list=options, input_name='ServerSettingsLevelTypeInput', x_offset=41))
                    break

            except AttributeError:
                pass

class ServerSettingsScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'

        self.scroll_widget = None
        self.header = None
        self.title_widget = None
        self.footer_widget = None
        self.menu_taskbar = None

        self.config_button = None
        self.open_path_button = None
        self.update_button = None
        self.update_label = None
        self.proxy_button = None
        self.rename_input = None
        self.delete_button = None
        self.world_button = None

    def check_changes(self, server_obj, force_banner=False):
        if server_obj.running:
            # print(server_obj.run_data['advanced-hash'], server_obj._get_advanced_hash(), sep="\n")
            if server_obj.run_data and server_obj.run_data['advanced-hash'] != server_obj._get_advanced_hash():
                if "[font=" not in self.header.text.text:
                    icons = os.path.join(constants.gui_assets, 'fonts', constants.fonts['icons'])
                    self.header.text.text = f"[color=#EFD49E][font={icons}]y[/font] " + self.header.text.text + "[/color]"
                    if force_banner:
                        Clock.schedule_once(
                            functools.partial(
                                screen_manager.current_screen.show_banner,
                                (0.937, 0.831, 0.62, 1),
                                f"A server restart is required to apply changes",
                                "sync.png",
                                3,
                                {"center_x": 0.5, "center_y": 0.965}
                            ), 0
                        )
                return True

            else:
                if "[font=" in self.header.text.text:
                    self.header.text.text = self.header.text.text.split("[/font] ")[1].split("[/color]")[0].strip()

        return False

    def generate_menu(self, **kwargs):
        server_obj = constants.server_manager.current_server
        server_obj.reload_config()

        # Scroll list
        scroll_widget = ScrollViewWidget()
        self.scroll_widget = scroll_widget
        scroll_anchor = AnchorLayout()
        scroll_layout = GridLayout(cols=1, spacing=10, size_hint_max_x=1175, size_hint_y=None, padding=[0, -50, 0, 60])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 1.5
            call_widget.pos_hint = {"center_y": 0.5}
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        scroll_layout.bind(minimum_height=scroll_layout.setter('height'))
        scroll_layout.id = 'scroll_content'

        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.84}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60))
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.17}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60))

        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'

        pgh_font = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["mono-medium"]}.otf')

        # Create and add paragraphs to GridLayout
        def create_paragraph(name, layout, cid, center_y):

            sub_layout = ScrollItem()
            content_size = sp(22)
            content_height = sum([(child.height + (layout.spacing[0]*2)) for child in layout.children])
            paragraph = paragraph_object(size=(530, content_height), name=name, content=' ', font_size=content_size, font=pgh_font)
            sub_layout.height = paragraph.height + 80

            sub_layout.add_widget(paragraph)
            sub_layout.add_widget(layout)
            layout.pos_hint = {'center_x': 0.5, 'center_y': center_y}
            scroll_layout.add_widget(sub_layout)


        # ----------------------------------------------- General ------------------------------------------------------

        general_layout = GridLayout(cols=1, spacing=10, size_hint_max_x=1050, size_hint_y=None, padding=[0, 0, 0, 0])

        if server_obj.type == 'vanilla':
            # Edit properties button
            def edit_server_properties(*args):
                open_config_file(constants.server_path(server_obj.name, 'server.properties'))
            self.config_button = WaitButton("Edit 'server.properties'", (0.5, 0.5), 'document-text-outline.png', click_func=edit_server_properties)
        else:
            # Edit config button
            def open_config_menu(*args):
                screen_manager.current = 'ServerConfigScreen'
            self.config_button = WaitButton("Edit Configuration Files", (0.5, 0.5), 'document-text-outline.png', click_func=open_config_menu)

        sub_layout = ScrollItem()
        sub_layout.add_widget(self.config_button)
        general_layout.add_widget(sub_layout)


        if server_obj._telepath_data:
            def download_server(*a):
                def download_thread():
                    if screen_manager.current_screen.name == 'ServerSettingsScreen':
                        download_button = screen_manager.current_screen.download_button
                        if download_button:
                            Clock.schedule_once(functools.partial(download_button.loading, True), 0)

                    path = os.path.join(server_obj.backup.directory, server_obj.backup.save()[0])
                    location = constants.telepath_download(server_obj._telepath_data, path, constants.userDownloads)
                    if os.path.exists(location):
                        constants.open_folder(location)
                        Clock.schedule_once(
                            functools.partial(
                                screen_manager.current_screen.show_banner,
                                (0.553, 0.902, 0.675, 1),
                                f"Downloaded $'{server_obj._view_name}'$ successfully",
                                "cloud-download-sharp.png",
                                3,
                                {"center_x": 0.5, "center_y": 0.965}
                            ), 1
                        )

                    if screen_manager.current_screen.name == 'ServerSettingsScreen':
                        download_button = screen_manager.current_screen.download_button
                        if download_button:
                            Clock.schedule_once(functools.partial(download_button.loading, False), 0)

                threading.Timer(0, download_thread).start()

            sub_layout = ScrollItem()
            self.download_button = WaitButton('Download Server', (0.5, 0.5), 'cloud-download-sharp.png', click_func=download_server)
            sub_layout.add_widget(self.download_button)
            general_layout.add_widget(sub_layout)

        else:

            # Open server directory
            def open_server_dir(*args):
                constants.open_folder(server_obj.server_path)
                Clock.schedule_once(self.open_path_button.button.on_leave, 0.5)

            sub_layout = ScrollItem()
            self.open_path_button = WaitButton('Open Server Directory', (0.5, 0.5), 'folder-outline.png', click_func=open_server_dir)
            sub_layout.add_widget(self.open_path_button)
            general_layout.add_widget(sub_layout)


        # RAM allocation slider (Max limit = 75% of memory capacity)
        max_limit = constants.get_remote_var('max_memory', server_obj._telepath_data)
        min_limit = 0
        start_value = min_limit if str(server_obj.dedicated_ram) == 'auto' else int(server_obj.dedicated_ram)

        def change_limit(val):
            server_obj.set_ram_limit('auto' if val == min_limit else val)
            self.check_changes(server_obj, force_banner=True)

        sub_layout = ScrollItem()
        sub_layout.add_widget(blank_input(pos_hint={"center_x": 0.5, "center_y": 0.5}, hint_text="memory usage  (GB)"))
        sub_layout.add_widget(NumberSlider(start_value, (0.5, 0.5), input_name='RamInput', limits=(min_limit, max_limit), min_icon='auto-icon.png', function=change_limit))
        general_layout.add_widget(sub_layout)


        # JVM flags
        sub_layout = ScrollItem()
        sub_layout.add_widget(InputLabel(pos_hint={"center_x": 0.5, "center_y": 1.1}))
        flag_input = ServerFlagInput(pos_hint={'center_x': 0.5, 'center_y': 0.5})
        flag_input.size_hint_max_x = 435
        sub_layout.add_widget(flag_input)
        general_layout.add_widget(sub_layout)


        create_paragraph('general', general_layout, 0, 0.65)

        # --------------------------------------------------------------------------------------------------------------



        # ----------------------------------------------- Network ------------------------------------------------------

        network_layout = GridLayout(cols=1, spacing=10, size_hint_max_x=1050, size_hint_y=None, padding=[0, 0, 0, 0])

        # MOTD Input
        sub_layout = ScrollItem()
        sub_layout.add_widget(InputLabel(pos_hint={"center_x": 0.5, "center_y": 1.2}))
        motd_input = ServerMOTDInput(pos_hint={'center_x': 0.5, 'center_y': 0.5})
        motd_input.size_hint_max_x = 435
        sub_layout.add_widget(motd_input)
        network_layout.add_widget(sub_layout)


        # Edit IP/Port input
        sub_layout = ScrollItem()
        sub_layout.add_widget(InputLabel(pos_hint={"center_x": 0.5, "center_y": 1.1}))
        port_input = ServerPortInput(pos_hint={'center_x': 0.5, 'center_y': 0.5}, text=process_ip_text(server_obj=server_obj))
        port_input.size_hint_max_x = 435
        sub_layout.add_widget(port_input)
        network_layout.add_widget(sub_layout)


        # Playit toggle/install button
        def add_switch(index=0, fade=False, *a):
            sub_layout = ScrollItem()
            state = server_obj.proxy_enabled
            input_border = blank_input(pos_hint={"center_x": 0.5, "center_y": 0.5}, hint_text='enable proxy (playit)', disabled=(not constants.app_online))
            sub_layout.add_widget(input_border)
            sub_layout.add_widget(toggle_button('proxy', (0.5, 0.5), custom_func=toggle_proxy, default_state=server_obj.proxy_enabled, disabled=(not constants.app_online)))
            network_layout.add_widget(sub_layout, index)
            if fade:
                input_border.opacity = 0
                Animation(opacity=1, duration=0.5).start(input_border)

        if not server_obj.proxy_installed():
            def prompt_install(*args):
                def install_wrapper(*a):
                    Clock.schedule_once(functools.partial(self.proxy_button.loading, True), 0)
                    boolean = server_obj.install_proxy()

                    def add_widgets(*b):
                        self.proxy_button.loading(False)
                        network_layout.remove_widget(self.proxy_button.parent)
                        add_switch(1, True)
                        Clock.schedule_once(
                            functools.partial(
                                screen_manager.current_screen.show_banner,
                                (0.553, 0.902, 0.675, 1) if boolean else (0.937, 0.831, 0.62, 1),
                                f"playit was {'installed successfully' if boolean else 'not installed'}",
                                "checkmark-circle-outline.png" if boolean else "close-circle-outline.png",
                                2.5,
                                {"center_x": 0.5, "center_y": 0.965}
                            ), 0
                        )
                    Clock.schedule_once(add_widgets, 0)

                if constants.app_online:
                    Clock.schedule_once(
                        functools.partial(
                            self.show_popup,
                            "query",
                            "Install playit",
                            "playit is a free proxy service that creates a tunnel to the internet. It can be used to bypass ISP port blocking or conflicts in which the client refuses to connect (e.g. strict NAT).\n\nWould you like to install playit?",
                            (None, threading.Timer(0, install_wrapper).start)
                        ),
                        0
                    )
                else:
                    self.show_popup('warning', 'Error', 'An internet connection is required to install playit\n\nPlease check your connection and try again', (None))

            sub_layout = ScrollItem()
            self.proxy_button = WaitButton('Install playit', (0.5, 0.5), 'earth.png', click_func=prompt_install)
            sub_layout.add_widget(self.proxy_button)
            network_layout.add_widget(sub_layout)
        else:
            add_switch()


        # Enable Geyser toggle switch
        def toggle_geyser(boolean, install=True):
            if install:
                server_obj.addon._install_geyser(boolean)

                # Actually make changes
                server_obj.config_file.set("general", "enableGeyser", str(boolean).lower())
                server_obj.write_config()
                server_obj.geyser_enabled = boolean

                # Show banner if server is running
                if screen_manager.current_screen.check_changes(server_obj):
                    Clock.schedule_once(
                        functools.partial(
                            screen_manager.current_screen.show_banner,
                            (0.937, 0.831, 0.62, 1),
                            f"A server restart is required to apply changes",
                            "sync.png",
                            3,
                            {"center_x": 0.5, "center_y": 0.965}
                        ), 0
                    )

                else:
                    Clock.schedule_once(
                        functools.partial(
                            screen_manager.current_screen.show_banner,
                            (0.553, 0.902, 0.675, 1) if boolean else (0.937, 0.831, 0.62, 1),
                            f"Bedrock support {'en' if boolean else 'dis'}abled",
                            "checkmark-circle-outline.png" if boolean else "close-circle-outline.png",
                            2.5,
                            {"center_x": 0.5, "center_y": 0.965}
                        ), 0
                    )

        # Geyser switch for bedrock support
        sub_layout = ScrollItem()
        disabled = not (constants.version_check(server_obj.version, ">=", "1.13.2") and server_obj.type.lower() in ['spigot', 'paper', 'purpur', 'fabric', 'quilt', 'neoforge'])
        hint_text = "geyser (unsupported server)" if disabled else "bedrock support (geyser)"
        if not constants.app_online:
            disabled = True
        sub_layout.add_widget(blank_input(pos_hint={"center_x": 0.5, "center_y": 0.5}, hint_text=hint_text, disabled=disabled))
        sub_layout.add_widget(toggle_button('geyser', (0.5, 0.5), custom_func=toggle_geyser, disabled=disabled, default_state=(server_obj.geyser_enabled) and not disabled))
        network_layout.add_widget(sub_layout)


        create_paragraph('network', network_layout, 1, 0.65)

        # --------------------------------------------------------------------------------------------------------------



        # ------------------------------------------------ Updates -----------------------------------------------------

        update_layout = GridLayout(cols=1, spacing=10, size_hint_max_x=1050, size_hint_y=None, padding=[0, 0, 0, 0])

        # Automatic updates toggle
        def toggle_auto_update(boolean, *a):
            server_obj.enable_auto_update(boolean)
            Clock.schedule_once(
                functools.partial(
                    screen_manager.current_screen.show_banner,
                    (0.553, 0.902, 0.675, 1) if boolean else (0.937, 0.831, 0.62, 1),
                    f"Automatic server updates {'en' if boolean else 'dis'}abled",
                    "checkmark-circle-outline.png" if boolean else "close-circle-outline.png",
                    2.5,
                    {"center_x": 0.5, "center_y": 0.965}
                ), 0
            )

        disabled = server_obj.is_modpack and server_obj.is_modpack != 'mrpack'
        sub_layout = ScrollItem()
        sub_layout.add_widget(blank_input(pos_hint={"center_x": 0.5, "center_y": 0.5}, hint_text='automatic updates', disabled=disabled))
        sub_layout.add_widget(toggle_button('auto-update', (0.5, 0.5), custom_func=toggle_auto_update, default_state=server_obj.auto_update == 'true', disabled=disabled))
        update_layout.add_widget(sub_layout)

        disabled = server_obj.running or not constants.app_online

        # Updates server
        def update_server(*a):
            if server_obj.is_modpack == 'mrpack':
                update_url = ''
                if server_obj._telepath_data:
                    try:
                        update_url = constants.server_manager.get_telepath_update(server_obj._telepath_data, server_obj.name)['updateUrl']
                    except KeyError:
                        pass
                else:
                    update_url = constants.update_list[server_obj.name]['updateUrl']
                if update_url:
                    constants.import_data = {
                        'name': server_obj.name,
                        'url': update_url
                    }
                    os.chdir(constants.get_cwd())
                    constants.safe_delete(constants.tempDir)
                    screen_manager.current = 'UpdateModpackProgressScreen'

            else:
                constants.new_server_init()
                constants.init_update()
                constants.new_server_info['type'] = server_obj.type
                constants.new_server_info['version'] = constants.latestMC[server_obj.type]
                if server_obj.type in ['forge', 'paper']:
                    constants.new_server_info['build'] = constants.latestMC['builds'][server_obj.type]
                screen_manager.current = 'MigrateServerProgressScreen'

        # Check for updates button
        sub_layout = ScrollItem()

        if server_obj._telepath_data:
            while not constants.server_manager.get_telepath_update(server_obj._telepath_data, server_obj.name):
                constants.server_manager.reload_telepath_updates(server_obj._telepath_data)
                time.sleep(0.5)
        else:
            while server_obj.name not in constants.update_list:
                time.sleep(0.1)

        # First check if the server is a '.zip' format modpack
        needs_update = False
        if server_obj._telepath_data:
            try:
                needs_update = constants.server_manager.get_telepath_update(server_obj._telepath_data, server_obj.name)['needsUpdate'] == 'true'
            except KeyError:
                pass
        else:
            needs_update = constants.update_list[server_obj.name]['needsUpdate'] == 'true'


        if server_obj.is_modpack == 'zip':
            def select_file(*a):
                zip_file = file_popup("file", start_dir=constants.userDownloads, ext=["*.zip", "*.mrpack"], input_name=None, select_multiple=True, title='Select a modpack update')
                if zip_file:
                    zip_file = zip_file[0]
                    if zip_file.endswith('.zip') or zip_file.endswith('.mrpack'):
                        constants.import_data = {
                            'name': server_obj.name,
                            'path': os.path.abspath(zip_file)
                        }
                        os.chdir(constants.get_cwd())
                        constants.safe_delete(constants.tempDir)
                        screen_manager.current = 'UpdateModpackProgressScreen'
                    else:
                        self.update_label.update_text('Invalid file type')

            self.update_label = InputLabel(pos_hint={"center_x": 0.5, "center_y": 1.05})
            disabled = (not constants.app_online) or server_obj.running
            self.update_button = WaitButton("Update from '.zip'", (0.5, 0.5), 'modpack.png', disabled=disabled, click_func=select_file)


        elif needs_update:
            if 'settings' in server_obj.viewed_notifs:
                if server_obj.viewed_notifs['settings'] != server_obj.update_string:
                    Clock.schedule_once(
                        functools.partial(
                            self.show_banner,
                            (0.553, 0.902, 0.675, 1),
                            f"A server update is available",
                            "arrow-up-circle-sharp.png",
                            2.5,
                            {"center_x": 0.5, "center_y": 0.965}
                        ), 0
                    )
            server_obj._view_notif('settings', viewed=server_obj.update_string)
            self.update_button = WaitButton(f"Update to ${server_obj.update_string}$", (0.5, 0.5), 'arrow-up-circle-outline.png', disabled=disabled, click_func=update_server)

        # No updates are available
        else:
            self.update_button = WaitButton('Up to date', (0.5, 0.5), 'checkmark-circle.png', disabled=True)
            Animation.stop_all(self.update_button.icon)
            self.update_button.icon.opacity = 0.5

        sub_layout.add_widget(self.update_button)
        try:
            if self.update_label:
                sub_layout.add_widget(self.update_label)
        except:
            pass
        update_layout.add_widget(sub_layout)


        # Change 'server.jar' button
        def migrate_server(*a):
            constants.new_server_init()
            constants.new_server_info['type'] = server_obj.type
            constants.new_server_info['version'] = server_obj.version
            screen_manager.current = 'MigrateServerTypeScreen'

        sub_layout = ScrollItem()
        sub_layout.add_widget(WaitButton("Change 'server.jar'", (0.5, 0.5), 'swap-horizontal-outline.png', disabled=disabled or server_obj.is_modpack, click_func=migrate_server))
        update_layout.add_widget(sub_layout)


        create_paragraph('updates', update_layout, 0, 0.555)

        # --------------------------------------------------------------------------------------------------------------



        # ----------------------------------------------- Transilience -------------------------------------------------

        transilience_layout = GridLayout(cols=1, spacing=10, size_hint_max_x=1050, size_hint_y=None, padding=[0, 0, 0, 0])

        def rename_server(name, *args):
            def loading_screen(*a):
                screen_manager.current = 'BlurredLoadingScreen'
            Clock.schedule_once(loading_screen, 0)

            # Actually rename the server files
            server_obj.rename(name)

            # Change header and footer text to reflect change
            def change_data(*a):
                def go_back(*a):
                    screen_manager.current = 'ServerSettingsScreen'
                    effect_y = screen_manager.current_screen.scroll_widget.effect_y
                    screen_manager.current_screen.scroll_widget.effect_y = None
                    screen_manager.current_screen.scroll_widget.scroll_y = 0
                    def reset_effect(*a):
                        screen_manager.current_screen.scroll_widget.effect_y = effect_y
                    Clock.schedule_once(reset_effect, 0)
                Clock.schedule_once(go_back, 0)

                self.remove_widget(self.title_widget)
                self.remove_widget(self.footer_widget)
                del self.title_widget
                del self.footer_widget
                self.title_widget = generate_title(f"Server Settings: '{name}'")
                self.footer_widget = generate_footer(f"{name}, Settings", color='EFD49E')
                self.add_widget(self.title_widget)
                self.add_widget(self.footer_widget)

                # Display banner to show success
                Clock.schedule_once(
                    functools.partial(
                        screen_manager.current_screen.show_banner,
                        (0.553, 0.902, 0.675, 1),
                        f"Server renamed to '${name}$' successfully!",
                        "rename.png",
                        2.5,
                        {"center_x": 0.5, "center_y": 0.965}
                    ), 0
                )
            Clock.schedule_once(change_data, 0)
        def rename_thread(name, *a):
            threading.Timer(0, functools.partial(rename_server, name)).start()

        # Rename server input
        sub_layout = ScrollItem()
        input_label = InputLabel(pos_hint={"center_x": 0.5, "center_y": 1.2})
        sub_layout.add_widget(input_label)
        self.rename_input = ServerRenameInput(pos_hint={'center_x': 0.5, 'center_y': 0.5}, text=server_obj.name, on_validate=rename_thread, disabled=server_obj.running)
        self.rename_input.size_hint_max_x = 435
        sub_layout.add_widget(self.rename_input)
        transilience_layout.add_widget(sub_layout)

        if server_obj.running:
            input_label.update_text("Server is running", True)


        # Change world file
        def change_world(*a):
            if constants.server_manager.current_server:
                screen_manager.current = 'ServerWorldScreen'

        sub_layout = ScrollItem()
        self.world_button = WaitButton("Change world file", (0.5, 0.5), 'world.png', click_func=change_world, disabled=server_obj.running)
        sub_layout.add_widget(self.world_button)
        transilience_layout.add_widget(sub_layout)


        # Delete server button
        def delete_server(*args):
            def loading_screen(*a):
                screen_manager.current = 'BlurredLoadingScreen'
            Clock.schedule_once(loading_screen, 0)

            server_name = server_obj.name
            server_obj.delete()
            constants.server_manager.current_server = None

            def switch_screens(*a):
                constants.server_manager.refresh_list()
                screen_manager.current = "ServerManagerScreen"
                constants.screen_tree = ['MainMenuScreen']

                Clock.schedule_once(
                    functools.partial(
                        screen_manager.current_screen.show_banner,
                        (1, 0.5, 0.65, 1),
                        f"'${server_name}$' was deleted successfully",
                        "trash-sharp.png",
                        3,
                        {"center_x": 0.5, "center_y": 0.965}
                    ), 0.1
                )
            Clock.schedule_once(switch_screens, 0.5)
        def timer_delete(*a):
            threading.Timer(0, delete_server).start()
        def prompt_delete(*args):
            Clock.schedule_once(
                functools.partial(
                    screen_manager.current_screen.show_popup,
                    "warning_query",
                    f"Delete '${server_obj.name}$'",
                    "Do you want to permanently delete this server?\n\nThis action cannot be undone\n(Your server can be re-imported from a back-up later)",
                    (None, functools.partial(Clock.schedule_once, timer_delete, 0.5))
                ),
                0
            )

        sub_layout = ScrollItem()
        self.delete_button = color_button('Delete Server', (0.5, 0.5), 'trash-sharp.png', click_func=prompt_delete, color=(1, 0.5, 0.65, 1), disabled=server_obj.running)
        sub_layout.add_widget(self.delete_button)
        transilience_layout.add_widget(sub_layout)


        create_paragraph('transilience', transilience_layout, 0, 0.555)

        # --------------------------------------------------------------------------------------------------------------



        # Append scroll view items
        scroll_anchor.add_widget(scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)


        # Server Preview Box
        # float_layout.add_widget(server_demo_input(pos_hint={"center_x": 0.5, "center_y": 0.81}, properties=constants.new_server_info))


        # Configure header
        header_content = "Modify server configuration"
        self.header = HeaderText(header_content, '', (0, 0.89))
        self.check_changes(server_obj, force_banner=True)
        float_layout.add_widget(self.header)


        # if server_obj.advanced_hash_changed():
        #     icons = os.path.join(constants.gui_assets, 'fonts', constants.fonts['icons'])
        #     header_content = f"[color=#EFD49E][font={icons}]y[/font] " + header_content + "[/color]"


        buttons.append(ExitButton('Back', (0.5, -1), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        self.title_widget = generate_title(f"Server Settings: '{server_obj.name}'")
        self.footer_widget = generate_footer(f"{server_obj.name}, Settings", color='EFD49E')
        self.add_widget(self.title_widget)
        self.add_widget(self.footer_widget)

        self.add_widget(float_layout)

        # Add ManuTaskbar
        self.menu_taskbar = MenuTaskbar(selected_item='settings')
        self.add_widget(self.menu_taskbar)

# Update/Migrate server screens
class MigrateServerTypeScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.current_selection = 'vanilla'
        self.content_layout_1 = None
        self.content_layout_2 = None

    def generate_menu(self, **kwargs):
        server_obj = constants.server_manager.current_server

        # Return if no free space or telepath is busy
        if disk_popup('ServerSettingsScreen', telepath_data=server_obj._telepath_data):
            return
        if telepath_popup('ServerSettingsScreen'):
            return


        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'

        float_layout.add_widget(HeaderText("Which distribution would you like to switch to?", 'This action will automatically create a back-up', (0, 0.89)))

        # Create UI buttons
        buttons.append(next_button('Next', (0.5, 0.21), False, next_screen='MigrateServerVersionScreen'))
        buttons.append(ExitButton('Back', (0.5, 0.12), cycle=True))

        self.current_selection = constants.new_server_info['type']


        # Create type buttons (Page 1)
        self.content_layout_1 = FloatLayout()
        row_top = BoxLayout()
        row_bottom = BoxLayout()
        row_top.pos_hint = {"center_y": 0.66, "center_x": 0.5}
        row_bottom.pos_hint = {"center_y": 0.405, "center_x": 0.5}
        row_bottom.size_hint_max_x = row_top.size_hint_max_x = dp(1000)
        row_top.orientation = row_bottom.orientation = "horizontal"
        row_top.add_widget(big_icon_button('runs most plug-ins, optimized', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'paper', clickable=True, selected=('paper' == constants.new_server_info['type'])))
        row_top.add_widget(big_icon_button('default, stock experience', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'vanilla', clickable=True, selected=('vanilla' == constants.new_server_info['type'])))
        row_top.add_widget(big_icon_button('modded experience', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'forge', clickable=True, selected=('forge' == constants.new_server_info['type'])))
        row_bottom.add_widget(big_icon_button('performant fork of paper', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'purpur', clickable=True, selected=('purpur' == constants.new_server_info['type'])))
        row_bottom.add_widget(big_icon_button('modern mod platform', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'fabric', clickable=True, selected=('fabric' == constants.new_server_info['type'])))
        row_bottom.add_widget(big_icon_button('view more options', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'more', clickable=True, selected=False))
        self.content_layout_1.add_widget(row_top)
        self.content_layout_1.add_widget(row_bottom)


        # Create type buttons (Page 2)
        self.content_layout_2 = FloatLayout()
        constants.hide_widget(self.content_layout_2)
        row_top = BoxLayout()
        row_bottom = BoxLayout()
        row_top.pos_hint = {"center_y": 0.66, "center_x": 0.5}
        row_bottom.pos_hint = {"center_y": 0.405, "center_x": 0.5}
        row_top.size_hint_max_x = dp(1000)
        row_bottom.size_hint_max_x = dp(650)
        row_top.orientation = row_bottom.orientation = "horizontal"
        row_top.add_widget(big_icon_button('modern $Forge$ implementation', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'neoforge', clickable=True, selected=('neoforge' == constants.new_server_info['type'])))
        row_top.add_widget(big_icon_button('enhanced fork of $Fabric$', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'quilt', clickable=True, selected=('quilt' == constants.new_server_info['type'])))
        row_top.add_widget(big_icon_button('requires tuning, but efficient', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'spigot', clickable=True, selected=('spigot' == constants.new_server_info['type'])))
        row_bottom.add_widget(big_icon_button('legacy, supports plug-ins', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'craftbukkit', clickable=True, selected=('craftbukkit' == constants.new_server_info['type'])))
        row_bottom.add_widget(big_icon_button('view more options', {"center_y": 0.5, "center_x": 0.5}, (0, 0), (None, None), 'more', clickable=True, selected=False))
        self.content_layout_2.add_widget(row_top)
        self.content_layout_2.add_widget(row_bottom)


        for button in buttons:
            float_layout.add_widget(button)

        float_layout.add_widget(self.content_layout_1)
        float_layout.add_widget(self.content_layout_2)
        float_layout.add_widget(page_counter(1, 2, (0, 0.86)))
        float_layout.add_widget(generate_title(f"Server Settings: '{server_obj.name}'"))
        float_layout.add_widget(generate_footer(f"{server_obj.name}, Settings, Change 'server.jar'"))

        self.add_widget(float_layout)

class MigrateServerVersionScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'

        self.final_button = None

    def generate_menu(self, **kwargs):
        server_obj = constants.server_manager.current_server

        # Generate buttons on page load
        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'

        # Prevent server creation if offline
        if not constants.app_online:
            float_layout.add_widget(HeaderText("Changing the 'server.jar' requires an internet connection", '', (0, 0.6)))
            buttons.append(ExitButton('Back', (0.5, 0.35)))

        # Regular menus
        else:
            def update_next(boolean_value, message, *a):

                if message:
                    for child in float_layout.children:
                        if "ServerVersionInput" in child.__class__.__name__:
                            child.focus = False
                            child.valid(boolean_value, message)

                self.final_button.disable(not boolean_value)

            def migrate_server(*a):

                def start_migration(*a):
                    def main_thread(*b):
                        screen_manager.current = "MigrateServerProgressScreen"
                    Clock.schedule_once(functools.partial(self.final_button.loading, True), 0)
                    constants.init_update()
                    Clock.schedule_once(main_thread, 0)

                def check_version(*args, **kwargs):
                    self.final_button.loading(True)
                    version_data = constants.search_version(constants.new_server_info)
                    constants.new_server_info['version'] = version_data[1]['version']
                    constants.new_server_info['build'] = version_data[1]['build']
                    constants.new_server_info['jar_link'] = version_data[3]
                    self.final_button.loading(False)
                    Clock.schedule_once(functools.partial(update_next, version_data[0], version_data[2]), 0)

                    # Continue to next screen if valid input, and back button not pressed
                    if version_data[0] and not version_data[2] and screen_manager.current == 'MigrateServerVersionScreen':
                        if constants.version_check(constants.new_server_info['version'], '<', server_obj.version):
                            Clock.schedule_once(
                                functools.partial(
                                    screen_manager.current_screen.show_popup,
                                    "warning_query",
                                    f'Downgrade Warning',
                                    "Downgrading can corrupt the save file and crash until it's replaced.\n\nDo you really wish to downgrade?",
                                    (None, start_migration)
                                ),
                                0
                            )
                        else:
                            start_migration()

                timer = threading.Timer(0, function=check_version)
                timer.start()

            float_layout.add_widget(InputLabel(pos_hint={"center_x": 0.5, "center_y": 0.57}))
            float_layout.add_widget(page_counter(2, 2, (0, 0.77)))
            float_layout.add_widget(HeaderText("What version of Minecraft would you like to switch to?", f'Current version:  ${server_obj.version}$', (0, 0.8)))
            self.final_button = WaitButton("Change 'server.jar'", (0.5, 0.24), 'swap-horizontal-outline.png', click_func=migrate_server)
            float_layout.add_widget(ServerVersionInput(pos_hint={"center_x": 0.5, "center_y": 0.49}, text=constants.new_server_info['version'], enter_func=migrate_server))
            self.add_widget(self.final_button)
            buttons.append(ExitButton('Back', (0.5, 0.14), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        float_layout.add_widget(generate_title(f"Server Settings: '{server_obj.name}'"))
        float_layout.add_widget(generate_footer(f"{server_obj.name}, Settings, Change 'server.jar'"))

        self.add_widget(float_layout)

class MigrateServerProgressScreen(ProgressScreen):

    # Only replace this function when making a child screen
    # Set fail message in child functions to trigger an error
    def contents(self):
        server_obj = constants.server_manager.current_server
        if constants.new_server_info['type'] != server_obj.type:
            desc_text = "Migrating"
            final_text = "Migrated"
            "migrating '$$'"
            "migrated '$$' successfully"
        elif constants.version_check(constants.new_server_info['version'], '<', server_obj.version):
            desc_text = "Downgrading"
            final_text = "Downgraded"
            "downgrading '$$'"
            "downgraded '$$' successfully"
        elif constants.version_check(constants.new_server_info['version'], '>', server_obj.version) or server_obj.update_string.startswith('b-'):
            desc_text = "Updating"
            final_text = "Updated"
            "updating '$$'"
            "updated '$$' successfully"
        else:
            desc_text = "Reinstalling"
            final_text = "Reinstalled"
            "reinstalling '$$'"
            "reinstalled '$$' successfully"

        def before_func(*args):

            if not constants.app_online:
                self.execute_error("An internet connection is required to continue\n\nVerify connectivity and try again")

            elif not constants.check_free_space(telepath_data=server_obj._telepath_data):
                self.execute_error("Your primary disk is almost full\n\nFree up space and try again")

            else:
                telepath_data = server_obj._telepath_data
                if telepath_data:
                    response = constants.api_manager.request(
                        endpoint='/create/push_new_server',
                        host=telepath_data['host'],
                        port=telepath_data['port'],
                        args={'server_info': constants.new_server_info}
                    )
                constants.pre_server_update()


        def after_func(*args):
            constants.post_server_update()
            self.open_server(server_obj.name, True, f"{final_text} '${server_obj.name}$' successfully", launch=self.page_contents['launch'])


        # Original is percentage before this function, adjusted is a percent of hooked value
        def adjust_percentage(*args):
            original = self.last_progress
            adjusted = args[0]
            total = args[1] * 0.01
            final = original + round(adjusted * total)
            if final < 0:
                final = original
            self.progress_bar.update_progress(final)

        self.page_contents = {
            'launch': False,

            # Page name
            'title': f"{desc_text} '{server_obj.name}'",

            # Header text
            'header': "Sit back and relax, it's automation time...",

            # Tuple of tuples for steps (label, function, percent)
            # Percent of all functions must total 100
            # Functions must return True, or default error will be executed
            'default_error': 'There was an issue, please try again later',

            'function_list': (),

            # Function to run before steps (like checking for an internet connection)
            'before_function': before_func,

            # Function to run after everything is complete (like cleaning up the screen tree) will only run if no error
            'after_function': after_func,

            # Screen to go to after complete
            'next_screen': None
        }

        # Create function list
        java_text = 'Verifying Java Installation' if os.path.exists(constants.javaDir) else 'Installing Java'
        function_list = [
            (java_text, functools.partial(constants.java_check, functools.partial(adjust_percentage, 30)), 0),
            ("Downloading 'server.jar'", functools.partial(constants.download_jar, functools.partial(adjust_percentage, 30)), 0)
        ]

        download_addons = False
        needs_installed = False

        if constants.new_server_info['type'] != 'vanilla':
            download_addons = constants.new_server_info['addon_objects'] or constants.new_server_info['server_settings']['disable_chat_reporting'] or constants.new_server_info['server_settings']['geyser_support'] or (constants.new_server_info['type'] in ['fabric', 'quilt'])
            needs_installed = constants.new_server_info['type'] in ['forge', 'neoforge', 'fabric', 'quilt']

        if needs_installed:
            function_list.append((f'Installing ${constants.new_server_info["type"].title().replace("forge","Forge")}$', functools.partial(constants.install_server), 10 if download_addons else 20))

        if download_addons:
            function_list.append((f'{desc_text} add-ons', functools.partial(constants.iter_addons, functools.partial(adjust_percentage, 10 if needs_installed else 20), True), 0))

        function_list.append(('Creating pre-install back-up', functools.partial(constants.create_backup), 5 if (download_addons or needs_installed) else 10))

        function_list.append(('Applying new configuration', functools.partial(constants.update_server_files), 10 if (download_addons or needs_installed) else 20))

        function_list.append(('Creating post-install back-up', functools.partial(constants.create_backup), 5 if (download_addons or needs_installed) else 10))

        self.page_contents['function_list'] = tuple(function_list)

class UpdateModpackProgressScreen(ProgressScreen):

    # Only replace this function when making a child screen
    # Set fail message in child functions to trigger an error
    def contents(self):
        server_obj = constants.server_manager.current_server

        def before_func(*args):

            # First, clean out any existing server in temp folder
            os.chdir(constants.get_cwd())
            constants.safe_delete(constants.tempDir)

            if not constants.app_online:
                self.execute_error("An internet connection is required to continue\n\nVerify connectivity and try again")

            elif not constants.check_free_space(telepath_data=server_obj._telepath_data):
                self.execute_error("Your primary disk is almost full\n\nFree up space and try again")

            else:
                telepath_data = server_obj._telepath_data
                if telepath_data:
                    response = constants.api_manager.request(
                        endpoint='/create/push_new_server',
                        host=telepath_data['host'],
                        port=telepath_data['port'],
                        args={'server_info': constants.new_server_info, 'import_info': constants.import_data}
                    )
                constants.pre_server_update()

        def after_func(*args):
            import_data = constants.post_server_create(modpack=True)

            if self.telepath and import_data['readme']:
                import_data['readme'] = constants.telepath_download(self.telepath, import_data['readme'])['path']

            self.open_server(
                import_data['name'],
                True,
                f"Updated '${import_data['name']}$' successfully",
                show_readme=import_data['readme']
            )

        # Original is percentage before this function, adjusted is a percent of hooked value
        def adjust_percentage(*args):
            original = self.last_progress
            adjusted = args[0]
            total = args[1] * 0.01
            final = original + round(adjusted * total)
            if final < 0:
                final = original
            self.progress_bar.update_progress(final)


        self.page_contents = {

            # Page name
            'title': f"Updating '${server_obj.name}$'",

            # Header text
            'header': "Sit back and relax, it's automation time...",

            # Tuple of tuples for steps (label, function, percent)
            # Percent of all functions must total 100
            # Functions must return True, or default error will be executed
            'default_error': "There was an issue updating this modpack.\n\nThe required resources were unobtainable and will require manual installation.",

            'function_list': (),

            # Function to run before steps (like checking for an internet connection)
            'before_function': before_func,

            # Function to run after everything is complete (like cleaning up the screen tree) will only run if no error
            'after_function': after_func,

            # Screen to go to after complete
            'next_screen': None
        }

        # Create function list
        java_text = 'Verifying Java Installation' if os.path.exists(constants.javaDir) else 'Installing Java'
        function_list = [
            (java_text, functools.partial(constants.java_check, functools.partial(adjust_percentage, 30)), 0),
            ('Validating modpack', functools.partial(constants.scan_modpack, True, functools.partial(adjust_percentage, 20)), 0),
            ("Downloading 'server.jar'", functools.partial(constants.download_jar, functools.partial(adjust_percentage, 10), True), 0),
            ('Installing modpack',functools.partial(constants.install_server, None, True), 15),
            ('Creating pre-install back-up', functools.partial(constants.create_backup, True), 10),
            ('Validating configuration', functools.partial(constants.finalize_modpack, True, functools.partial(adjust_percentage, 5)), 0),
            ('Creating post-install back-up', functools.partial(constants.create_backup, True), 10)
        ]

        self.page_contents['function_list'] = tuple(function_list)



# </editor-fold> ///////////////////////////////////////////////////////////////////////////////////////////////////////




# ============================================= Telepath Utilities =====================================================
# <editor-fold desc="Telepath Utilities">

# Telepath instance screen (for a client to view servers it's connected to)
class InstanceButton(HoverButton):

    class NameInput(TextInput):

        def update_config(self, *a):
            def write(*a):
                constants.server_manager.rename_telepath_server(self.properties, self.text)

            if self.change_timeout:
                self.change_timeout.cancel()
            self.change_timeout = Clock.schedule_once(write, 0.7)

        def _on_focus(self, instance, value, *largs):
            super()._on_focus(instance, value, *largs)

            if not value and not self.text:
                self.text = constants.format_nickname(self.original_text)

        # Ignore popup text
        def insert_text(self, substring, from_undo=False):
            if screen_manager.current_screen.popup_widget:
                return None

            # Input validation & formatting
            if len(substring) > 1 or (substring in [' ', '-', '.'] and (not self.text or self.text[self.cursor_col-1] in ['-', '.'])):
                return

            if len(self.text) >= 20:
                return

            substring = substring.lower().replace(' ', '-')
            substring = re.sub('[^a-zA-Z0-9.-]', '', substring)

            self.update_config()

            super().insert_text(substring, from_undo)

        # Special keypress behaviors
        def keyboard_on_key_down(self, window, keycode, text, modifiers):

            if keycode[1] == "backspace" and control in modifiers:
                original_index = self.cursor_col
                new_text, index = constants.control_backspace(self.text, original_index)
                self.select_text(original_index - index, original_index)
                self.delete_selection()
            else:
                super().keyboard_on_key_down(window, keycode, text, modifiers)

        def __init__(self, instance_data, *args, **kwargs):
            super().__init__(*args, **kwargs)
            self.properties = instance_data
            self.__translate__ = False
            self.id = "title"
            self.halign = "left"
            self.foreground_color = constants.brighten_color((0.65, 0.65, 1, 1), 0.07)
            self.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
            self.background_color = (0, 0, 0, 0)
            self.size = (400, 50)
            self.font_size = sp(25)
            self.max_lines = 1
            self.multiline = False
            self.hint_text_color = (0.6, 0.6, 1, 0.4)
            self.cursor_color = (0.55, 0.55, 1, 1)
            self.cursor_width = dp(3)
            self.selection_color = (0.5, 0.5, 1, 0.4)
            self.hint_text = 'enter a nickname...'
            self.original_text = ''
            self.change_timeout = None

    def animate_button(self, image, color, **kwargs):
        image_animate = Animation(duration=0.05)

        def f(w):
            w.background_normal = image

        Animation(color=color, duration=0.06).start(self.title)
        Animation(color=(color if ((self.subtitle.text == self.original_subtitle) or self.hovered) else self.connect_color), duration=0.06).start(self.subtitle)
        Animation(color=color, duration=0.06).start(self.type_image.image)

        if self.type_image.version_label.__class__.__name__ == "AlignLabel":
            Animation(color=color, duration=0.06).start(self.type_image.version_label)
        Animation(color=color, duration=0.06).start(self.type_image.type_label)

        a = Animation(duration=0.0)
        a.on_complete = functools.partial(f)

        image_animate += a

        image_animate.start(self)

    def resize_self(self, *args):

        # Title and description
        padding = 2.17
        self.title.pos = (self.x + 53, self.y + 26)
        self.subtitle.pos = (self.x + (self.subtitle.text_size[0] / padding) - 78, self.y + 8)
        offset = 9.55

        self.type_image.image.x = self.width + self.x - (self.type_image.image.width) - 13
        self.type_image.image.y = self.y + ((self.height / 2) - (self.type_image.image.height / 2))

        self.type_image.type_label.x = self.width + self.x - (self.padding_x * offset) - self.type_image.width - 83
        self.type_image.type_label.y = self.y + (self.height * 0.05)


        # Edit button
        self.edit_layout.size_hint_max = (self.size_hint_max[0], self.size_hint_max[1])
        self.edit_layout.pos = (self.pos[0] - 6, self.pos[1] + 13)


        # Update label
        if self.type_image.version_label.__class__.__name__ == "AlignLabel":
            self.type_image.version_label.x = self.width + self.x - (self.padding_x * offset) - self.type_image.width - 83
            self.type_image.version_label.y = self.y - (self.height / 3.2)

        # Banner version object
        else:
            self.type_image.version_label.x = self.width + self.x - (self.padding_x * offset) - self.type_image.width - 130
            self.type_image.version_label.y = self.y - (self.height / 3.2) - 2

    def highlight(self):
        def next_frame(*args):
            Animation.stop_all(self.highlight_border)
            self.highlight_border.opacity = 1
            Animation(opacity=0, duration=0.7).start(self.highlight_border)

        Clock.schedule_once(next_frame, 0)

    def update_subtitle(self):

        def reset(*a):
            self.subtitle.copyable = False
            self.subtitle.color = self.color_id[1]
            self.subtitle.default_opacity = 0.56
            self.subtitle.font_name = self.original_font
            self.subtitle.text = self.original_subtitle
            self.enabled = False
            self.background_normal = os.path.join(constants.gui_assets, 'addon_button_disabled.png')

        try:
            if self.properties['host'] in constants.server_manager.online_telepath_servers:
                self.connect_color = (0.529, 1, 0.729, 1)
                self.subtitle.color = self.connect_color
                self.subtitle.default_opacity = 0.8
                self.subtitle.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
                self.subtitle.text = 'Connected'
                self.enabled = True
                self.background_normal = os.path.join(constants.gui_assets, 'telepath_button_enabled.png')

            else:
                self.connect_color = (1, 0.65, 0.65, 1)
                self.subtitle.color = self.connect_color
                self.subtitle.default_opacity = 0.8
                self.subtitle.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')

                if self.properties['telepath-version'] != constants.api_manager.version:
                    self.subtitle.text = 'API version mismatch'
                else:
                    self.subtitle.text = 'Authentication failure'

                self.enabled = False
                self.background_normal = os.path.join(constants.gui_assets, 'addon_button_disabled.png')

        except KeyError:
            reset()

        self.background_down = self.background_normal
        self.subtitle.opacity = self.subtitle.default_opacity
        self.color_id = [(0.05, 0.05, 0.1, 1), (0.65, 0.65, 1, 1)] if self.enabled else [(0.05, 0.1, 0.1, 1), (1, 0.6, 0.7, 1)]
        self.title.color = self.color_id[1]

    def generate_name(self):
        tld = self.properties['host']
        if self.properties['nickname']:
            tld = self.properties['nickname']
        return tld

    def __init__(self, instance_data, click_function=None, fade_in=0.0, highlight=None, update_banner="", **kwargs):
        super().__init__(**kwargs)

        self.properties = instance_data
        self.border = (-5, -5, -5, -5)
        self.color_id = [(0.05, 0.05, 0.1, 1), constants.brighten_color((0.65, 0.65, 1, 1), 0.07)]
        self.connect_color = (0.529, 1, 0.729, 1)
        self.pos_hint = {"center_x": 0.5, "center_y": 0.6}
        self.size_hint_max = (580, 80)
        self.id = "server_button"
        self.enabled = False

        self.background_normal = os.path.join(constants.gui_assets, 'server_button.png' if self.enabled else 'addon_button_disabled.png')
        self.background_down = self.background_normal

        self.icons = os.path.join(constants.gui_assets, 'fonts', constants.fonts['icons'])


        # Loading stuffs
        self.original_subtitle = 'Offline'
        self.original_font = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["regular"]}.ttf')


        # Title of Instance
        self.title = self.NameInput(instance_data)
        self.title.text = self.title.original_text = self.generate_name()
        self.add_widget(self.title)


        # Authentication status formatted
        self.subtitle = Label()
        self.subtitle.__translate__ = False
        self.subtitle.size = (300, 30)
        self.subtitle.id = "subtitle"
        self.subtitle.halign = "left"
        self.subtitle.valign = "center"
        self.subtitle.font_size = sp(21)
        self.subtitle.text_size = (self.size_hint_max[0] * 0.91, self.size_hint_max[1])
        self.subtitle.shorten = True
        self.subtitle.markup = True
        self.subtitle.shorten_from = "right"
        self.subtitle.max_lines = 1
        self.subtitle.text_size[0] = 350
        self.subtitle.copyable = False
        self.subtitle.color = self.color_id[1]
        self.subtitle.default_opacity = 0.56
        self.subtitle.font_name = self.original_font
        self.subtitle.text = self.original_subtitle

        self.subtitle.opacity = self.subtitle.default_opacity

        self.add_widget(self.subtitle)
        self.update_subtitle()


        # Edit button
        self.edit_layout = RelativeLayout()
        self.edit_button = IconButton('', {}, (0, 0), (None, None), 'unpair.png', anchor='right', click_func=functools.partial(click_function, instance_data))
        self.edit_layout.add_widget(self.edit_button)
        self.add_widget(self.edit_layout)


        # Type icon and info
        self.type_image = RelativeLayout()
        self.type_image.width = 400

        instance_icon = os.path.join(constants.gui_assets, 'icons', 'big', f'{self.properties["os"]}.png')
        self.type_image.image = Image(source=instance_icon)

        self.type_image.image.allow_stretch = True
        self.type_image.image.size_hint_max = (65, 65)
        self.type_image.image.color = self.color_id[1]
        self.type_image.add_widget(self.type_image.image)

        def TemplateLabel():
            template_label = AlignLabel()
            template_label.__translate__ = False
            template_label.halign = "right"
            template_label.valign = "middle"
            template_label.text_size = template_label.size
            template_label.font_size = sp(19)
            template_label.color = self.color_id[1]
            template_label.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
            template_label.width = 150
            return template_label

        if update_banner:
            self.type_image.version_label = RelativeLayout()
            self.type_image.version_label.add_widget(
                BannerObject(
                    pos_hint={"center_x": 1, "center_y": 0.5},
                    size=(100, 30),
                    color=(0.647, 0.839, 0.969, 1),
                    text=update_banner,
                    icon="arrow-up-circle.png",
                    icon_side="left"
                )
            )

        else:
            self.type_image.version_label = TemplateLabel()
            self.type_image.version_label.color = self.color_id[1]
            self.type_image.version_label.text = f"auto-mcs v{self.properties['app-version']}"
            self.type_image.version_label.opacity = 0.6


        self.type_image.type_label = TemplateLabel()
        self.type_image.type_label.text = self.properties["os"].replace('macos', 'macOS')
        self.type_image.type_label.font_size = sp(23)
        self.type_image.add_widget(self.type_image.version_label)
        self.type_image.add_widget(self.type_image.type_label)
        self.add_widget(self.type_image)


        # Animate opacity
        if fade_in > 0:
            self.opacity = 0
            self.title.opacity = 0

            Animation(opacity=1, duration=fade_in).start(self)
            Animation(opacity=1, duration=fade_in).start(self.title)
            Animation(opacity=self.subtitle.default_opacity, duration=fade_in).start(self.subtitle)

        self.bind(pos=self.resize_self)

    def on_enter(self, *args):
        return
        if not self.ignore_hover:
            self.animate_button(image=os.path.join(constants.gui_assets, 'server_button_hover.png'), color=self.color_id[0], hover_action=True)

    def on_leave(self, *args):
        return
        if not self.ignore_hover:
            self.animate_button(image=os.path.join(constants.gui_assets, 'server_button.png' if self.enabled else 'addon_button_disabled.png'), color=self.color_id[1], hover_action=False)

class TelepathInstanceScreen(MenuBackground):

    def switch_page(self, direction):

        if self.max_pages == 1:
            return

        if direction == "right":
            if self.current_page == self.max_pages:
                self.current_page = 1
            else:
                self.current_page += 1

        else:
            if self.current_page == 1:
                self.current_page = self.max_pages
            else:
                self.current_page -= 1

        self.page_switcher.update_index(self.current_page, self.max_pages)
        self.gen_search_results(self.last_results)

    def gen_search_results(self, results, new_search=False, fade_in=True, highlight=None, animate_scroll=True, *args):
        default_scroll = 1

        # Update page counter
        self.last_results = results
        self.max_pages = (len(results) / self.page_size).__ceil__()
        self.current_page = 1 if self.current_page == 0 or new_search else self.current_page


        self.page_switcher.update_index(self.current_page, self.max_pages)
        page_list = []
        for k, v in constants.deepcopy(results).items():
            v['host'] = k
            page_list.append(v)
        page_list = page_list[(self.page_size * self.current_page) - self.page_size:self.page_size * self.current_page]

        self.scroll_layout.clear_widgets()


        # Generate header
        server_count = len(constants.server_manager.telepath_servers)
        header_content = "Select an instance to manage"

        for child in self.header.children:
            if child.id == "text":
                child.text = header_content
                break


        # Show servers if they exist
        if server_count != 0:

            # Clear and add all ServerButtons
            for x, instance in enumerate(page_list, 1):

                # Activated when server is clicked
                def view_server(data, *a):
                    if data['nickname']:
                        display_name = f"{data['host']} ({data['nickname']})"
                    else:
                        display_name = data['nickname']

                    desc = f"Un-pairing this instance will prevent you from accessing it via $Telepath$ until it's paired again.\n\nAre you sure you want to un-pair from '${display_name}$'?"

                    def unpair(*a):
                        # Log out if possible
                        if data['host'] in constants.api_manager.jwt_tokens:
                            constants.api_manager.logout(data['host'], data['port'])

                        constants.server_manager.remove_telepath_server(data)
                        self.gen_search_results(constants.server_manager.telepath_servers)

                        telepath_banner(f"Un-paired from '${data['host']}$'", False)


                    Clock.schedule_once(
                        functools.partial(
                            screen_manager.current_screen.show_popup,
                            "warning_query",
                            f'Un-pair Instance',
                            desc,
                            (None, unpair)
                        ),
                        0
                    )

                # Add-on button click function
                self.scroll_layout.add_widget(
                    ScrollItem(
                        widget = InstanceButton(
                            instance_data = instance,
                            fade_in = ((x if x <= 8 else 8) / self.anim_speed) if fade_in else 0,
                            click_function = view_server
                        )
                    )
                )

            self.resize_bind()

        # Go back to main menu if they don't
        else:
            screen_manager.current = 'TelepathManagerScreen'
            constants.screen_tree = ['MainMenuScreen']
            return

        # Animate scrolling
        def set_scroll(*args):
            Animation.stop_all(self.scroll_layout.parent.parent)
            if animate_scroll:
                Animation(scroll_y=default_scroll, duration=0.1).start(self.scroll_layout.parent.parent)
            else:
                self.scroll_layout.parent.parent.scroll_y = default_scroll
        Clock.schedule_once(set_scroll, 0)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.background_color = constants.brighten_color(constants.background_color, -0.09)
        self.menu = 'init'
        self.header = None
        self.scroll_layout = None
        self.blank_label = None
        self.page_switcher = None
        self.load_layout = None

        self.last_results = []
        self.page_size = 10
        self.current_page = 0
        self.max_pages = 0
        self.anim_speed = 10

        with self.canvas.before:
            self.color = Color(*self.background_color, mode='rgba')
            self.rect = Rectangle(pos=self.pos, size=self.size)

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        super()._on_keyboard_down(keyboard, keycode, text, modifiers)

        # Press arrow keys to switch pages
        if keycode[1] in ['right', 'left'] and self.name == screen_manager.current_screen.name:
            self.switch_page(keycode[1])

    def show_loading(self, show=True, *a):
        Animation.stop_all(self.load_layout)
        Animation(opacity=1 if show else 0, duration=0.2).start(self.load_layout)

    def generate_menu(self, **kwargs):

        # Scroll list
        scroll_widget = ScrollViewWidget(position=(0.5, 0.52))
        scroll_anchor = AnchorLayout()
        self.scroll_layout = GridLayout(cols=1, spacing=15, size_hint_max_x=1250, size_hint_y=None, padding=[0, 30, 0, 30])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 1.82
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1
            self.anim_speed = 13 if Window.width > grid_layout.size_hint_max_x else 10

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, self.scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        self.scroll_layout.bind(minimum_height=self.scroll_layout.setter('height'))
        self.scroll_layout.id = 'scroll_content'


        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.795}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60), color=self.background_color)
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.26}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60), color=self.background_color)

        # Generate buttons on page load
        header_content = "Select an instance to manage"
        self.header = HeaderText(header_content, '', (0, 0.89))

        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(self.header)

        self.page_switcher = PageSwitcher(0, 0, (0.5, 0.887), self.switch_page)


        # Append scroll view items
        scroll_anchor.add_widget(self.scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)
        float_layout.add_widget(self.page_switcher)

        buttons.append(ExitButton('Back', (0.5, 0.11), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        menu_name = "Instance Manager"
        float_layout.add_widget(generate_title(menu_name))
        float_layout.add_widget(generate_footer(f'Telepath, {menu_name}', no_background=True))

        # Load layout
        self.load_layout = FloatLayout(opacity=0)

        # Loading icon to swap button
        self.load_layout.icon = Image()
        self.load_layout.icon.id = "load_icon"
        self.load_layout.icon.source = os.path.join(constants.gui_assets, 'animations', 'loading_pickaxe.gif')
        self.load_layout.icon.size_hint_max = (50, 50)
        self.load_layout.icon.color = (0.6, 0.6, 1, 1)
        self.load_layout.icon.pos_hint = {"center_y": 0.5, "center_x": 0.4}
        self.load_layout.icon.allow_stretch = True
        self.load_layout.icon.anim_delay = constants.anim_speed * 0.02
        self.load_layout.add_widget(self.load_layout.icon)

        # Load label
        self.load_layout.text = Label()
        self.load_layout.text.text = "loading instances..."
        self.load_layout.text.halign = "center"
        self.load_layout.text.valign = "center"
        self.load_layout.text.font_name = os.path.join(constants.gui_assets, 'fonts', constants.fonts['italic'])
        self.load_layout.text.pos_hint = {"center_x": 0.5, "center_y": 0.5}
        self.load_layout.text.font_size = sp(25)
        self.load_layout.text.color = (0.6, 0.6, 1, 0.5)
        self.load_layout.add_widget(self.load_layout.text)

        self.add_widget(float_layout)
        self.add_widget(self.load_layout)

        # Async reload Telepath servers
        def refresh_telepath_instances(*a):
            Clock.schedule_once(lambda *_: self.show_loading(True), 0)
            constants.server_manager.check_telepath_servers()
            Clock.schedule_once(lambda *_: self.show_loading(False), 0)
            Clock.schedule_once(lambda *_: self.gen_search_results(constants.server_manager.telepath_servers), 0.15)
        threading.Timer(0, refresh_telepath_instances).start()


# Telepath user screen (for a server to view connected clients)
class UserButton(HoverButton):
    def animate_button(self, image, color, **kwargs):
        image_animate = Animation(duration=0.05)

        def f(w):
            w.background_normal = image

        Animation(color=color, duration=0.06).start(self.title)
        Animation(color=(color if ((self.subtitle.text == self.original_subtitle) or self.hovered) else self.connect_color), duration=0.06).start(self.subtitle)
        Animation(color=color, duration=0.06).start(self.type_image.image)

        if self.type_image.version_label.__class__.__name__ == "AlignLabel":
            Animation(color=color, duration=0.06).start(self.type_image.version_label)
        Animation(color=color, duration=0.06).start(self.type_image.type_label)

        a = Animation(duration=0.0)
        a.on_complete = functools.partial(f)

        image_animate += a

        image_animate.start(self)

    def resize_self(self, *args):

        # Title and description
        padding = 2.17
        self.title.pos = (self.x + (self.title.text_size[0] / padding) - 8.3 + 30, self.y + 31)
        self.subtitle.pos = (self.x + (self.subtitle.text_size[0] / padding) - 78, self.y + 8)
        offset = 9.55

        self.type_image.image.x = self.width + self.x - (self.type_image.image.width) - 8
        self.type_image.image.y = self.y + ((self.height / 2) - (self.type_image.image.height / 2))

        self.type_image.type_label.x = self.width + self.x - (self.padding_x * offset) - self.type_image.width - 75
        self.type_image.type_label.y = self.y + (self.height * 0.15)

        self.disable_layout.pos = (self.x + self.width + 57, self.y - 23)


        # Edit button
        self.edit_layout.size_hint_max = (self.size_hint_max[0], self.size_hint_max[1])
        self.edit_layout.pos = (self.pos[0] - 6, self.pos[1] + 13)

    def highlight(self):
        def next_frame(*args):
            Animation.stop_all(self.highlight_border)
            self.highlight_border.opacity = 1
            Animation(opacity=0, duration=0.7).start(self.highlight_border)

        Clock.schedule_once(next_frame, 0)

    def update_status(self):

        def reset(*a):
            self.subtitle.copyable = False
            self.subtitle.color = self.color_id[1]
            self.subtitle.default_opacity = 0.56
            self.subtitle.font_name = self.original_font
            self.subtitle.text = self.original_subtitle
            self.enabled = False
            self.background_normal = os.path.join(constants.gui_assets, 'addon_button_disabled.png')

        try:

            # User is connected
            if self.connected:
                self.connect_color = (0.529, 1, 0.729, 1)
                self.type_image.image.color = self.type_image.type_label.color = self.connect_color
                self.type_image.type_label.text = 'connected'
                self.background_normal = os.path.join(constants.gui_assets, 'telepath_button_enabled.png')

            # User is offline
            elif not self.access_disabled:
                self.connect_color = (0.65, 0.65, 1, 1)
                self.type_image.image.color = self.type_image.type_label.color = self.connect_color
                self.type_image.type_label.text = 'offline'
                self.background_normal = os.path.join(constants.gui_assets, 'addon_button.png')

            # User is restricted
            else:
                self.connect_color = (1, 0.65, 0.65, 1)
                self.type_image.image.color = self.type_image.type_label.color = self.connect_color
                self.type_image.type_label.text = 'restricted'
                self.background_normal = os.path.join(constants.gui_assets, 'addon_button_disabled.png')

        except KeyError:
            reset()

        self.background_down = self.background_normal
        self.subtitle.opacity = self.subtitle.default_opacity
        self.color_id = [(0.05, 0.05, 0.1, 1), (0.65, 0.65, 1, 1)] if self.connected else [(0.05, 0.1, 0.1, 1), (1, 0.6, 0.7, 1)]

    def generate_name(self):
        return self.properties['user']

    def __init__(self, user_data, click_function=None, fade_in=0.0, connected=False, highlight=None, **kwargs):
        super().__init__(**kwargs)

        self.properties = user_data
        self.border = (-5, -5, -5, -5)
        self.color_id = [(0.05, 0.05, 0.1, 1), constants.brighten_color((0.65, 0.65, 1, 1), 0.07)]
        self.connect_color = (0.529, 1, 0.729, 1)
        self.pos_hint = {"center_x": 0.5, "center_y": 0.6}
        self.size_hint_max = (580, 80)
        self.id = "server_button"
        self.access_disabled = 'disabled' in self.properties and self.properties['disabled']
        self.connected = connected

        self.background_normal = os.path.join(constants.gui_assets, 'server_button.png' if self.connected else 'addon_button_disabled.png')
        self.background_down = self.background_normal

        self.icons = os.path.join(constants.gui_assets, 'fonts', constants.fonts['icons'])


        # Loading stuffs
        self.original_subtitle = self.properties["host"] if self.properties["host"] else self.properties["ip"]
        self.original_font = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["regular"]}.ttf')


        # Title of user
        self.title = Label()
        self.title.__translate__ = False
        self.title.id = "title"
        self.title.halign = "left"
        self.title.color = self.color_id[1]
        self.title.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
        self.title.font_size = sp(25)
        self.title.text_size = (self.size_hint_max[0] * 0.58, self.size_hint_max[1])
        self.title.shorten = True
        self.title.markup = True
        self.title.shorten_from = "right"
        self.title.max_lines = 1
        self.title.text = self.generate_name()
        self.add_widget(self.title)


        # Hostname
        self.subtitle = Label()
        self.subtitle.__translate__ = False
        self.subtitle.size = (300, 30)
        self.subtitle.id = "subtitle"
        self.subtitle.halign = "left"
        self.subtitle.valign = "center"
        self.subtitle.font_size = sp(21)
        self.subtitle.text_size = (self.size_hint_max[0] * 0.91, self.size_hint_max[1])
        self.subtitle.shorten = True
        self.subtitle.markup = True
        self.subtitle.shorten_from = "right"
        self.subtitle.max_lines = 1
        self.subtitle.text_size[0] = 350
        self.subtitle.copyable = False
        self.subtitle.color = self.color_id[1]
        self.subtitle.default_opacity = 0.65
        self.subtitle.font_name = self.original_font
        self.subtitle.text = self.original_subtitle

        self.subtitle.opacity = self.subtitle.default_opacity

        self.add_widget(self.subtitle)


        # Edit button
        self.edit_layout = RelativeLayout()
        self.edit_button = IconButton('', {}, (0, 0), (None, None), 'unpair.png', anchor='right', click_func=functools.partial(click_function, user_data))
        self.edit_layout.add_widget(self.edit_button)
        self.add_widget(self.edit_layout)


        # Type icon and info
        self.type_image = RelativeLayout()
        self.type_image.width = 400

        user_icon = os.path.join(constants.gui_assets, 'icons', 'big', 'telepath-user.png')
        self.type_image.image = Image(source=user_icon)

        self.type_image.image.allow_stretch = True
        self.type_image.image.size_hint_max = (65, 65)
        self.type_image.image.color = self.color_id[1]
        self.type_image.add_widget(self.type_image.image)

        def TemplateLabel():
            template_label = AlignLabel()
            template_label.__translate__ = False
            template_label.halign = "right"
            template_label.valign = "middle"
            template_label.text_size = template_label.size
            template_label.font_size = sp(19)
            template_label.color = self.color_id[1]
            template_label.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
            template_label.opacity = 0.8
            template_label.width = 150
            return template_label

        self.type_image.type_label = TemplateLabel()
        self.type_image.type_label.font_size = sp(23)
        self.type_image.add_widget(self.type_image.type_label)
        self.add_widget(self.type_image)
        self.update_status()


        # Temporary disable switch
        def disable_user(disable=True):
            constants.api_manager._disable_user(self.properties['id'], not disable)
            self.access_disabled = not disable
            self.update_status()

        # Make this check eventual variable
        self.disable_layout = RelativeLayout(size_hint_max=(10, 10))
        self.disable_user = toggle_button('telepath-disable', (0.5, 0.5), default_state=not self.access_disabled, x_offset=-395, custom_func=disable_user)
        self.disable_layout.size_hint_max = (10, 10)
        self.disable_layout.add_widget(self.disable_user)
        self.add_widget(self.disable_layout)


        # Animate opacity
        if fade_in > 0:
            self.opacity = 0
            self.title.opacity = 0

            Animation(opacity=1, duration=fade_in).start(self)
            Animation(opacity=1, duration=fade_in).start(self.title)
            Animation(opacity=self.subtitle.default_opacity, duration=fade_in).start(self.subtitle)

        self.bind(pos=self.resize_self)

    def on_enter(self, *args):
        return
        if not self.ignore_hover:
            self.animate_button(image=os.path.join(constants.gui_assets, 'server_button_hover.png'), color=self.color_id[0], hover_action=True)

    def on_leave(self, *args):
        return
        if not self.ignore_hover:
            self.animate_button(image=os.path.join(constants.gui_assets, 'server_button.png' if self.enabled else 'addon_button_disabled.png'), color=self.color_id[1], hover_action=False)

class TelepathUserScreen(MenuBackground):

    def switch_page(self, direction):

        if self.max_pages == 1:
            return

        if direction == "right":
            if self.current_page == self.max_pages:
                self.current_page = 1
            else:
                self.current_page += 1

        else:
            if self.current_page == 1:
                self.current_page = self.max_pages
            else:
                self.current_page -= 1

        self.page_switcher.update_index(self.current_page, self.max_pages)
        self.gen_search_results(self.last_results)

    def gen_search_results(self, new_search=False, fade_in=True, highlight=None, animate_scroll=True, *args):

        # Generate list of online users
        online_list = []
        for user in constants.api_manager.current_users.values():
            user_str = f'{user["host"]}/{user["user"]}'
            if user_str not in online_list:
                online_list.append(user_str)

        # Sort users based on if they are online
        results = sorted(
            constants.api_manager.authenticated_sessions,
            key = lambda u: f'{u["host"]}/{u["user"]}' in online_list,
            reverse = True
        )


        default_scroll = 1

        # Update page counter
        self.last_results = results
        self.max_pages = (len(results) / self.page_size).__ceil__()
        self.current_page = 1 if self.current_page == 0 or new_search else self.current_page


        self.page_switcher.update_index(self.current_page, self.max_pages)
        page_list = results[(self.page_size * self.current_page) - self.page_size:self.page_size * self.current_page]

        self.scroll_layout.clear_widgets()


        # Generate header
        user_count = len(constants.api_manager.authenticated_sessions)
        header_content = "Select a user to manage"

        for child in self.header.children:
            if child.id == "text":
                child.text = header_content
                break


        # Show users if they exist
        if user_count != 0:

            # Clear and add all ServerButtons
            for x, user in enumerate(page_list, 1):

                # Activated when server is clicked
                def view_user(data, *a):
                    if data['host']:
                        display_name = f"{data['host']}/{data['user']}"
                    else:
                        display_name = f"{data['ip']}/{data['user']}"

                    desc = f"Un-pairing this user will prevent them from accessing this instance via $Telepath$ until paired again.\n\nAre you sure you want to un-pair '${display_name}$'?"

                    def unpair(*a):
                        # Log out if possible
                        if data['ip'] in constants.api_manager.current_users:
                            constants.api_manager._force_logout(constants.api_manager.current_users[data['ip']]['session_id'])

                        constants.api_manager._revoke_session(data['id'])
                        self.gen_search_results()
                        telepath_banner(f"Un-paired '${display_name}$'", False)


                    Clock.schedule_once(
                        functools.partial(
                            screen_manager.current_screen.show_popup,
                            "warning_query",
                            f'Un-pair Instance',
                            desc,
                            (None, unpair)
                        ),
                        0
                    )

                # Add-on button click function
                self.scroll_layout.add_widget(
                    ScrollItem(
                        widget = UserButton(
                            user_data = user,
                            fade_in = ((x if x <= 8 else 8) / self.anim_speed) if fade_in else 0,
                            click_function = view_user,
                            connected = f'{user["host"]}/{user["user"]}' in online_list,
                        )
                    )
                )

            self.resize_bind()

        # Go back to main menu if they don't
        else:
            screen_manager.current = 'TelepathManagerScreen'
            constants.screen_tree = ['MainMenuScreen']
            return

        # Animate scrolling
        def set_scroll(*args):
            Animation.stop_all(self.scroll_layout.parent.parent)
            if animate_scroll:
                Animation(scroll_y=default_scroll, duration=0.1).start(self.scroll_layout.parent.parent)
            else:
                self.scroll_layout.parent.parent.scroll_y = default_scroll
        Clock.schedule_once(set_scroll, 0)

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.background_color = constants.brighten_color(constants.background_color, -0.09)
        self.menu = 'init'
        self.header = None
        self.scroll_layout = None
        self.blank_label = None
        self.page_switcher = None
        self.load_layout = None

        self.last_results = []
        self.page_size = 10
        self.current_page = 0
        self.max_pages = 0
        self.anim_speed = 10

        with self.canvas.before:
            self.color = Color(*self.background_color, mode='rgba')
            self.rect = Rectangle(pos=self.pos, size=self.size)

    def _on_keyboard_down(self, keyboard, keycode, text, modifiers):
        super()._on_keyboard_down(keyboard, keycode, text, modifiers)

        # Press arrow keys to switch pages
        if keycode[1] in ['right', 'left'] and self.name == screen_manager.current_screen.name:
            self.switch_page(keycode[1])

    def show_loading(self, show=True, *a):
        Animation.stop_all(self.load_layout)
        Animation(opacity=1 if show else 0, duration=0.2).start(self.load_layout)

    def generate_menu(self, **kwargs):

        # Scroll list
        scroll_widget = ScrollViewWidget(position=(0.5, 0.52))
        scroll_anchor = AnchorLayout()
        self.scroll_layout = GridLayout(cols=1, spacing=15, size_hint_max_x=1250, size_hint_y=None, padding=[0, 30, 0, 30])


        # Bind / cleanup height on resize
        def resize_scroll(call_widget, grid_layout, anchor_layout, *args):
            call_widget.height = Window.height // 1.82
            grid_layout.cols = 2 if Window.width > grid_layout.size_hint_max_x else 1
            self.anim_speed = 13 if Window.width > grid_layout.size_hint_max_x else 10

            def update_grid(*args):
                anchor_layout.size_hint_min_y = grid_layout.height

            Clock.schedule_once(update_grid, 0)


        self.resize_bind = lambda*_: Clock.schedule_once(functools.partial(resize_scroll, scroll_widget, self.scroll_layout, scroll_anchor), 0)
        self.resize_bind()
        Window.bind(on_resize=self.resize_bind)
        self.scroll_layout.bind(minimum_height=self.scroll_layout.setter('height'))
        self.scroll_layout.id = 'scroll_content'


        # Scroll gradient
        scroll_top = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.795}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, 60), color=self.background_color)
        scroll_bottom = scroll_background(pos_hint={"center_x": 0.5, "center_y": 0.26}, pos=scroll_widget.pos, size=(scroll_widget.width // 1.5, -60), color=self.background_color)

        # Generate buttons on page load
        header_content = "Select a user to manage"
        self.header = HeaderText(header_content, '', (0, 0.89))

        buttons = []
        float_layout = FloatLayout()
        float_layout.id = 'content'
        float_layout.add_widget(self.header)

        self.page_switcher = PageSwitcher(0, 0, (0.5, 0.887), self.switch_page)


        # Append scroll view items
        scroll_anchor.add_widget(self.scroll_layout)
        scroll_widget.add_widget(scroll_anchor)
        float_layout.add_widget(scroll_widget)
        float_layout.add_widget(scroll_top)
        float_layout.add_widget(scroll_bottom)
        float_layout.add_widget(self.page_switcher)

        buttons.append(ExitButton('Back', (0.5, 0.11), cycle=True))

        for button in buttons:
            float_layout.add_widget(button)

        menu_name = "User Manager"
        float_layout.add_widget(generate_title(menu_name))
        float_layout.add_widget(generate_footer(f'Telepath, {menu_name}', no_background=True))

        self.add_widget(float_layout)

        self.gen_search_results()




class TelepathHostInput(CreateServerPortInput):
    def __init__(self, **kwargs):
        self.ip = ''
        self.port = ''
        super().__init__(**kwargs)
        self.checking = False
        self.bind(on_text_validate=self.check_connection)

    def check_connection(self, *a):

        def change_icon(show=True, *a):
            try:
                load_icon = screen_manager.current_screen.load_icon
                Animation.stop_all(load_icon)
                Animation(opacity=1 if show else 0, duration=0.15).start(load_icon)
            except AttributeError:
                pass

        def background(*a):
            self.checking = True
            try:
                data = {'detail': 'Failed to connect'}
                Clock.schedule_once(functools.partial(change_icon, True), 0)
                if constants.check_port(self.ip, int(self.port), timeout=5):
                    data = constants.api_manager.request_pair(self.ip, self.port)
            except:
                pass

            Clock.schedule_once(functools.partial(change_icon, False), 0)
            self.checking = False

            try:
                if 'detail' in data:
                    self.stinky_text = ' Unable to connect'
                    self.valid(False)
                    return
            except:
                pass

            if data and screen_manager.current_screen.name == 'TelepathManagerScreen':
                Clock.schedule_once(
                    functools.partial(screen_manager.current_screen.confirm_pair_input, self.ip, self.port), 0)

        if not self.checking:
            threading.Timer(0, background).start()
        change_timeout = None

    def update_config(self, *a):

        if self.change_timeout:
            self.change_timeout.cancel()
        self.change_timeout = Clock.schedule_once(self.check_connection, 2)

    # Input validation
    def insert_text(self, substring, from_undo=False):

        if not self.text and substring == " ":
            substring = ""

        elif len(self.text) < 30:
            if '\n' in substring:
                substring = substring.splitlines()[0]
            s = re.sub('[^a-z0-9-:.]', '', substring)

            if ":" in self.text and ":" in s:
                s = ''
            if ("." in s and ((self.cursor_col > self.text.find(":")) and (self.text.find(":") > -1))) or ("." in s and self.text.count(".") >= 3):
                s = ''

            # Add name to current config
            def process(*a):
                self.process_text(text=(self.text))
            Clock.schedule_once(process, 0)

            return BaseInput.insert_text(self, s, from_undo=from_undo)

    def process_text(self, text=''):
        new_ip = ''
        default_port = constants.api_manager.default_port
        new_port = default_port

        typed_info = text if text else self.text

        # interpret typed information
        if ":" in typed_info:
            new_ip, new_port = typed_info.split(":")
        else:
            if "." in typed_info or not new_port:
                new_ip = typed_info.replace(":", "")
                new_port = default_port
            else:
                new_port = typed_info.replace(":", "")

        if not str(self.port) or not new_port:
            new_port = default_port

        if not str(new_port).isnumeric():
            new_port = default_port

        # Input validation
        try:
            port_check = ((int(new_port) < 1024) or (int(new_port) > 65535))
        except:
            port_check = True
        ip_check = (constants.check_ip(new_ip) and '.' in typed_info) or new_ip.replace('-','').replace('.','').isalpha()
        self.stinky_text = ''
        fail = False

        if typed_info:

            if new_ip in constants.server_manager.telepath_servers:
                self.stinky_text = ' Host is already added'
                fail = True

            elif '.' not in typed_info and typed_info.isnumeric():
                self.stinky_text = ' Enter an IPv4 address'
                fail = True

            elif not ip_check and ("." in typed_info or ":" in typed_info):
                self.stinky_text = 'Invalid IPv4 address' if not port_check else 'Invalid IPv4 and port'
                fail = True

            elif port_check:
                self.stinky_text = ' Invalid port  (use 1024-65535)'
                fail = True

        else:
            new_ip = ''
            new_port = constants.api_manager.default_port

        if not fail:
            self.ip = new_ip

        if new_port and not fail:
            self.port = int(new_port)

        if fail:
            self.ip = ''
            self.port = default_port

        self.valid(not self.stinky_text)

class TelepathCodeInput(BigBaseInput):
    def __init__(self, ip: str, port: int, **kwargs):
        super().__init__(**kwargs)
        self.ip = ip
        self.port = port

        self.title_text = "pair code"
        self.hint_text = '000-000'
        self.is_valid = True
        self.stinky_text = ''

        self.valign = "center"
        self.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["mono-bold"]}.otf')
        self.font_size = sp(69)
        self.padding_y = (12, 9)
        self.cursor_width = dp(5)
        self.checking = False
        self.bind(on_text_validate=self.check_connection)
        self.fail_count = 0

    def check_connection(self, *a):
        code = self.text.replace('-', '').upper().strip()
        if len(code) != 6:
            self.stinky_text = 'Invalid code length'
            self.valid_text(False, True)
            self.valid(False)
            return
        else:
            self.valid(True)

        def change_icon(show=True, *a):
            try:
                load_icon = screen_manager.current_screen.load_icon
                Animation.stop_all(load_icon)
                Animation(opacity=1 if show else 0, duration=0.15).start(load_icon)
            except AttributeError:
                pass

        def background(*a):
            self.checking = True
            data = None

            Clock.schedule_once(functools.partial(change_icon, True), 0)
            if constants.check_port(self.ip, int(self.port), timeout=5):
                data = constants.api_manager.submit_pair(self.ip, self.port, code)


            Clock.schedule_once(functools.partial(change_icon, False), 0)
            self.checking = False

            try:
                if not data or 'detail' in data:
                    self.stinky_text = '  Unable to connect or invalid code'
                    self.fail_count += 1
                    self.valid_text(False, True)
                    self.valid(False)
            except:
                pass

            if self.fail_count >= 3 and screen_manager.current_screen.name == 'TelepathManagerScreen':
                Clock.schedule_once(functools.partial(screen_manager.current_screen.show_pair_input, True), 0)
                return

            if data and screen_manager.current_screen.name == 'TelepathManagerScreen':
                def back_to_menu(*a):
                    constants.server_manager.refresh_list()
                    screen_manager.current = 'ServerManagerScreen'
                    constants.screen_tree = ['MainMenuScreen']
                    server_name = data['nickname'] if data['nickname'] else data['host']
                    telepath_banner(f"Successfully paired '${server_name}$'", True, play_sound='popup_telepath_success.wav')
                Clock.schedule_once(back_to_menu, 0)
                return
        if not self.checking:
            threading.Timer(0, background).start()

    # Ignore popup text
    def insert_text(self, substring, from_undo=False):
        substring = substring.upper()
        if len(substring) > 1:
            substring = ''

        if not self.text and substring == " ":
            substring = ""

        elif len(self.text) < 7:
            if '\n' in substring:
                substring = substring.splitlines()[0]
            s = re.sub('[^a-zA-Z0-9]', '', substring).upper().replace('O', '0')

            super().insert_text(s, from_undo)
            if len(self.text) == 3:
                super().insert_text('-')

    def valid_text(self, boolean_value, text):
        for child in self.parent.children:
            try:
                if child.id == "InputLabel":

                # Valid input
                    if boolean_value:
                        child.clear_text()
                        child.disable_text(False)

                # Invalid input
                    else:
                        child.update_text(self.stinky_text)
                        child.disable_text(True)
                    break

            except AttributeError:
                pass

    # Special keypress behaviors
    def keyboard_on_key_down(self, window, keycode, text, modifiers):

        def update_bar(*a):
            if (not self.text.endswith('-')) or keycode[1] == "backspace":
                self.text = self.text.replace('-','')
            if len(self.text.replace('-', '')) > 3:
                self.text = self.text[:3] + '-' + self.text[3:]
        Clock.schedule_once(update_bar, 0)

        if keycode[1] == "backspace" and control in modifiers:
            original_index = self.cursor_col
            new_text, index = constants.control_backspace(self.text, original_index)
            self.select_text(original_index - index, original_index)
            self.delete_selection()

        else:
            super().keyboard_on_key_down(window, keycode, text, modifiers)

class ParticleMesh(Widget):
    points = ListProperty()

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.direction = []
        self._generated = False

        self.point_number = 50
        self.point_radius = 3
        self.line_width = 1
        self.speed = 0.05
        self.max_line_length = 200

        self.line_color = (0.55, 0.55, 0.8)
        self.point_color = (0.8, 0.8, 1)

        # Generate points and fade in
        self.opacity = 0
        self.bind(size=self.plot_points)

    def show(self, *a):
        Animation(opacity=1, duration=3, transition='out_sine').start(self)

    def plot_points(self, *a):
        if self.height > 200 and not self._generated:
            Clock.schedule_once(self.show, 0)
            self._generated = True
            for _ in range(self.point_number):
                x = random.randint(0, self.width)
                y = random.randint(0, self.height)
                self.points.extend([x, y])
                self.direction.append(random.randint(0, 300))
            Clock.schedule_interval(self.update_positions, self.speed)

    def draw_lines(self):
        self.canvas.after.clear()
        with self.canvas.after:
            for i in range(0, len(self.points), 2):
                for j in range(i + 2, len(self.points), 2):
                    d = self.distance_between_points(self.points[i], self.points[i + 1], self.points[j], self.points[j + 1])
                    if d > self.max_line_length:
                        continue
                    opacity = 1 - (d / self.max_line_length)
                    Color(rgba=[*self.line_color, opacity])
                    Line(points=[self.points[i], self.points[i + 1], self.points[j], self.points[j + 1]], width=self.line_width)
                    Color(rgba=[*self.point_color, opacity])
                Ellipse(pos=(self.points[i] - self.point_radius, self.points[i + 1] - self.point_radius), size=(self.point_radius * 2, self.point_radius * 2))

    def update_positions(self, *args):
        step = 1
        for i, j in zip(range(0, len(self.points), 2), range(len(self.direction))):
            theta = self.direction[j]
            self.points[i] += step * math.cos(theta)
            self.points[i + 1] += step * math.sin(theta)

            if self.off_screen(self.points[i], self.points[i + 1]):
                self.direction[j] = 90 + self.direction[j]

        self.draw_lines()

    @staticmethod
    def distance_between_points(x1, y1, x2, y2):
        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5

    def off_screen(self, x, y):
        return x < -5 or x > self.width + 5 or y < -5 or y > self.height + 5

class TelepathManagerScreen(MenuBackground):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.name = self.__class__.__name__
        self.menu = 'init'
        self.background_color = constants.brighten_color(constants.background_color, -0.09)
        self.back_button = None
        self.help_button = None
        self.instances_button = None
        self.users_button = None
        self.pair_button = None
        self.api_input = None
        self.api_toggle = None
        self.host_input = None
        self.confirm_input = None
        self.load_icon = None
        self.page_speed = 0.15

        with self.canvas.before:
            self.canvas.clear()

        with self.canvas.before:
            self.color = Color(*self.background_color, mode='rgba')
            self.rect = Rectangle(pos=self.pos, size=self.size)

        # Layouts
        self.main_layout = None
        self.pair_layout = None
        self.confirm_layout = None

    def on_pre_enter(self, *args):
        constants.api_manager.pair_listen = True
        return super().on_pre_enter(*args)

    def on_pre_leave(self, *args):
        constants.api_manager.pair_listen = False
        return super().on_pre_leave(*args)

    def show_pair_input(self, back=False, show=True):
        self.pair_button.disabled = True
        if show:
            self.back_button.custom_func = self.main_menu
            if self.pair_layout:
                self.pair_layout.clear_widgets()

            self.pair_layout = FloatLayout()
            self.pair_layout.opacity = 0
            self.pair_layout.add_widget(InputLabel(pos_hint={"center_x": 0.5, "center_y": 0.55}))
            self.pair_layout.add_widget(HeaderText("Enter the IPv4/port you wish to connect", 'make sure "share this instance" is enabled on the server', (0, 0.75)))
            self.host_input = TelepathHostInput(pos_hint={"center_x": 0.5, "center_y": 0.45}, text='')
            self.pair_layout.add_widget(self.host_input)

            # Spinning pickaxe
            load_icon = Image()
            load_icon.id = "load_icon"
            load_icon.source = os.path.join(constants.gui_assets, 'animations', 'loading_pickaxe.gif')
            load_icon.size_hint_max = (self.host_input.height / 2.5, self.host_input.height / 2.5)
            load_icon.color = (0.6, 0.6, 1, 1)
            load_icon.pos_hint = {"center_y": 0.45}
            load_icon.allow_stretch = True
            load_icon.anim_delay = constants.anim_speed * 0.02
            load_icon.opacity = 0
            if self.load_icon and self.confirm_layout:
                self.confirm_layout.remove_widget(self.load_icon)
            self.load_icon = load_icon
            self.pair_layout.add_widget(load_icon)
            def recenter(*a):
                def r(*a):
                    load_icon.x = Window.center[0] - (self.host_input.width / 2) + 13
                Clock.schedule_once(r, 0)
            self.pair_layout.bind(pos=recenter, size=recenter)

            # Switch "screens"
            if back:
                def after(*a):
                    self.confirm_layout.opacity = 0
                    self.remove_widget(self.confirm_layout)
                    self.add_widget(self.pair_layout)
                    Animation(opacity=1, duration=self.page_speed).start(self.pair_layout)
                Animation.stop_all(self.confirm_layout)
                Animation(opacity=0, duration=self.page_speed).start(self.confirm_layout)
                Clock.schedule_once(after, self.page_speed + 0.05)

            else:
                def after(*a):
                    self.main_layout.opacity = 0
                    self.remove_widget(self.main_layout)
                    self.add_widget(self.pair_layout)
                    Animation(opacity=1, duration=self.page_speed).start(self.pair_layout)
                Animation.stop_all(self.main_layout)
                Animation(opacity=0, duration=self.page_speed).start(self.main_layout)
                Clock.schedule_once(after, self.page_speed + 0.05)

    def confirm_pair_input(self, ip: str, port: int, show=True):
        self.pair_button.disabled = True
        self.back_button.custom_func = functools.partial(self.show_pair_input, True)
        if show:
            if self.confirm_layout:
                self.confirm_layout.clear_widgets()

            self.confirm_layout = FloatLayout()
            self.confirm_layout.opacity = 0
            self.confirm_layout.add_widget(InputLabel(pos_hint={"center_x": 0.5, "center_y": 0.58}))
            self.confirm_layout.add_widget(HeaderText(f"Enter the pair code from:   $[color=#AAAAEE]{ip}[/color]$", 'if headless, use the "$telepath pair$" command', (0, 0.75)))
            self.confirm_input = TelepathCodeInput(ip, port, pos_hint={"center_x": 0.5, "center_y": 0.45}, text='')
            self.confirm_layout.add_widget(self.confirm_input)


            # Spinning pickaxe
            load_icon = Image()
            load_icon.id = "load_icon"
            load_icon.source = os.path.join(constants.gui_assets, 'animations', 'loading_pickaxe.gif')
            load_icon.size_hint_max = (self.host_input.height, self.host_input.height)
            load_icon.color = (0.6, 0.6, 1, 1)
            load_icon.pos_hint = {"center_y": 0.45}
            load_icon.allow_stretch = True
            load_icon.anim_delay = constants.anim_speed * 0.02
            load_icon.opacity = 0
            if self.load_icon and self.pair_layout:
                self.pair_layout.remove_widget(self.load_icon)
            self.load_icon = load_icon
            self.confirm_layout.add_widget(load_icon)
            def recenter(*a):
                def r(*a):
                    load_icon.x = Window.center[0] - (self.host_input.width / 2) + 30
                Clock.schedule_once(r, 0)
            self.confirm_layout.bind(pos=recenter, size=recenter)


            # Switch "screens"
            def after(*a):
                self.pair_layout.opacity = 0
                self.remove_widget(self.pair_layout)
                self.add_widget(self.confirm_layout)
                Animation(opacity=1, duration=self.page_speed).start(self.confirm_layout)
            Animation.stop_all(self.pair_layout)
            Animation(opacity=0, duration=self.page_speed).start(self.pair_layout)
            self.confirm_input.grab_focus()
            Clock.schedule_once(after, self.page_speed + 0.05)

    def main_menu(self):
        # Switch "screens"
        def after(*a):
            self.back_button.custom_func = None
            self.pair_button.disabled = False
            self.pair_layout.opacity = 0
            self.remove_widget(self.pair_layout)
            self.add_widget(self.main_layout)
            Animation(opacity=1, duration=self.page_speed).start(self.main_layout)
        Animation.stop_all(self.pair_layout)
        Animation(opacity=0, duration=self.page_speed).start(self.pair_layout)
        Clock.schedule_once(after, self.page_speed + 0.05)

    def recalculate_buttons(self, *a):
        try:
            self.main_layout.remove_widget(self.users_button)
        except:
            pass
        try:
            self.main_layout.remove_widget(self.instances_button)
        except:
            pass

        if constants.api_manager.authenticated_sessions and constants.app_config.telepath_settings['enable-api']:
            self.main_layout.add_widget(self.users_button)

            pair_pos = (0.5, 0.42)
            enable_pos = (0.5, 0.29)
            back_pos = (0.5, 0.13)

        elif constants.server_manager.telepath_servers:
            self.main_layout.add_widget(self.instances_button)

            pair_pos = (0.5, 0.42)
            enable_pos = (0.5, 0.29)
            back_pos = (0.5, 0.13)

        else:
            pair_pos = (0.5, 0.5)
            enable_pos = (0.5, 0.35)
            back_pos = (0.5, 0.17)

        self.pair_button.pos_hint = {'center_x': pair_pos[0], 'center_y': pair_pos[1]}
        self.api_input.pos_hint = {'center_x': enable_pos[0], 'center_y': enable_pos[1]}
        self.api_toggle.button.pos_hint = {'center_x': enable_pos[0], 'center_y': enable_pos[1]}
        self.api_toggle.knob.pos_hint = {"center_y": enable_pos[1]}
        self.back_button.text.pos_hint = self.back_button.button.pos_hint = {'center_x': back_pos[0], 'center_y': back_pos[1]}
        self.back_button.icon.pos_hint = {'center_y': back_pos[1]}

    def generate_menu(self, **kwargs):
        self.main_layout = FloatLayout()
        self.main_layout.opacity = 0

        # Add particle background and gradient on top
        particles = ParticleMesh()
        self.add_widget(particles)

        # Menu shadow
        shadow = Image(source=os.path.join(constants.gui_assets, 'menu_shadow.png'))
        shadow.color = self.background_color
        shadow.opacity = 0.8
        shadow.size_hint_max = (600, 600)
        shadow.allow_stretch = True
        shadow.keep_ratio = False
        shadow.pos_hint = {'center_x': 0.5, 'center_y': 0.5}
        self.add_widget(shadow)

        gradient = Image(source=os.path.join(constants.gui_assets, 'telepath_gradient.png'))
        gradient.size_hint_max = (None, None)
        gradient.allow_stretch = True
        gradient.keep_ratio = False
        gradient.opacity = 0.6
        gradient.color = constants.brighten_color(self.background_color, 0.03)
        self.add_widget(gradient)


        # Help button
        def show_help():
            help_text = """$Telepath$ is an $auto-mcs$ protocol to control remote sessions seamlessly. For example, $Telepath$ can connect a local computer to an instance of $auto-mcs$ running on a different computer, or a VPS in the cloud.
            
To connect via $Telepath$, enable â€œshare this instanceâ€ on the server you intend to connect. Then click â€œPair a Serverâ€ on the client and follow the prompts.

Once paired, remote servers will appear in the Server Manager and can be interacted with like normal. You can also import or create a server on a $Telepath$ instance."""

            Clock.schedule_once(
                functools.partial(
                    self.show_popup,
                    "controls",
                    "About $Telepath$",
                    help_text,
                    (None)
                ),
                0
            )
        self.help_button = IconButton('help', {}, (70, 60), (None, None), 'question.png', clickable=True, anchor='right', click_func=show_help)
        self.add_widget(self.help_button)



        # Add telepath logo
        logo = Image(source=os.path.join(constants.gui_assets, 'telepath_logo.png'), allow_stretch=True, size_hint=(None, None), width=dp(400), pos_hint={"center_x": 0.5, "center_y": 0.77})
        logo.color = (0.8, 0.8, 1, 0.9)
        self.main_layout.add_widget(logo)

        session_splash = Label(pos_hint={"center_y": 0.7}, color=(0.7, 0.7, 1, 0.4), font_name=os.path.join(constants.gui_assets, 'fonts', constants.fonts['medium']), font_size=sp(25))
        session_splash.text = 'simplified remote access'
        self.main_layout.add_widget(session_splash)


        # Logic-driven button visibility
        def user_manager(*a):
            screen_manager.current = "TelepathUserScreen"
        def instance_manager(*a):
            screen_manager.current = "TelepathInstanceScreen"
        self.users_button = color_button("MANAGE USERS", position=(0.5, 0.55), icon_name='person-sharp.png', click_func=user_manager, color=(0.8, 0.8, 1, 1))
        self.instances_button = color_button("MANAGE INSTANCES", position=(0.5, 0.55), icon_name='settings-sharp.png', click_func=instance_manager, color=(0.8, 0.8, 1, 1))
        self.pair_button = color_button("PAIR A SERVER", position=(0.5, 0.5), icon_name='telepath.png', click_func=functools.partial(self.show_pair_input, False), color=(0.8, 0.8, 1, 1))
        self.main_layout.add_widget(self.pair_button)


        # Enable API toggle button
        def toggle_api(state, only_input=False, *a):
            if not only_input:
                constants.app_config.telepath_settings['enable-api'] = state
                constants.app_config.save_config()
                text = 'enabled' if state else 'disabled'
                constants.telepath_banner(f'$Telepath$ API is now {text}', state)

            # Update hint text
            if state:
                port = constants.api_manager.port
                ip = constants.api_manager.host
                if ip == '0.0.0.0':
                    ip = constants.get_private_ip()
                if constants.public_ip:
                    if constants.check_port(constants.public_ip, port, 0.05):
                        ip = constants.public_ip
                new_text = f">   {ip}:{port}"
                self.api_input.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["italic"]}.ttf')
                self.api_input.hint_text_color = (0.6, 0.9, 1, 1)
                constants.api_manager.start()

            else:
                new_text = 'share this instance'
                self.api_input.hint_text_color = (0.6, 0.6, 1, 0.8)
                self.api_input.font_name = os.path.join(constants.gui_assets, 'fonts', f'{constants.fonts["medium"]}.ttf')
                constants.api_manager.stop()

            self.api_input.hint_text = new_text
        sub_layout = RelativeLayout()
        self.api_input = blank_input(pos_hint={"center_x": 0.5, "center_y": 0.35}, hint_text="share this instance")
        self.api_toggle = toggle_button('api', (0.5, 0.35), default_state=constants.app_config.telepath_settings['enable-api'], custom_func=toggle_api)
        sub_layout.add_widget(self.api_input)
        sub_layout.add_widget(self.api_toggle)
        self.main_layout.add_widget(sub_layout)
        if constants.app_config.telepath_settings['enable-api']:
            toggle_api(True, True)

        Clock.schedule_once(self.recalculate_buttons, 0)


        # Static content on each page
        self.add_widget(generate_footer('$Telepath$', no_background=True))
        self.add_widget(self.main_layout)
        Animation(opacity=1, duration=1).start(self.main_layout)
        self.back_button = ExitButton('Back', (0.5, 0.17), cycle=True)
        self.add_widget(self.back_button)


# Telepath notifications and pairing
class TelepathPair():
    def __init__(self):
        self.is_open = False
        self.pair_data = {}

    def close(self):
        if not self.is_open:
            return

        current_user = constants.api_manager.current_users[self.pair_data['host']['ip']]
        if current_user and current_user['host'] == self.pair_data['host']['host'] and current_user['user'] == self.pair_data['host']['user']:
            message = f"Successfully paired with '${current_user['host']}/{current_user['user']}$'"
            color = (0.553, 0.902, 0.675, 1)
            sound = 'popup_telepath_success.wav'
        else:
            message = f'$Telepath$ pair request expired'
            color = (0.937, 0.831, 0.62, 1)
            sound = 'popup_warning.wav'

        # Reset token if cancelled
        if constants.api_manager.pair_data:
            constants.api_manager.pair_data = {}

        Clock.schedule_once(
            functools.partial(
                screen_manager.current_screen.show_banner,
                color,
                message,
                "telepath.png",
                2.5,
                {"center_x": 0.5, "center_y": 0.965},
                sound
            ), 0.1
        )

        self.is_open = False
        self.pair_data = {}

    def open(self, data: dict):
        if self.is_open:
            return

        self.pair_data = data

        # If the application is blocked, wait until it's not to show the pop-up
        def wait_thread(*a):
            self.is_open = True
            while constants.ignore_close or screen_manager.current_screen.popup_widget:
                time.sleep(1)

            Clock.schedule_once(
                functools.partial(
                    screen_manager.current_screen.show_popup,
                    "pair_request",
                    " ",
                    self.pair_data,
                    self.close
                ), 0
            )

        threading.Timer(0, wait_thread).start()
constants.telepath_pair = TelepathPair()

# Telepath banner endpoint for sending remote notifications
def telepath_banner(message: str, finished: bool, play_sound=None):
    screen = screen_manager.current_screen

    if screen.show_banner:
        Clock.schedule_once(
            functools.partial(
                screen.show_banner,
                (0.553, 0.902, 0.675, 1) if finished else (0.937, 0.831, 0.62, 1),
                message,
                "checkmark-circle-sharp.png" if finished else "telepath.png",
                3,
                {"center_x": 0.5, "center_y": 0.965},
                play_sound
            ), 0.1
        )

    # Refresh Telepath home screen
    if screen.name == 'TelepathManagerScreen':
        Clock.schedule_once(screen.recalculate_buttons, 0)

    # Refresh user list if visible
    if screen.name == 'TelepathUserScreen' and not screen.popup_widget:
        Clock.schedule_once(lambda *_: screen.gen_search_results(fade_in=False), 0)

constants.telepath_banner = telepath_banner
telepath.create_endpoint(constants.telepath_banner, 'main', True)

# Handle UI logic when telepath session gets disconnected
def telepath_disconnect():
    try:
        # This is handled in MenuBackground.on_pre_enter()
        if constants.server_manager.current_server:
            constants.server_manager.current_server._disconnected = True
    except AttributeError:
        pass
constants.telepath_disconnect = telepath_disconnect

def check_telepath_disconnect():
    sm = constants.server_manager
    server_obj = sm.current_server

    if server_obj:
        telepath_data = server_obj._telepath_data
        if telepath_data:

            # Make a better health check at some point, this is really expensive with latency
            server_obj._check_object_init()
            if server_obj._disconnected:
                sm.current_server = None

                if telepath_data and screen_manager.current_screen.name not in ['MainMenuScreen', 'ServerManagerScreen']:
                    constants.server_manager.refresh_list()
                    screen_manager.current = 'ServerManagerScreen'
                    constants.screen_tree = ['MainMenuScreen']

                server_name = telepath_data['nickname'] if telepath_data['nickname'] else telepath_data['host']
                telepath_banner(f"Lost connection to $'{server_name}'$", False)
                return True

    return False




# </editor-fold> ///////////////////////////////////////////////////////////////////////////////////////////////////////




# ======================================================================================================================
screen_manager = ScreenManager()
# ======================================================================================================================


# .kv file
kv_file = '''
'''


# Run application and startup preferences
def check_running(final_func):
    running = constants.server_manager.running_servers

    # Issue stop command to all running servers to quit gracefully
    def close_servers(*args):
        for server in running.values():
            threading.Timer(0, functools.partial(server.silent_command, "stop")).start()

        if final_func:
            final_func()

    # If there are running servers, prompt user before exiting
    if running:
        server_count = len(list(running.keys()))

        if server_count == 1:
            desc = "There is currently 1 server running. To continue, it will be closed.\n\nAre you sure you want to continue?"
        else:
            desc = f"There are currently ${server_count}$ servers running. To continue, they will be closed.\n\nAre you sure you want to continue?"

        popup = screen_manager.current_screen.popup_widget
        if popup:
            popup.self_destruct(screen_manager.current_screen, False)
            screen_manager.current_screen.canvas.after.clear()

        Clock.schedule_once(
            functools.partial(
                screen_manager.current_screen.show_popup,
                "warning_query",
                f'Server Warning',
                desc,
                (None, close_servers)
            ),
            1 if popup else 0
        )

    # If there aren't running server, execute function normally
    elif final_func:
        final_func()

def exit_app():
    amseditor.quit_ipc = True
    sys.exit(0)

class MainApp(App):

    # Disable F1 menu when compiled
    if constants.app_compiled:
        def open_settings(self, *largs):
            pass

    # Check if window pos is set in config
    preconfigured = False
    if constants.app_config.geometry:
        constants.last_window = constants.app_config.geometry
        pos = constants.app_config.geometry['pos']
        size = constants.app_config.geometry['size']
        if (size[0] >= constants.window_size[0] and size[1] >= constants.window_size[1] - 50) and (pos[0] > -5000 and pos[1] > -5000):
            Window.size = size
            Window.left = pos[0]
            Window.top = pos[1]
            preconfigured = True

    # Window size
    if not preconfigured:
        size = constants.window_size

        # Get pos and knowing the old size calculate the new one
        top = dp((Window.top * Window.size[1] / size[1])) - dp(50)
        left = dp(Window.left * Window.size[0] / size[0])

        Window.size = (dp(size[0]), dp(size[1]))
        Window.top = top
        Window.left = left
    Window.on_request_close = functools.partial(sys.exit)

    Window.minimum_width = constants.window_size[0]
    Window.minimum_height = constants.window_size[1] - 50
    Window.clearcolor = constants.background_color
    Builder.load_string(kv_file)

    # Prevent window from closing during certain situations
    def exit_check(self, force_close=False, *args):

        # Write window size to global config
        save_window_pos()
        constants.app_config.fullscreen = (Window.width > (constants.window_size[0] + 400))
        constants.app_config.geometry = constants.last_window

        if force_close:
            Window.close()
            return False

        if constants.ignore_close:
            return True

        elif constants.server_manager.running_servers:
            check_running(Window.close)
            return True

        else:
            Window.close()
            return False

    def _close_window_wrapper(self):
        data = main_app.exit_check()
        if not data:
            exit_app()
        return data
    Window.bind(on_request_close=_close_window_wrapper)
    Window.bind(on_cursor_enter=save_window_pos, on_cursor_leave=save_window_pos)
    dropped_files = []
    processing_drops = False

    def build(self):
        Window.bind(on_dropfile=self.file_drop)

        self.icon = os.path.join(constants.gui_assets, "big-icon.png")
        # Loader.loading_image = os.path.join(constants.gui_assets, 'empty.png')

        # Dynamically add every class with the name '*Screen' to ScreenManager
        screen_list = [x[0] for x in inspect.getmembers(sys.modules[__name__], inspect.isclass) if x[0].endswith('Screen') and x[0] != 'Screen']
        # print(screen_list)
        for screen in screen_list:
            screen_manager.add_widget(globals()[screen]())

        constants.app_loaded = True
        screen_manager.transition = NoTransition()
        screen_manager.current = constants.startup_screen

        screen_manager.transition = FadeTransition(duration=0.115)

        # Close splash screen if compiled
        if constants.app_compiled and constants.os_name == 'windows':
            import pyi_splash
            pyi_splash.close()

        if constants.app_config.fullscreen:
            Window.maximize()
        Window.show()

        # Raise window
        def raise_window(*a):
            Window.raise_window()
        Clock.schedule_once(raise_window, 0)


        # Screen manager override for testing
        # if not constants.app_compiled:
        #    pass



        # Process --launch flag
        if constants.boot_launches:
            if not constants.is_admin() or constants.bypass_admin_warning:

                def launch_server(*_):
                    for server in constants.boot_launches:
                        def open_menu(*args):
                            open_server(server, wait_page_load=True, ignore_update=False, launch=True)
                        Clock.schedule_once(open_menu, 0.5)

                        if len(constants.boot_launches) > 1:
                            while server not in constants.server_manager.running_servers:
                                time.sleep(0.5)
                            Clock.schedule_once(previous_screen, 1.5)
                            time.sleep(2)

                threading.Timer(0, launch_server).start()

        return screen_manager


    # Executes function on file drop
    def file_drop(self, w, path):
        def process_drops(*a):
            if not self.processing_drops and self.dropped_files:
                self.processing_drops = True


                if screen_manager.current == 'CreateServerAddonScreen':
                    banner_text = ''
                    for addon in self.dropped_files:
                        if addon.endswith(".jar") and os.path.isfile(addon):
                            addon = addons.get_addon_file(addon, constants.new_server_info)
                            constants.new_server_info['addon_objects'].append(addon)
                            screen_manager.current_screen.gen_search_results(
                                constants.new_server_info['addon_objects'])

                            # Switch pages if page is full
                            if (len(screen_manager.current_screen.scroll_layout.children) == 0) and (len(constants.new_server_info['addon_objects']) > 0):
                                screen_manager.current_screen.switch_page("right")

                            # Show banner
                            if len(self.dropped_files) == 1:
                                if len(addon.name) < 26:
                                    addon_name = addon.name
                                else:
                                    addon_name = addon.name[:23] + "..."

                                banner_text = f"Added '${addon_name}$' to the queue"
                            else:
                                banner_text = f"Added ${len(self.dropped_files)}$ add-ons to the queue"

                    if banner_text:
                        Clock.schedule_once(
                            functools.partial(
                                screen_manager.current_screen.show_banner,
                                (0.553, 0.902, 0.675, 1),
                                banner_text,
                                "add-circle-sharp.png",
                                2.5,
                                {"center_x": 0.5, "center_y": 0.965}
                            ), 0
                        )

                if screen_manager.current == 'ServerAddonScreen':
                    addon_manager = constants.server_manager.current_server.addon
                    banner_text = ''
                    for addon in self.dropped_files:
                        if addon.endswith(".jar") and os.path.isfile(addon):
                            addon = addon_manager.import_addon(addon)
                            addon_list = addon_manager.return_single_list()
                            screen_manager.current_screen.gen_search_results(addon_manager.return_single_list(), fade_in=False, highlight=addon.hash, animate_scroll=True)

                            # Switch pages if page is full
                            if (len(screen_manager.current_screen.scroll_layout.children) == 0) and (len(addon_list) > 0):
                                screen_manager.current_screen.switch_page("right")

                            # Show banner
                            if len(self.dropped_files) == 1:
                                if len(addon.name) < 26:
                                    addon_name = addon.name
                                else:
                                    addon_name = addon.name[:23] + "..."

                                banner_text = f"Imported '${addon_name}$'"
                            else:
                                banner_text = f"Imported ${len(self.dropped_files)}$ add-ons"

                    if banner_text:

                        # Show banner if server is running
                        if addon_manager._hash_changed():
                            Clock.schedule_once(
                                functools.partial(
                                    screen_manager.current_screen.show_banner,
                                    (0.937, 0.831, 0.62, 1),
                                    f"A server restart is required to apply changes",
                                    "sync.png",
                                    3,
                                    {"center_x": 0.5, "center_y": 0.965}
                                ), 0
                            )

                        else:
                            Clock.schedule_once(
                                functools.partial(
                                    screen_manager.current_screen.show_banner,
                                    (0.553, 0.902, 0.675, 1),
                                    banner_text,
                                    "add-circle-sharp.png",
                                    2.5,
                                    {"center_x": 0.5, "center_y": 0.965}
                                ), 0
                            )

                if screen_manager.current == 'ServerAmscriptScreen':
                    script_manager = constants.server_manager.current_server.script_manager
                    if self.dropped_files:
                        banner_text = ''
                        for script in self.dropped_files:
                            if script.endswith(".ams") and os.path.isfile(script):
                                script = script_manager.import_script(script)
                                if not script:
                                    continue

                                script_list = script_manager.return_single_list()
                                screen_manager.current_screen.gen_search_results(script_manager.return_single_list(), fade_in=False, highlight=script.hash, animate_scroll=True)

                                # Switch pages if page is full
                                if (len(screen_manager.current_screen.scroll_layout.children) == 0) and (len(script_list) > 0):
                                    screen_manager.current_screen.switch_page("right")

                                # Show banner
                                if len(self.dropped_files) == 1:
                                    if len(script.title) < 26:
                                        script_name = script.title
                                    else:
                                        script_name = script.title[:23] + "..."

                                    banner_text = f"Imported '${script_name}$'"
                                else:
                                    banner_text = f"Imported ${len(self.dropped_files)}$ scripts"

                        if banner_text:

                            # Show banner if server is running
                            if script_manager._hash_changed():
                                Clock.schedule_once(
                                    functools.partial(
                                        screen_manager.current_screen.show_banner,
                                        (0.937, 0.831, 0.62, 1),
                                        "An amscript reload is required to apply changes",
                                        "sync.png",
                                        3,
                                        {"center_x": 0.5, "center_y": 0.965}
                                    ), 0
                                )

                            else:
                                Clock.schedule_once(
                                    functools.partial(
                                        screen_manager.current_screen.show_banner,
                                        (0.553, 0.902, 0.675, 1),
                                        banner_text,
                                        "add-circle-sharp.png",
                                        2.5,
                                        {"center_x": 0.5, "center_y": 0.965}
                                    ), 0
                                )


                def enable(*a):
                    self.processing_drops = False
                self.dropped_files = []
                Clock.schedule_once(enable, 1)


        self.dropped_files.append(path.decode())
        if not self.processing_drops and self.dropped_files:
            Clock.schedule_once(process_drops, 0.1)


main_app = None
def run_application():
    global main_app
    main_app = MainApp(title=constants.app_title)
    try:
        main_app.run()
        if constants.os_name == 'macos':
            Window.close()
    except ArgumentError:
        pass
    except Exception as e:
        Window.close()
        raise e
